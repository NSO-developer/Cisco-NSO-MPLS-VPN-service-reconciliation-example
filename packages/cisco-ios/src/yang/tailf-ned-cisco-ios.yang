
// =========================================================================
//                          CISCO-IOS NED
// =========================================================================

module tailf-ned-cisco-ios {
  namespace "urn:ios";
  prefix ios;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2015-03-16 {
    description
      "3.8.0
      Enhancements:
      Support for NCS-3.4.
      Removed all specific snmp-server enable traps. Replaced by generic list.
      Additions to the YANG model:
       csdb tcp|udp|icmp|session
       snmp-server queue-limit notification-host
       router bgp * / bgp additional-paths
       interface pseudowire * / service-policy
       interface * / xconnect encapsulation / mtu
       interface * / switchport private-vlan
       interface * / wrr-queue dscp-map *
       interface * / priority-queue dscp-map *
       interface * / priority-queue queue-limit
      Merged cloudvpn-develop (commit: 13d3dc9 from 2015-03-05):
       Enhancements:
        Added license command under live-status, e.g.:
         devices device csr1000v live-status exec license smart deregister
        Implemented support for 'default' exec commands in config mode, e.g.:
         devname(config) default crypto ikev2 authorization policy
        Additions to the YANG model:
         aaa attribute list *
         class-map * / match protocal attribute category *
         crypto dynamic-map *
         crypto ikev2 profile * / aaa authorization group
         crypto ikev2 authorization policy *
         crypto ikev2 keyring * / peer * / identity
         crypto ikev2 profile * / nat keepalive
         crypto ikev2 profile * / match fvrf
         crypto isakmp nat
         crypto isakmp profile *
         crypto keyring *
         crypto map * ipsec-isakmp|ipsec-manual
         crypto logging ikev2
         ip dhcp pool * / vrf
         ip nat inside source route-map *
         ip sla * / * / vrf
         ip ssh stricthostkeycheck
         logging source-interface * vrf
         pnp startup-vlan
         pnp tag
         .. and more minor additions ..
       Corrections:
        Remove ip sla entry before modifying it upon error from device.
        Modifications in the YANG model:
         aaa accounting exec *
         crypto ikev2 profile * / authentication
         crypto isakmp policy * / encryption
         crypto map *
         interface * / ipv6 nd ra suppress
         interface * / ntp multicast client
         ip nat outside source
         pnp profile * / transport
         .. and more minor various bugfixes ..
      Corrections:
       Changed router * / passive-interface from a leaf to a list.
       Fixed deletion of 'no passive-interface' on router config.
       Bugfixed router eigrp and router rip.
       Fixed order dependancy between service instance and ethernet evc.
      ";
  }

  revision 2015-03-04 {
    description
      "3.7.0.3
      Enhancements:
       Additions to the YANG model:
        interface * / l2protocol-tunnel lldp
        interface * / l2protocol point-to-point
      Corrections:
       Fixed dependency issues:
       On Catalyst devices there is a dependency between:
        interface * / switchport and interface * / l2protocol-tunnel.
       The config under l2protocol-tunnel must always be deleted before
        switchport is deleted.
       The same dependency also applies to
        interface * / switchport and interface * / service.
      ";
  }

  revision 2015-02-19 {
    description
      "3.7.0.1
      Enhancements:
       Added interface BRI and Async basic configuration.
       Populated router bgp * / peer-policy & peer-session lists.
       Expanded policy-map class random-detect config.
      Corrections:
       Numerous router rip,ospf,ospfv3,isis and bgp bug fixes.
      ";
  }

  revision 2015-02-13 {
    description
      "3.6.0
      Enhancements:
      Corrections:
       Do not delete config in set-hook's if talking Netconf.
      ";
  }

  revision 2015-02-11 {
    description
      "3.5.0.7
      Enhancements:
      Corrections:
       Improved expect of sent commands at login, solving login problems
        on asr903 device.
       Bugfixed copy, reload and traceroute commands under live-status.
       Removed auto-create of vlan when configuring bridge-domain.
       Fixed order dependancy problem with service-policy.
      ";
  }

  revision 2015-02-09 {
    description
      "3.5.0.6
      Enhancements:
       Expanded ethernet cfm config.
       Added aaa accounting update periodic config.
       Added interface ip ospf authentication config.
       Added numerous ASR903/ASR920 L2 config.
       Added ip tcp mss config.
       Added copy, reload and traceroute commands under live-status.
      Corrections:
       Remodelled ethernet cfm service evc to list.
      ";
  }

  revision 2015-01-28 {
    description
      "3.5.0.5
      Enhancements:
       Expanded cable config.
       Support for vlan ranges in service instance encapsulation dot1q config.
       Added generic snmp-server enable traps list accepting all entries.
       Expanded router lisp config.
      Corrections:
       Restored router bgp / address family ipv6 configuration mode.
       Fixed banner config bug which ended in additional 'C' in message.
      ";
  }

  revision 2015-01-12 {
    description
      "3.5.0.4
      Enhancements:
       Added support for ip explicit-path identifier.
       Added cable modulation-profile, tag, service, qos, filter, submgmt,
         logging, sflog, docsis30-voice, util-interval, clock, dsg and
         load-balance config.
       Added basic interface Cable config.
      Corrections:
       Reworked ip explicit-path to support delete/modify of entries by making
        index value for next-address and exclude-address mandatory.
      ";
  }

  revision 2014-12-19 {
    description
      "3.5.0.3
      Enhancements:
       Added support for aaa accounting connection. (RT17164)
       Added support for sub-interface Port-channel #.#
       Automatically delete channel-group and shutdown dependant ethernet
        interfaces when Port-channel interface is deleted. (RT17422 / #12304)
       General config expansion for improved MPLS and L2VPN support.
      Corrections:
       Reworked aaa accounting lists method options. (RT17164)
       Fixed bug in router ospf * / redistribute bgp|eigrp config.
       Fixed bug with setting banners. (RT17300 / #12300). Removed
        delimiter config to avoid compare config diff.
       Fixed ordering problem when deleting switchport mode trunk and
        switchport trunk encapsulation dot1q. (RT17421 / #12312)
       Do not delete switchport container when member leaves are deleted.
      ";
  }

  revision 2014-12-10 {
    description
      "3.5.0.2
      Enhancements:
       Added basic support for cable l2vpn and cable  dot1q-vc-map
      Corrections:
      ";
  }

  revision 2014-12-03 {
    description
      "3.5.0.1
      Enhancements:
      Corrections:
       Reworked aaa authentication and authorization lists method options.
        Non-backwards compatible 'aaa authorization network' model.
      ";
  }

  revision 2014-12-01 {
    description
      "3.4.0
      Enhancements:
       Support for NCS-3.3.
       YANG data model updates: mls qos map ip-prec-dscp (R17250).
       Added ping and clear exec commands under live-status, e.g.:
        devices device c7200 live-status exec ping 192.168.1.1
        devices device c7200 live-status exec clear ppp queues
      Corrections:
      ";
  }

  revision 2014-11-19 {
    description
      "3.3.0.1
      Enhancements:
       Added basic support for new L2VPN config, YANG data model adds:
        interface pseudowire
        l2vpn xconnect context
       Added route-map / continue config.
       Updated for new NCS features 'trim-defaults' which hides config
        set to default values.
      Corrections:
       Fixed problem with route-map * / set community reordering values.
       Remove ip prefix sequence entry before modifying it.
       Fixed problem with deleting ip vrf *, bad prefix used.
       Ignore incomplete crypto profile warning.
      ";
  }

  revision 2014-11-05 {
    description
      "3.2.0
       Master merge and release.
      ";
  }

  revision 2014-11-04 {
    description
      "3.1.4.4
      Enhancements:
       Added ncs java log and ned trace print of TransactionId.
       Added crypto ssl support.
       Added crypto pki enroll <name> command.
       Added crypto pki trustpoint create&remove hook for automatic creation
        and removal of corresponding pki certificate chain.
       Added pnp profile config.
       Cleaned up router rip config.
      Corrections:
       Fixed policy-map / class / bandwidth percent modification bug.
       Fixed dependency between interface switchport and service instance
        delete.
       Removed 'no switchport' lines on all device types.
       Bugfixed ipv6 route.
       Bugfixed snmp-server host vrf.
       Bugfixed router ospf vrf.
      ";
  }

  revision 2014-10-24 {
    description
      "3.1.4.3
      Enhancements:
       General config expansion in multiple areas.
       Added l3vpn encapsulation ip config.
       Added track config.
       Simplified event manager applet / action to support all commands.
       Expanded ip pim, using grouping from ip pim vrf *.
      Corrections:
       Bugfixed policy-map / class / random-detect precedence-based.
        In order to delete and create two different xxx-based configs
        in the same transaction, ncs-3.2.2.2 or newer is required.
      ";
  }

  revision 2014-10-21 {
    description
      "3.1.4.2
      Enhancements:
        Added connect command.
        Expanded ip mobile router config.
        Added controller Cellular *
        Implemented support for 'crypto pki server <cs-lbl> [rollover [cancel]]
         exec commands in config mode.
        Introduced 'tailfned police' options: cirmode|cirflat|bpsflat|numflat
        Added bridge-domain hook for auto creating vlans with same <id>.
      Corrections:
        Repaired support for multiple certificates.
        Only add/delete ip route-cache with switchport mods for me340x devices.
        Improved access-list patterns (removed no.*) to only add valid entries.
        Bugfixed policy-map / class / random-detect dscp and discard.
        Reworked and bugfixed all routers 'distribute-list' lists.
      ";
  }

  revision 2014-10-13 {
    description
      "3.1.4.1
      Enhancements:
        Added tailfned config container for device specific config control.
        Added REMOVE hooks on /ip/vrf and /vrf/definition lists to
         automatically delete routes on same vrf.
        Added 'backup peer' and 'synchronous mode' interface commands.
        Disabled device-specific policy-map/class/police config.
        Added support for c7350 policy-map/class/police command syntax.
        Reworked interface switchport support with special support for c7600.
      Corrections:
        Fixed problem with 'no media-type' clearing duplex on interface.
        Fixed ip domain-name, domain-list and domain-lookup sync from device.
        Minor update for XE BGP neighbor remote-as leaf value.
        Reworked xconnect in interface and interface service instance.
      ";
  }

  revision 2014-09-30 {
    description
      "3.1.3.2
       Minor update for XE BGP neighbor remote-as leaf value.
      ";
  }

  revision 2014-09-26 {
    description
      "3.1.3.1
      Enhancements:
        Expanded mobile ip and dialer config.
        Expanded LISP config.
        Expanded crypto config.
      Corrections:
        Change argument to setTimeout() from seconds to millisecs in
         NED Java code due to NCS NED API change.
      ";
  }

  revision 2014-09-24 {
    description
      "3.1.2.1
      Enhancements:
       Implemented support for 'show' commands under live-status exec, e.g.
        devices device c7200 live-status exec show running-config brief
       Implemented support for 'crypto key' exec commands in config mode.
       Expanded crypto settings.
       Reviewed and reordered /ipv6 config.
       Reworked 'ipv6 route' list config to support all interfaces.
       Reviewed and reordered /aaa config.
       Numerous order rearrangements made from testing on a c7200.
      Corrections:
       Reviewed, reordered and bugfixed /service config.
       Reviewed, reordered and bugfixed /vrf definition config.
       Reviewed, reordered and bugfixed /ip config.
      ";
  }

  revision 2014-09-19 {
    description
      "3.1.1.1
      Enhancements:
       Added basic crypto isakmp and crypto ipsec support.
       Moved policy-map description to before class.
      Corrections:
       Fixed order dependency issues in policy-map/class/police when switching
         between an aggregate and policer.
         NOTE: Requires support for 'tailf:cli-trigger-on-set' option.
       Bugfixed mls qos srr-queue.
      ";
  }

  revision 2014-09-16 {
    description
      "3.0.3.3
      Enhancements:
       Expanded mls qos srr-queue.
      Corrections:
      ";
  }

  revision 2014-09-15 {
    description
      "3.0.3.2
      Enhancements:
      Corrections:
       Moved policy-map/class/police aggregate out of police choice.
      ";
  }

  revision 2014-08-18 {
    description
      "3.0.3.1
      Enhancements:
      Corrections:
       Display 'switchport port-security' on a separate line.
       Added cli-show-no to shutdown leaf in in order to be able to bring
         down (send 'no shutdown') interface after creation.
      ";
  }

  revision 2014-08-07 {
    description
      "Added support for 'sequence' keyword to ipv6 access-list
       Added interface-ethernet-grouping to Port-channel interface
       Added error check: 'please remove the service-policy on the zone-pair'
       Added error check: 'in use, cannot'
       Moved table-map,mls,policer,class-map and policy-map to before interface
       Remodelled interface/ip access-group to support both in and out entries
       Removed 'ntp clock-period' because auto changed by device
      ";
  }

  revision 2014-07-02 {
    description
      "Fixed issue with remove before change on the following leafs:
       interface * / service-policy / input
       interface * / service-policy / output
      ";
  }

  revision 2014-06-27 {
    description
      "Implemented basic crypto ikev2 config support.
       Added other single config items in various areas.
      ";
  }

  revision 2014-06-26 {
    description
      "Implemented basic VoIP config support.
       Added other single config items in various areas.
      ";
  }

  revision 2014-06-19 {
    description
      "Added minimal router eigrp support.
       Populated ip dhcp pool config.
       Reworked card config.
       Added other single config items in various areas.
      ";
  }

  revision 2014-06-16 {
    description
      "Expanded ip pim vrf config.
      ";
  }

  revision 2014-06-13 {
    description
      "Added storm-control action shutdown|trap config items.
       Added Ethernet interface.
       Expanded Tunnel interface config.
       Added minimal ip explicit-path config.
       Added minimal pseudowire-class config.
       Added ip flow-aggregation cache config.
       Added other single config items in various areas.
      ";
  }

  revision 2014-06-11 {
    description
      "Additional config supported for PPP/Ethernet/Frame Relay Bundled Service
          and Ethernet MPLS L2VPN.
       Added MFR - Multilink Frame Relay bundle - (sub)interface.
       Added Tunnel interface.
      ";
  }

  revision 2014-05-26 {
    description
      "Implemented full support for NTP configuration, modified/expanded:
          ntp and interface / ntp commands.
       Implemented full support for SNTP configuration, implemented:
          sntp command.
      ";
  }

  revision 2014-05-21 {
    description
      "Implemented full support for DNS configuration, modified/expanded:
          ip host, ip name-server and ip domain commands.
      ";
  }

  revision 2014-05-09 {
    description
      "Added support for match config in router bgp redistribute ospf list
      ";
  }

  revision 2014-04-29 {
    description
      "Expanded various config, mainly in routing areas
       Added config error check for 'not configured'
       Added support for interface service instance config
      ";
  }

  revision 2014-04-04 {
    description
      "Added basic support for Locator/ID Separation Protocol (LISP)
      ";
  }

  revision 2014-02-12 {
    description
      "Fixed show live-status for interfaces.
      ";
  }

  revision 2014-02-10 {
    description
      "[ip] vrf forwarding fix on interfaces.
      ";
  }

  revision 2014-02-06 {
    description
      "Fixed interface 'no ip address' bug
       Preliminary IOS XE support work
       Added 'interface Virtual-Template *'
       Added 'interface * / peer default ip' support'
       Expanded 'interface * / ppp' support'
       Merged interface encapsulation config (API change)
       Merged all fixes/adds in confd-4.3 ios-xe between r59179 and r65905.
      ";
  }

  revision 2014-01-30 {
    description
      "Merged from confd-5.0.
       Expanded 'ip nat'
      ";
  }

  revision 2014-01-28 {
    description
      "Fixed bugs in 'ip route'. API changes to list due to variable
       number of keys.
      ";
  }

  revision 2013-12-09 {
    description
      "Police and policer work
      ";
  }

  revision 2013-11-25 {
    description
      "API-cleaning for Juniper and bugfixes
       Made cir,bc and be keywords mandatory in policy-map/class police
      ";
  }

  revision 2013-11-12 {
    description
      "Rewrote police-map/class police command to support more combos";
  }

  revision 2013-10-14 {
    description
      "Merged all yang files to one file.";
  }

  revision 2013-08-15 {
    description
      "Added switchport commands
       Added spanning-tree top level commands
       Added a number of SNMP traps
       Added support for OSPFv3
       Added support for IPv6 prefix-lists
    ";

  }

  revision 2013-08-08 {
    description
      "Added support for Cisco 7600 constructs.";
  }

  revision 2013-06-25 {
    description
      "Renamed YANG module, submodule and namespace.";
  }

  revision 2013-04-18 {
    description
      "Restructuring using new file ios-common0.yang and
        augment(s) in order to fix order dependencies.
       Added model constructs for Cisco 2800.
      ";
  }


  // =========================================================================
  // TODO
  // =========================================================================
  // fix 'interface / ip mobile router-service collocated' config
  // service alignment logging
  // ip interface / route-cache & ip route-cache cef
  // ip sla * / udp-jitter remove before change bug
  // RT17387: redistribute external 1 external 2 support, #12306
  // remove channel-group and set shutdown when deleting Port-channel, #12304
  //


  // =========================================================================
  // TYPEDEF
  // =========================================================================

  //typedef boolean-no-type {
  //tailf:cli-boolean-no;
  //type boolean;
  //}

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  // IPv4 prefix (address and mask length) in A.B.C.D/P format
  typedef ipv4-prefix {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
  }

  // IPv6 prefix in standard format
  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
        + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
        + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
        + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
        + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
        + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
        + '(/.+)';
    }
  }

  // Host type, clean
  typedef host-type {
    type union {
      type inet:ip-address {
        tailf:info "";
      }
      type inet:domain-name {
        tailf:info "";
      }
    }
  }

  // Host type, v4-v6
  typedef host-v4v6-type {
    type union {
      type inet:ipv4-address {
        tailf:info "Hostname or A.B.C.D;;ip address or host name";
      }
      type inet:domain-name {
        tailf:info "";
      }
      type inet:ipv6-address {
        tailf:info "X:X:X:X::X;;IPv6 address";
      }
    }
  }

  // Router Distinguisher
  typedef rd-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
      pattern '(\d*(.\d*)*)?:(\d*(.\d*)*)?';
    }
  }

  // VPN id type
  typedef vpn-id-type {
    type string {
      tailf:info "OUI:VPN-Index;;, format (hex) <3 bytes OUI:4 bytes "
        +"VPN_Index>";
      pattern '[0-9a-fA-F][0-9a-fA-F]?[0-9a-fA-F]?:[0-9a-fA-F]'
        +'[0-9a-fA-F]?[0-9a-fA-F]?[0-9a-fA-F]?';
    }
  }

  // ASN IP type
  typedef asn-ip-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn";
      pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        +'\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
    }
  }

  // Hour&minute type
  typedef hhmm-type {
    type string {
      pattern "([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?";
    }
  }

  // Weekday type
  typedef weekday-type {
    type enumeration {
      enum Mon;
      enum Tue;
      enum Wed;
      enum Thu;
      enum Fri;
      enum Sat;
      enum Sun;
    }
  }

  // Month type
  typedef month-type {
    type enumeration {
      enum Jan;
      enum Feb;
      enum Mar;
      enum Apr;
      enum May;
      enum Jun;
      enum Jul;
      enum Aug;
      enum Sep;
      enum Oct;
      enum Nov;
      enum Dec;
    }
  }

  // Standard access list type
  typedef std-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard access list";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard access list (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Named access list";
      }
    }
  }

  // Standard IP access list type
  typedef std-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard IP access list";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard IP access list (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Named access list";
      }
    }
  }

  // Extended access list type
  typedef ext-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;Access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;Access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;IP Named Extended Access list";
      }
    }
  }

  // Extended ip access list type
  typedef ext-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;IP access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;IP access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }

  // Expanded ip access list type
  typedef exp-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-199>;;IP access list";
        range "1..199";
      }
      type uint16 {
        tailf:info "<1300-2699>;;IP expanded access list";
        range "1300..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }

  typedef rip-offset-list-id-type {
    type union {
      type uint32 {
        tailf:info "<0-99>;;Access list of networks to apply offset "
          +"(0 selects all networks)";
        range "0..99";
      }
      type uint32 {
        tailf:info "<1300-1999>;;Access list of networks to apply offset "
          +"(expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }

  // LDP discovery address type
  typedef ldp-discovery-address-type {
    type union {
      type enumeration {
        enum interface {
          tailf:code-name "ldp_interface";
          tailf:info "Use interface address for LDP "
            +"transport address";
        }
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address to use for LDP "
          +"transport address";
      }
    }
  }

  // Mst cost
  typedef mst-cost-type {
    type union {
      type uint32 {
        tailf:info "<1-200000000>;;Port path cost";
        range "1..200000000";
      }
      type enumeration {
        enum auto {
          tailf:code-name mst_cost_type_auto;
          tailf:info "Determine cost based on media speed of this "
            +"interface";
        }
      }
    }
  }

  // Spanning tree cost
  typedef spanning-tree-cost-type {
    type union {
      type uint32 {
        tailf:info "<1-200000000>;;Port path cost";
        range "1..200000000";
      }
      type enumeration {
        enum auto {
          tailf:code-name spanning-tree-cost-type-auto;
          tailf:info "Determine cost based on media speed of this "
            +"interface";
        }
      }
    }
  }

  // DSCP type
  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "Match packets with AF11 dscp (001010)";
          value 10011;
        }
        enum af12 {
          tailf:info "Match packets with AF12 dscp (001100)";
          value 10012;
        }
        enum af13 {
          tailf:info "Match packets with AF13 dscp (001110)";
          value 10013;
        }
        enum af21 {
          tailf:info "Match packets with AF21 dscp (010010)";
          value 10021;
        }
        enum af22 {
          tailf:info "Match packets with AF22 dscp (010100)";
          value 10022;
        }
        enum af23 {
          tailf:info "Match packets with AF23 dscp (010110)";
          value 10023;
        }
        enum af31 {
          tailf:info "Match packets with AF31 dscp (011010)";
          value 10031;
        }
        enum af32 {
          tailf:info "Match packets with AF32 dscp (011100)";
          value 10032;
        }
        enum af33 {
          tailf:info "Match packets with AF33 dscp (011110)";
          value 10033;
        }
        enum af41 {
          tailf:info "Match packets with AF41 dscp (100010)";
          value 10041;
        }
        enum af42 {
          tailf:info "Match packets with AF42 dscp (100100)";
          value 10042;
        }
        enum af43 {
          tailf:info "Match packets with AF43 dscp (100110)";
          value 10043;
        }
        enum cs1 {
          tailf:info "Match packets with CS1(precedence 1) dscp"+
            " (001000)";
          value 10001;
        }
        enum cs2 {
          tailf:info "Match packets with CS2(precedence 2) dscp"+
            " (010000)";
          value 10002;
        }
        enum cs3 {
          tailf:info "Match packets with CS3(precedence 3) dscp"+
            " (011000)";
          value 10003;
        }
        enum cs4 {
          tailf:info "Match packets with CS4(precedence 4) dscp"+
            " (100000)";
          value 10004;
        }
        enum cs5 {
          tailf:info "Match packets with CS5(precedence 5) dscp"+
            " (101000)";
          value 10005;
        }
        enum cs6 {
          tailf:info "Match packets with CS6(precedence 6) dscp"+
            " (110000)";
          value 10006;
        }
        enum cs7 {
          tailf:info "Match packets with CS7(precedence 7) dscp"+
            " (111000)";
          value 10007;
        }
        enum "default" {
          tailf:info "Match packets with default dscp (000000)";
          tailf:code-name "dscp_default";
          value 1000;
        }
        enum dscp {
          tailf:info "Set packet dscp from dscp";
          value 1001;
        }
        enum ef {
          tailf:info "Match packets with EF dscp (101110)";
          value 1002;
        }
        enum precedence {
          tailf:info "Set packet dscp from precedence";
          value 1003;
        }
      }
    }
  }

  // Precedence type
  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum internet {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control"+
            " precedence (6)";
        }
        enum network {
          tailf:info "Set packets with network control precedence"+
            " (7)";
        }
        enum priority {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
        }
      }
    }
  }

  // cos_value-type
  typedef cos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new cos value";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet cos from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet cos from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet cos from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet cos from precedence";
          value 1004;
        }
      }
    }
  }

  // qos_value-type
  typedef qos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-99>;;new qos-group";
        range "0..99";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet qos from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet qos from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet qos from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet qos from precedence";
          value 1004;
        }
      }
    }
  }

  // exp_value-type
  typedef exp_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new exp";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet exp from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet exp from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet exp from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet exp from precedence";
          value 1004;
        }
      }
    }
  }

  // prec_value-type
  typedef prec_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new precedence";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet precedence from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet precedence from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet precedence from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet precedence from precedence";
          value 1004;
        }
      }
    }
  }

  typedef redist-ospf-external-type {
    type enumeration {
      enum "1" {
        tailf:info "Redistribute external type 1 routes";
      }
      enum "2" {
        tailf:info "Redistribute external type 2 routes";
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0..4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef ospf-metric-type {
    type uint32 {
      tailf:info "<1-2>;;OSPF Link State type";
      range "1..2";
    }
  }

  typedef limit-dc-non-dc-type {
    type union {
      type uint32 {
        tailf:info "<1-255>;;The maximum number of retransmissions";
        range "1..255";
      }
      type enumeration {
        enum disable {
          tailf:info "Disable the feature";
        }
      }
    }
  }

  typedef isis-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "Level-1 only";
      }
      enum level-1-2 {
        tailf:info "Level-1-2";
      }
      enum level-2 {
        tailf:info "Level-2 only";
      }
    }
  }

  typedef authentication-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "ISIS authentication for level-1";
      }
      enum level-2 {
        tailf:info "ISIS authentication for level-2";
      }
    }
  }

  typedef logging-level-type {
    type union {
      type uint16 {
        tailf:info "<0-7>;;Logging severity level";
        range "0..7";
      }
      type enumeration {
        enum alerts {
          tailf:info "Immediate action needed (severity=1)";
        }
        enum critical {
          tailf:info "Critical conditions (severity=2)";
        }
        enum debugging {
          tailf:info "Debugging messages (severity=7)";
        }
        enum emergencies {
          tailf:info "System is unusable (severity=0)";
        }
        enum errors {
          tailf:info "Error conditions (severity=3)";
        }
        enum informational {
          tailf:info "Informational messages (severity=6)";
        }
        enum notifications {
          tailf:info "Normal but significant conditions "+
            "(severity=5)";
        }
        enum warnings {
          tailf:info "Warning conditions (severity=4)";
        }
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
    }
  }

  typedef police-packets-bytes-type {
    type enumeration {
      enum packets {
        tailf:info "Treat 'burst' value as packets";
      }
      enum bytes {
        tailf:info "Treat 'burst' value as bytes";
      }
    }
  }

  typedef police-pps-bps-type {
    type enumeration {
      enum pps {
        tailf:info "pps  Treat 'rate' value in "+
          "packets-per-second";
      }
      enum bps {
        tailf:info "pps  Treat 'rate' value in "+
          "bytes-per-second";
      }
    }
  }

  // police target bit rate in bits per second (bps) type
  typedef police-bps-type {
    type uint64 {
      tailf:info "<8000-64000000000>;;Bits per second";
      range "8000..64000000000";
    }
  }

  typedef police-burst-type {
    type uint32 {
      tailf:info "<1000-512000000>;;Burst bytes";
      range "1000..512000000";
    }
  }

  typedef crypto-ipsec-transform-bits-type {
    type enumeration {
      enum "128" {
        tailf:info "128 bit keys.";
      }
      enum "192" {
        tailf:info "192 bit keys.";
      }
      enum "256" {
        tailf:info "256 bit keys.";
      }
    }
  }

  typedef crypto-ipsec-transform-type {
    type enumeration {
      enum ah-md5-hmac {
        tailf:info "AH-HMAC-MD5 transform";
      }
      enum ah-sha-hmac {
        tailf:info "AH-HMAC-SHA transform";
      }
      enum ah-sha256-hmac {
        tailf:info "AH-HMAC-SHA256 transform";
      }
      enum ah-sha384-hmac {
        tailf:info "AH-HMAC-SHA384 transform";
      }
      enum ah-sha512-hmac {
        tailf:info "AH-HMAC-SHA512 transform";
      }
      enum comp-lzs {
        tailf:info "IP Compression using the LZS compression algorithm";
      }
      enum esp-3des {
        tailf:info "ESP transform using 3DES(EDE) cipher (168 bits)";
      }
      enum esp-aes {
        tailf:info "ESP transform using AES cipher";
      }
      enum esp-des {
        tailf:info "ESP transform using DES cipher (56 bits)";
      }
      enum esp-gcm {
        tailf:info "ESP transform using GCM";
      }
      enum esp-gmac {
        tailf:info "ESP transform using GMAC cipher";
      }
      enum esp-md5-hmac {
        tailf:info "ESP transform using HMAC-MD5 auth";
      }
      enum esp-null {
        tailf:info "ESP transform w/o cipher";
      }
      enum esp-seal {
        tailf:info "ESP transform using SEAL cipher (160 bits)";
      }
      enum esp-sha-hmac {
        tailf:info "ESP transform using HMAC-SHA auth";
      }
      enum esp-sha256-hmac {
        tailf:info "ESP transform using HMAC-SHA256 auth";
      }
      enum esp-sha384-hmac {
        tailf:info "ESP transform using HMAC-SHA384 auth";
      }
      enum esp-sha512-hmac {
        tailf:info "ESP transform using HMAC-SHA512 auth";
      }
    }
  }

  // aaa-authorization-name-type
  typedef aaa-authorization-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default authorization list.";
        }
      }
      type string {
        tailf:info "WORD;;Named authorization list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-authentication-name-type
  typedef aaa-authentication-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default authentication list.";
        }
      }
      type string {
        tailf:info "WORD;;Named authentication list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-accounting-name-type
  typedef aaa-accounting-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default accounting list.";
        }
      }
      type string {
        tailf:info "WORD;;Named Accounting list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-group-type
  typedef aaa-group-type {
    type union {
      type string {
        tailf:info "WORD;;Server-group name";
      }
      type enumeration {
        enum ldap {
          tailf:info "Use list of all LDAP hosts.";
        }
        enum radius {
          tailf:info "Use list of all Radius hosts.";
        }
        enum "tacacs+" {
          tailf:info "Use list of all Tacacs+ hosts.";
        }
      }
    }
  }

  // ipsec-window-size-type
  typedef ipsec-window-size-type {
    type enumeration {
      enum "1024" {
        tailf:info "Window size of 1024";
      }
      enum "128" {
        tailf:info "Window size of 128";
      }
      enum "256" {
        tailf:info "Window size of 256";
      }
      enum "512" {
        tailf:info "Window size of 512";
      }
      enum "64" {
        tailf:info "Window size of 64 (default)";
      }
    }
  }


  grouping redistribute-ospf-match-grouping {
    leaf internal {
      tailf:info "Redistribute OSPF internal routes";
      type empty;
    }
    container external-1 {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute external type 1 routes";
          }
        }
      }
    }
    container external-2 {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute external type 2 routes";
          }
        }
      }
    }
    container nssa-external-1 {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute NSSA external type 1 routes";
          }
        }
      }
    }
    container nssa-external-2 {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute NSSA external type 2 routes";
          }
        }
      }
    }
  }


  // =========================================================================
  // GROUPING
  // =========================================================================


  // police {conform|exceed|violate}-action groupings
  grouping police-action-transmit-grouping {
    leaf transmit {
      tailf:info "transmit packet";
      type empty;
    }
  }
  grouping police-action-drop-grouping {
    leaf drop {
      tailf:info "drop packet";
      type empty;
    }
  }


  // Police conform action grouping
  grouping police-conform-action-grouping {
    container conform-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container conform-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container conform-set-cos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container conform-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container conform-set-dscp-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container conform-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container conform-set-mpls-exp-imposition-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container conform-set-mpls-exp-topmost-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container conform-set-prec-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container conform-set-qos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container conform-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  } // Police conform action grouping


  // Police exceed action grouping
  grouping police-exceed-action-grouping {
    container exceed-dscp {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf dscp {
          //tailf:info
          type dscp-type;
        }
      }
    }
    container exceed-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container exceed-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container exceed-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container exceed-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container exceed-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container exceed-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container exceed-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container exceed-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container exceed-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container exceed-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container exceed-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }   // Police exceed action grouping


  // Police violate action grouping
  grouping police-violate-action-grouping {
    container violate-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container violate-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container violate-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container violate-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container violate-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container violate-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container violate-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container violate-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container violate-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container violate-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container violate-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  } // Police violate action grouping


  // police-action-grouping
  grouping police-action-grouping {
    container actions {
      tailf:cli-break-sequence-commands;
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      // policy-map * / class * / police ? / conform-action
      uses police-conform-action-grouping;
      // policy-map * / class * / police ? / exceed-action
      uses police-exceed-action-grouping;
      // policy-map * / class * / police ? / violate-action
      uses police-violate-action-grouping;
    }
  }   // police-action-grouping


  // ip ftp password
  grouping password-grouping {

    container password-container {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Encryption type (0 to disable"+
            " encryption, 7 for proprietary)";
          range "0..7";
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The password";
          pattern "([1-680-9a-zA-Z].*)|(0.+)|(7.+)";
        }
      }
    }
  }


  // crypto-key-grouping
  grouping crypto-key-grouping {
    leaf "encryption" {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password "+
            "will follow";
        }
        enum "6" {
          tailf:info "Specifies an ENCRYPTED password "+
            "will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
          "user password";
      }
    }
  }

  grouping distribute-list-content-grouping {

    choice distribute-type {
      // distribute-list <access-list-name> in|out
      case access-list {
        leaf access-list-name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
      }

      // distribute-list prefix <pfx-list-name> gateway <pfx-list-name> in|out
      case prefix-list-gateway {
        leaf "prefix" {
          tailf:info "Filter prefixes in routing updates";
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
        leaf gateway {
          tailf:info "Filtering incoming updates based on gateway";
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
      }

      // distribute-list prefix routemap <route-map-name> in|out
      case route-map {
        leaf routemap {
          tailf:info "Filter prefixes based on the route-map";
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
      }
    }
  }

  // router rip
  // router ospf * / distribute-list
  // router bgp *
  // router bgp * / neighbor * distribute-list *
  grouping router-distribute-list-grouping {

    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      uses distribute-list-content-grouping;
    }

    container distribute-list-interface {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-remove-before-change;
        key "direction interface";
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming routing updates";
            }
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        uses distribute-list-content-grouping;
      }
    }
  }


  // router rip *
  // router ospf *
  // router isis
  // router isis *
  grouping passive-interface-grouping {

    // router rip * / passive-interface
    container passive-interface {
      tailf:info "Suppress routing updates on an interface";
      choice passive-interface-choice {
        // router rip * / passive-interface default
        leaf "default" {
          tailf:info "Suppress routing updates on all interfaces";
          type empty;
        }
        // router rip * / passive-interface *
        list interface {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }
    }

    // Fix to handle showing "no passive-interface <ifname>"
    // Replace 'disable passive-interface <ifname> with
    // "no passive-interface <ifname>"
    container disable {
      tailf:info "Use with 'disable passive-interface' for "+
        "'no passive-interface' config";
      when "../passive-interface/default";
      list passive-interface {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key interface;
        leaf interface {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  }


  // interface-name-grouping - all interface lists collected
  grouping interface-name-grouping {
    choice interface-choice {

      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Null/name";
        }
      }

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern "([0-9\.])+";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Loopback/name";
        }
      }

      leaf Embedded-Service-Engine {
        tailf:info "cisco embedded service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Embedded-Service-Engine/name";
        }
      }

      leaf Tunnel {
        tailf:info "Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32;
        tailf:non-strict-leafref {
          path "/ios:interface/Tunnel/name";
        }
      }

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32;
        tailf:non-strict-leafref {
          path "/ios:interface/Port-channel/name";
        }
      }

      container Port-channel-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Port-channel {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Port-channel-subinterface/Port-channel/name";
          }
        }
      }

      leaf Multilink {
        tailf:info "Multilink-group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          range "1..65535";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Multilink/name";
        }
      }

      leaf MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32;
        tailf:non-strict-leafref {
          path "/ios:interface/MFR/name";
        }
      }

      container MFR-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf MFR {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ios:interface/MFR-subinterface/MFR/name";
          }
        }
      }

      leaf BRI {
        tailf:info "ISDN Basic Rate Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16;
        tailf:non-strict-leafref {
          path "/ios:interface/BRI/name";
        }
      }

      leaf Ethernet {
        tailf:info "Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+.*";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Ethernet/name";
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/FastEthernet/name";
        }
      }

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/GigabitEthernet/name";
        }
      }

      leaf TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/TenGigabitEthernet/name";
        }
      }

      leaf BDI {
        tailf:info "Bridge-Domain interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4095>;;BDI interface number";
          range "1..4095";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BDI/name";
        }
      }

      leaf Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Cable/name";
        }
      }

      leaf Modular-Cable {
        tailf:info "Modular Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Modular-Cable/name";
        }
      }

      leaf Wideband-Cable {
        tailf:info "Wideband CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Wideband-Cable/name";
        }
      }

      leaf Bundle {
        tailf:info "Virtual Bundle";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Bundle/name";
        }
      }

      leaf Cellular {
        tailf:info "Cellular";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Cellular/name";
        }
      }

      leaf Vlan {
        tailf:info "Catalyst Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Vlan/name";
        }
      }

      leaf Async {
        tailf:info "Async interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16;
        tailf:non-strict-leafref {
          path "/ios:interface/Async/name";
        }
      }

      leaf Group-Async {
        tailf:info "Async Group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16;
        tailf:non-strict-leafref {
          path "/ios:interface/Group-Async/name";
        }
      }

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Serial/name";
        }
      }

      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+.*";
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Serial-subinterface/Serial/name";
          }
        }
      }

      leaf Virtual-Template {
        tailf:info "Virtual Template interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Virtual-Template/name";
        }
      }

      leaf pseudowire {
        tailf:info "Pseudowire Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/pseudowire/name";
        }
      }

      leaf LISP {
        tailf:info "Locator/ID Separation Protocol Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/LISP/name";
        }
      }

      container LISP-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf LISP {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ios:interface/LISP-subinterface/LISP/name";
          }
        }
      }

    }
  } // interface-name-grouping


  // ip-community-list-standard-grouping
  grouping ip-community-list-standard-grouping {
    container deny {
      tailf:info "Specify community to reject";
      tailf:cli-delete-when-empty;
      presence true;
      list deny-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "<1-4294967295>  community number
            aa:nn           community number
            internet        Internet (well-known community)
            local-AS        Do not send outside local AS (well-known community)
            no-advertise    Do not advertise to any peer (well-known community)
            no-export       Do not export to next AS (well-known community)
            ";
            pattern '((internet)|(local\-AS)|(no\-advertise)|'
              +'(no\-export)|(\d+:\d+)|(\d+))'
              +'( (internet)|(local\-AS)|'
              +'(no\-advertise)|(no\-export)|(\d+:\d+)|(\d+))*';
          }
        }
      }
    }

    container permit {
      tailf:info "Specify community to accept";
      tailf:cli-delete-when-empty;
      presence true;
      list permit-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "<1-4294967295>  community number
            aa:nn           community number
            internet        Internet (well-known community)
            local-AS        Do not send outside local AS (well-known community)
            no-advertise    Do not advertise to any peer (well-known community)
            no-export       Do not export to next AS (well-known community)
            ";
            pattern '((internet)|(local-AS)|(no-advertise)|'
              +'(no-export)|(\d+:\d+)|(\d+))( (internet)|'
              +'(local-AS)|(no-advertise)|(no-export)|'
              +'(\d+:\d+)|(\d+))*';
          }
        }
      }
    }
  }

  // ip-community-list-expanded-grouping
  grouping ip-community-list-expanded-grouping {
    container deny {
      tailf:info "Specify community to reject";
      tailf:cli-delete-when-empty;
      presence true;
      list deny-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "LINE;;An ordered list as a regular-expression";
          }
        }
      }
    }
    container permit {
      tailf:info "Specify community to accept";
      tailf:cli-delete-when-empty;
      presence true;
      list permit-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "LINE;;An ordered list as a regular-expression";
          }
        }
      }
    }
  }

  // ip-route-options-grouping
  grouping ip-route-options-grouping {
    leaf metric {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type uint8 {
        tailf:info "<1-255>;;Distance metric for this route";
        range "1..255";
      }
    }
    leaf global {
      tailf:info "Next hop address is global";
      type empty;
    }
    leaf name {
      tailf:info "Specify name of the next hop";
      type string {
        tailf:info "WORD;;Name of the next hop";
      }
    }
    leaf permanent {
      tailf:info "permanent route";
      type empty;
    }
    leaf multicast {
      tailf:info "multicast route";
      type empty;
    }
    leaf dhcp {
      tailf:info "Default Gateway obtained from DHCP";
      tailf:cli-case-insensitive;
      type empty;
    }
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Tag value";
        range "1..4294967295";
      }
    }
    leaf track {
      tailf:info "Install route depending on tracked item";
      type uint16 {
        tailf:info "<1-500>;;tracked object number";
        range "1..500";
      }
    }
  }

  // ip-route-grouping
  grouping ip-route-grouping {
    list ip-route-interface-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix mask interface forwarding-address";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "/ios:interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf forwarding-address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Forwarding router's address";
          }
          type enumeration {
            enum multicast {
               tailf:info "multicast route";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }
    list ip-route-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix mask forwarding-address";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf forwarding-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses ip-route-options-grouping;
    }
    list ip-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix mask interface";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        tailf:cli-case-insensitive;
        tailf:cli-diff-dependency "/ios:interface";
        type union {
          type string {
            tailf:info "WORD;;Interface name";
          }
          type enumeration {
            enum dhcp {
              tailf:info "Default Gateway obtained from DHCP";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }
  }

  // ipv6-route-options-grouping
  grouping ipv6-route-options-grouping {
    leaf distance {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type uint8 {
        tailf:info "<1-254>;;Administrative distance";
        range "1..254";
      }
    }
    choice type-choice {
      leaf multicast {
        tailf:info "Route only usable by multicast";
        tailf:cli-full-command;
        type empty;
      }
      leaf unicast {
        tailf:info "Route only usable by unicast";
        type empty;
      }
    }
    leaf tag {
      tailf:info "Tag value";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Tag value";
      }
    }
  }

  // ipv6-route-grouping
  grouping ipv6-route-grouping {
    list ipv6-route-interface-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix interface destination";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "/ios:interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;
    }
    list ipv6-route-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix destination";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;

    }
    list ipv6-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix interface";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "/ios:interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      uses ipv6-route-options-grouping;
    }
  }

  // random-detect-grouping
  grouping random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<1-262143>;;minimum threshold (in packet by default)";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum bytes {
          tailf:info "number of bytes";
        }
        enum ms {
          tailf:info "milliseconds";
        }
        enum us {
          tailf:info "microseconds";
        }
      }
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-262143>;;maximum threshold (number of packets)";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum bytes {
          tailf:info "number of bytes";
        }
        enum ms {
          tailf:info "milliseconds";
        }
        enum us {
          tailf:info "microseconds";
        }
      }
    }
    leaf denominator {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-65535>;;mark probability denominator";
      }
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {

    // class-map * / match access-group
    container access-group {
      tailf:info "Access group";
      leaf index {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-2799>;;Access list index";
          range "1..2699";
        }
      }
      leaf-list name {
        tailf:info "Named Access List";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
    }

    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }

    // class-map * / match class-map
    leaf-list class-map {
      tailf:info "Class map";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;Match class-map name";
      }
      tailf:non-strict-leafref {
        path "/ios:class-map/name";
      }
    }

    // class-map * / match cos
    leaf-list cos {
      tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
      tailf:cli-flat-list-syntax;
      max-elements 4;
      type uint16 {
        range "0..7";
        tailf:info "<0-7>;;Enter up to 4 class-of-service values"+
          " separated by white-spaces";
      }
    }

    // class-map * / match destination-address
    container destination-address {
      tailf:info "Destination address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // class-map * / match discard-class
    leaf-list discard-class {
      tailf:info "Discard behavior identifier";
      tailf:cli-list-syntax;
      type uint8 {
        tailf:info "<0-7>;;Discard Class value";
        range "0..7";
      }
    }

    // class-map * / match dscp
    leaf-list dscp {
      tailf:info "Match DSCP in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      tailf:cli-full-command;
      type dscp-type;
    }

    // class-map * / match fr-de
    leaf fr-de {
      tailf:info "Match on Frame-relay DE bit";
      type empty;
    }

    // class-map * / match fr-dlci
    leaf-list fr-dlci {
      tailf:info "Match on fr-dlci";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<16-1007>;;frame-relay dlci number";
        range "16..1007";
      }
    }

    // class-map * / match input-interface
    leaf-list input-interface {
      tailf:info "Select an input interface to match";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;Interface name";
      }
    }

    // class-map * / match ip
    container ip {
      tailf:info "IP specific values";
      // class-map * / ip dscp
      leaf-list dscp {
        tailf:info "Match IP DSCP (DiffServ CodePoints)";
        tailf:cli-flat-list-syntax;
        type dscp-type;
      }
      // class-map * / ip precedence
      leaf-list precedence {
        tailf:info "Match IP precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      // class-map * / ip rtp *
      list rtp {
        tailf:info "Match RTP port nos";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "port1 port2";
        leaf port1 {
          type uint16 {
            tailf:info "<2000-65535>;;Lower bound of UDP"+
              " destination port";
            range "2000..65535";
          }
        }
        leaf port2 {
          type uint16 {
            tailf:info "<0-16383>;;Range of UDP ports";
            range "0..16383";
          }
        }
      }
    }

    // class-map * / match mpls
    container mpls {
      tailf:info "Multi Protocol Label Switching specific values";
      container experimental {
        tailf:info "Match MPLS experimental";
        leaf-list topmost {
          tailf:info "Match MPLS experimental value on topmost label";
          tailf:cli-flat-list-syntax;
          type uint16 {
            range "0..7";
            tailf:info "<0-7>;;Enter up to 8 experimental values "+
              "separated by white-spaces";
          }
        }
      }
    }

    // class-map * / match packet
    container packet {
      tailf:info "Layer 3 Packet length";
      container "length" {
        tailf:info "Layer 3 Packet length";
        leaf max {
          tailf:info "Maximum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
        leaf min {
          tailf:info "Minimum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
      }
    }

    // class-map * / match precedence
    leaf-list precedence {
      tailf:info "Match Precedence in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      type precedence-type;
    }

    // class-map * / match protocol
    container protocol {
      tailf:info "Protocol";
      leaf x802-11-iapp {
        tailf:info "IEEE 802.11 WLANs WG IAPP";
        tailf:alt-name "802-11-iapp";
        type empty;
      }
      leaf ace-svr {
        tailf:info "ACE Server/Propagation";
        type empty;
      }
      leaf aol {
        tailf:info "America-Online Instant Messenger";
        type empty;
      }
      leaf appleqtc {
        tailf:info "Apple QuickTime";
        type empty;
      }
      leaf biff {
        tailf:info "Bliff mail notification";
        type empty;
      }
      leaf bittorrent {
        tailf:info "bittorrent";
        type empty;
      }
      leaf bootpc {
        tailf:info "Bootstrap Protocol Client";
        type empty;
      }
      leaf bootps {
        tailf:info "Bootstrap Protocol Server";
        type empty;
      }
      leaf cddbp {
        tailf:info "CD Database Protocol";
        type empty;
      }
      leaf cifs {
        tailf:info "CIFS";
        type empty;
      }
      leaf cisco-fna {
        tailf:info "Cisco FNATIVE";
        type empty;
      }
      leaf cisco-net-mgmt {
        tailf:info "cisco-net-mgmt";
        type empty;
      }
      leaf cisco-svcs {
        tailf:info "cisco license/perf/GDP/X.25/ident svcs";
        type empty;
      }
      leaf cisco-sys {
        tailf:info "Cisco SYSMAINT";
        type empty;
      }
      leaf cisco-tdp {
        tailf:info "Cisco TDP";
        type empty;
      }
      leaf cisco-tna {
        tailf:info "Cisco TNATIVE";
        type empty;
      }
      leaf citriximaclient {
        tailf:info "Citrix IMA Client";
        type empty;
      }
      leaf clp {
        tailf:info "Cisco Line Protocol";
        type empty;
      }
      leaf creativepartnr {
        tailf:info "Creative Partnr";
        type empty;
      }
      leaf creativeserver {
        tailf:info "Creative Server";
        type empty;
      }
      leaf daytime {
        tailf:info "Daytime (RFC 867)";
        type empty;
      }
      leaf dbase {
        tailf:info "dBASE Unix";
        type empty;
      }
      leaf dbcontrol_agent {
        tailf:info "Oracle dbControl Agent po";
        type empty;
      }
      leaf ddns-v3 {
        tailf:info "Dynamic DNS Version 3";
        type empty;
      }
      leaf dhcp-failover {
        tailf:info "DHCP Failover";
        type empty;
      }
      leaf directconnect {
        tailf:info "Direct Connect Version 2.0";
        type empty;
      }
      leaf discard {
        tailf:info "Discard port";
        type empty;
      }
      leaf dnsix {
        tailf:info "DNSIX Securit Attribute Token Map";
        type empty;
      }
      leaf echo {
        tailf:info "Echo port";
        type empty;
      }
      leaf entrust-svc-hdlr {
        tailf:info "Entrust KM/Admin Service Handler";
        type empty;
      }
      leaf entrust-svcs {
        tailf:info "Entrust sps/aaas/aams";
        type empty;
      }
      leaf exec {
        tailf:info "Remote Process Execution";
        type empty;
      }
      leaf fcip-port {
        tailf:info "FCIP";
        type empty;
      }
      leaf ftps {
        tailf:info "FTP over TLS/SSL";
        type empty;
      }
      leaf gdoi {
        tailf:info "GDOI";
        type empty;
      }
      leaf giop {
        tailf:info "Oracle GIOP/SSL";
        type empty;
      }
      leaf gtpv0 {
        tailf:info "GPRS Tunneling Protocol Version 0";
        type empty;
      }
      leaf gtpv1 {
        tailf:info "GPRS Tunneling Protocol Version 1";
        type empty;
      }
      leaf h225ras {
        tailf:info "H225 RAS over Unicast";
        type empty;
      }
      leaf h323callsigalt {
        tailf:info "h323 Call Signal Alternate";
        type empty;
      }
      leaf hp-alarm-mgr {
        tailf:info "HP Performance data alarm manager";
        type empty;
      }
      leaf hp-collector {
        tailf:info "HP Performance data collector";
        type empty;
      }
      leaf hp-managed-node {
        tailf:info "HP Performance data managed node";
        type empty;
      }
      leaf hsrp {
        tailf:info "Hot Standby Router Protocol";
        type empty;
      }
      leaf https {
        tailf:info "Secure Hypertext Transfer Protocol";
        type empty;
      }
      leaf ica {
        tailf:info "ica (Citrix)";
        type empty;
      }
      leaf icabrowser {
        tailf:info "icabrowser (Citrix)";
        type empty;
      }
      leaf ident {
        tailf:info "Authentication Service";
        type empty;
      }
      leaf igmpv3lite {
        tailf:info "IGMP over UDP for SSM";
        type empty;
      }
      leaf imap3 {
        tailf:info "Interactive Mail Access Protocol 3";
        type empty;
      }
      leaf imaps {
        tailf:info "IMAP over TLS/SSL";
        type empty;
      }
      leaf ipass {
        tailf:info "IPASS";
        type empty;
      }
      leaf ipsec-msft {
        tailf:info "Microsoft IPsec NAT-T";
        type empty;
      }
      leaf irc-serv {
        tailf:info "IRC-SERV";
        type empty;
      }
      leaf ircs {
        tailf:info "IRC over TLS/SSL";
        type empty;
      }
      leaf ircu {
        tailf:info "IRCU";
        type empty;
      }
      leaf isakmp {
        tailf:info "ISAKMP";
        type empty;
      }
      leaf iscsi {
        tailf:info "iSCSI";
        type empty;
      }
      leaf iscsi-target {
        tailf:info "iSCSI port";
        type empty;
      }
      leaf kermit {
        tailf:info "kermit";
        type empty;
      }
      leaf ldap-admin {
        tailf:info "LDAP admin server port";
        type empty;
      }
      leaf ldaps {
        tailf:info "LDAP over TLS/SSL";
        type empty;
      }
      leaf login {
        tailf:info "Remote login";
        type empty;
      }
      leaf lotusmtap {
        tailf:info "Lotus Mail Tracking Agent Protocol";
        type empty;
      }
      leaf lotusnote {
        tailf:info "Lotus Note";
        type empty;
      }
      leaf microsoft-ds {
        tailf:info "Microsoft-DS";
        type empty;
      }
      leaf ms-cluster-net {
        tailf:info "MS Cluster Net";
        type empty;
      }
      leaf ms-dotnetster {
        tailf:info "Microsoft .NETster Port";
        type empty;
      }
      leaf ms-sna {
        tailf:info "Microsoft SNA Server/Base";
        type empty;
      }
      leaf ms-sql {
        tailf:info "Microsoft SQL";
        type empty;
      }
      leaf ms-sql-m {
        tailf:info "Microsoft SQL Monitor";
        type empty;
      }
      leaf msexch-routing {
        tailf:info "Microsoft Exchange Routing";
        type empty;
      }
      leaf msnmsgr {
        tailf:info "MSN Instant Messenger";
        type empty;
      }
      leaf msrpc {
        tailf:info "Microsoft Remote Procedure Call";
        type empty;
      }
      leaf mysql {
        tailf:info "MySQL";
        type empty;
      }
      leaf n2h2server {
        tailf:info "N2H2 Filter Service Port";
        type empty;
      }
      leaf ncp {
        tailf:info "NCP (Novell)";
        type empty;
      }
      leaf net8-cman {
        tailf:info "Oracle Net8 Cman/Admin";
        type empty;
      }
      leaf netbios-dgm {
        tailf:info "NETBIOS Datagram Service";
        type empty;
      }
      leaf netbios-ns {
        tailf:info "NETBIOS Name Service";
        type empty;
      }
      leaf netbios-ssn {
        tailf:info "NETBIOS Session Service";
        type empty;
      }
      leaf netstat {
        tailf:info "Variant of systat";
        type empty;
      }
      leaf oem-agent {
        tailf:info "OEM Agent (Oracle)";
        type empty;
      }
      leaf oracle {
        tailf:info "Oracle";
        type empty;
      }
      leaf oracle-em-vp {
        tailf:info "Oracle EM/VP";
        type empty;
      }
      leaf oraclenames {
        tailf:info "Oracle Names";
        type empty;
      }
      leaf orasrv {
        tailf:info "Oracle SQL*Net v1/v2";
        type empty;
      }
      leaf pcanywheredata {
        tailf:info "pcANYWHEREdata";
        type empty;
      }
      leaf pcanywherestat {
        tailf:info "pcANYWHEREstat";
        type empty;
      }
      leaf pop3s {
        tailf:info "POP3 over TLS/SSL";
        type empty;
      }
      leaf pwdgen {
        tailf:info "Password  Generator Protocol";
        type empty;
      }
      leaf qmtp {
        tailf:info "Quick Mail Transfer Protocol";
        type empty;
      }
      leaf r-winsock {
        tailf:info "remote-winsock";
        type empty;
      }
      leaf radius {
        tailf:info "RADIUS & Accounting";
        type empty;
      }
      leaf rdb-dbs-disp {
        tailf:info "Oracle RDB";
        type empty;
      }
      leaf realmedia {
        tailf:info "RealNetwork's Realmedia Protocol";
        type empty;
      }
      leaf realsecure {
        tailf:info "ISS Real Secure Console Service Port";
        type empty;
      }
      leaf router {
        tailf:info "Local Routing Process";
        type empty;
      }
      leaf rsvp-encap {
        tailf:info "RSVP ENCAPSULATION-1/2";
        type empty;
      }
      leaf rsvp_tunnel {
        tailf:info "RSVP Tunnel";
        type empty;
      }
      leaf rtc-pm-port {
        tailf:info "Oracle RTC-PM port";
        type empty;
      }
      leaf rtelnet {
        tailf:info "Remote Telnet Service";
        type empty;
      }
      leaf send {
        tailf:info "SEND";
        type empty;
      }
      leaf shell {
        tailf:info "Remote command";
        type empty;
      }
      leaf sip-tls {
        tailf:info "SIP-TLS";
        type empty;
      }
      leaf sms {
        tailf:info "SMS RCINFO/XFER/CHAT";
        type empty;
      }
      leaf snmptrap {
        tailf:info "SNMP Trap";
        type empty;
      }
      leaf sql-net {
        tailf:info "SQL-NET";
        type empty;
      }
      leaf sqlserv {
        tailf:info "SQL Services";
        type empty;
      }
      leaf sqlsrv {
        tailf:info "SQL Service";
        type empty;
      }
      leaf sshell {
        tailf:info "SSLshell";
        type empty;
      }
      leaf ssp {
        tailf:info "State Sync Protocol";
        type empty;
      }
      leaf syslog-conn {
        tailf:info "Reliable Syslog Service";
        type empty;
      }
      leaf tacacs {
        tailf:info "Login Host Protocol (TACACS)";
        type empty;
      }
      leaf tacacs-ds {
        tailf:info "TACACS-Database Service";
        type empty;
      }
      leaf tarantella {
        tailf:info "Tarantella";
        type empty;
      }
      leaf tcp {
        tailf:info "TCP";
        type empty;
      }
      leaf telnets {
        tailf:info "Telnet over TLS/SSL";
        type empty;
      }
      leaf time {
        tailf:info "Time";
        type empty;
      }
      leaf timed {
        tailf:info "Time server";
        type empty;
      }
      leaf tr-rsrb {
        tailf:info "cisco RSRB";
        type empty;
      }
      leaf ttc {
        tailf:info "Oracle TTC/SSL";
        type empty;
      }
      leaf udp {
        tailf:info "UDP";
        type empty;
      }
      leaf uucp {
        tailf:info "UUCPD/UUCP-RLOGIN";
        type empty;
      }
      leaf vqp {
        tailf:info "VQP";
        type empty;
      }
      leaf webster {
        tailf:info "Network Disctionary";
        type empty;
      }
      leaf who {
        tailf:info "Who's service";
        type empty;
      }
      leaf wins {
        tailf:info "Microsoft WINS";
        type empty;
      }
      leaf x11 {
        tailf:info "X Window System";
        type empty;
      }
      leaf xdmcp {
        tailf:info "XDM Control Protocol";
        type empty;
      }
      leaf ymsgr {
        tailf:info "Yahoo! Instant Messenger";
        type empty;
      }
      leaf aarp {
        tailf:info "AppleTalk ARP";
        type empty;
      }
      leaf appletalk {
        tailf:info "AppleTalk";
        type empty;
      }
      leaf arp {
        tailf:info "IP ARP";
        type empty;
      }
      leaf bgp {
        tailf:info "Border Gateway Protocol";
        type empty;
      }
      leaf bridge {
        tailf:info "Bridging";
        type empty;
      }
      leaf bstun {
        tailf:info "Block Serial Tunnel";
        type empty;
      }
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }
      container citrix {
        tailf:info "Citrix Systems ICA protocol";
        presence "enable citrix system protocol matching";
        leaf ica-tag {
          tailf:info "Citrix ICA tag 0-high 1-medium 2-low "+
            "3-background";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf clns {
        tailf:info "ISO CLNS";
        type empty;
      }
      leaf clns_es {
        tailf:info "ISO CLNS End System";
        type empty;
      }
      leaf clns_is {
        tailf:info "ISO CLNS Intermediate System";
        type empty;
      }
      leaf cmns {
        tailf:info "ISO CMNS";
        type empty;
      }
      leaf compressedtcp {
        tailf:info "Compressed TCP (VJ";
        type empty;
      }
      leaf cuseeme {
        tailf:info "CU-SeeMe desktop video conference";
        type empty;
      }
      leaf decnet {
        tailf:info "DECnet";
        type empty;
      }
      leaf decnet_node {
        tailf:info "DECnet Node";
        type empty;
      }
      leaf decnet_router-l1 {
        tailf:info "DECnet Router L1";
        type empty;
      }
      leaf decnet_router-l2 {
        tailf:info "DECnet Router L2";
        type empty;
      }
      leaf dhcp {
        tailf:info "Dynamic Host Configuration";
        type empty;
      }
      leaf dlsw {
        type empty;
        tailf:info "Data Link Switching (Direct encapsulation only";
      }
      leaf dns {
        type empty;
        tailf:info "Domain Name Server lookup";
      }
      leaf edonkey {
        type empty;
        tailf:info "eDonkey";
      }
      leaf egp {
        type empty;
        tailf:info "Exterior Gateway Protocol";
      }
      leaf eigrp {
        type empty;
        tailf:info "Enhanced Interior Gateway Routing Protocol";
      }
      leaf exchange {
        type empty;
        tailf:info "MS-RPC for Exchange";
      }
      container fasttrack {
        tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster";
        presence "enable fasttrack matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf finger {
        type empty;
        tailf:info "Finger";
      }
      leaf ftp {
        type empty;
        tailf:info "File Transfer Protocol";
      }
      container gnutella {
        tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, "+
          "Morpheus";
        presence "enable gnutella matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf gopher {
        type empty;
        tailf:info "Gopher";
      }
      leaf gre {
        type empty;
        tailf:info "Generic Routing Encapsulation";
      }
      leaf h323 {
        type empty;
        tailf:info "H323 Protocol";
      }
      container http {
        tailf:info "World Wide Web traffic";
        presence "enable http traffic matching";
        leaf c-header-field {
          tailf:info "Client general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf host {
          tailf:info "Server Host Name";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf mime {
          tailf:info "Match MIME Type";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf s-header-field {
          tailf:info "Server general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf url {
          tailf:info "Match URL String";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf icmp {
        tailf:info "Internet Control Message";
        type empty;
      }
      leaf imap {
        tailf:info "Internet Message Access Protocol";
        type empty;
      }
      leaf ip {
        tailf:info "IP";
        type empty;
      }
      leaf ipinip {
        tailf:info "IP in IP (encapsulation";
        type empty;
      }
      leaf ipsec {
        tailf:info "IP Security Protocol (ESP/AH";
        type empty;
      }
      leaf ipv6 {
        tailf:info "IPV6";
        type empty;
      }
      leaf ipx {
        tailf:info "Novell IPX";
        type empty;
      }
      leaf irc {
        type empty;
        tailf:info "Internet Relay Chat";
      }
      container kazaa2 {
        tailf:info "Kazaa Version 2";
        presence "enable kazaa version 2 matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf kerberos {
        tailf:info "Kerberos";
        type empty;
      }
      leaf l2tp {
        tailf:info "L2F/L2TP tunnel";
        type empty;
      }
      leaf ldap {
        tailf:info "Lightweight Directory Access Protocol";
        type empty;
      }
      leaf llc2 {
        tailf:info "llc2";
        type empty;
      }
      leaf mgcp {
        tailf:info "Media Gateway Control Protocol";
        type empty;
      }
      container napster {
        tailf:info "Napster Traffic";
        presence "enable napster matching";
        leaf non-std {
          tailf:info "Non-standard port advertizements";
          type empty;
        }
      }
      leaf netbios {
        tailf:info "NetBIOS";
        type empty;
      }
      leaf netshow {
        tailf:info "Microsoft Netshow";
        type empty;
      }
      leaf nfs {
        tailf:info "Network File System";
        type empty;
      }
      leaf nntp {
        tailf:info "Network News Transfer Protocol";
        type empty;
      }
      leaf notes {
        tailf:info "Lotus Notes(R";
        type empty;
      }
      leaf novadigm {
        tailf:info "Novadigm EDM";
        type empty;
      }
      leaf ntp {
        tailf:info "Network Time Protocol";
        type empty;
      }
      leaf ospf {
        tailf:info "Open Shortest Path First";
        type empty;
      }
      leaf pad {
        tailf:info "PAD links";
        type empty;
      }
      leaf pcanywhere {
        tailf:info "Symantec pcANYWHERE";
        type empty;
      }
      leaf pop3 {
        tailf:info "Post Office Protocol";
        type empty;
      }
      leaf pppoe {
        tailf:info "PPP over Ethernet";
        type empty;
      }
      leaf pptp {
        tailf:info "Point-to-Point Tunneling Protocol";
        type empty;
      }
      leaf printer {
        tailf:info "print spooler/lpd";
        type empty;
      }
      leaf qllc {
        tailf:info "qllc protocol";
        type empty;
      }
      leaf rcmd {
        tailf:info "BSD r-commands (rsh, rlogin, rexec";
        type empty;
      }
      leaf rip {
        tailf:info "Routing Information Protocol";
        type empty;
      }
      leaf rsrb {
        tailf:info "Remote Source-Route Bridging";
        type empty;
      }
      leaf rsvp {
        tailf:info "Resource Reservation Protocol";
        type empty;
      }
      leaf rtcp {
        tailf:info "Real Time Control Protocol";
        type empty;
      }
      container rtp {
        tailf:info "Real Time Protocol";
        presence "enable rtp matching";
        leaf audio {
          tailf:info "Match voice packets";
          type empty;
        }
        leaf payload-type {
          tailf:info "Match an explicit PT";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf video {
          tailf:info "Match video packets";
          type empty;
        }
      }
      leaf rtsp {
        tailf:info "Real Time Streaming Protocol";
        type empty;
      }
      leaf secure-ftp {
        tailf:info "FTP over TLS/SSL";
        type empty;
      }
      leaf secure-http {
        tailf:info "Secured HTTP";
        type empty;
      }
      leaf secure-imap {
        tailf:info "Internet Message Access Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-irc {
        tailf:info "Internet Relay Chat over TLS/SSL";
        type empty;
      }
      leaf secure-ldap {
        tailf:info "Lightweight Directory Access Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-nntp {
        tailf:info "Network News Transfer Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-pop3 {
        tailf:info "Post Office Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-telnet {
        tailf:info "Telnet over TLS/SSL";
        type empty;
      }
      leaf sip {
        tailf:info "Session Initiation Protocol";
        type empty;
      }
      leaf skinny {
        tailf:info "Skinny Protocol";
        type empty;
      }
      leaf smtp {
        tailf:info "Simple Mail Transfer Protocol";
        type empty;
      }
      leaf snapshot {
        tailf:info "Snapshot routing support";
        type empty;
      }
      leaf snmp {
        tailf:info "Simple Network Management Protocol";
        type empty;
      }
      leaf socks {
        tailf:info "SOCKS";
        type empty;
      }
      leaf sqlnet {
        tailf:info "SQL*NET for Oracle";
        type empty;
      }
      leaf sqlserver {
        tailf:info "MS SQL Server";
        type empty;
      }
      leaf ssh {
        tailf:info "Secured Shell";
        type empty;
      }
      leaf streamwork {
        tailf:info "Xing Technology StreamWorks player";
        type empty;
      }
      leaf stun {
        tailf:info "Serial Tunnel";
        type empty;
      }
      leaf sunrpc {
        tailf:info "Sun RPC";
        type empty;
      }
      leaf syslog {
        tailf:info "System Logging Utility";
        type empty;
      }
      leaf telnet {
        tailf:info "Telnet";
        type empty;
      }
      leaf tftp {
        tailf:info "Trivial File Transfer Protocol";
        type empty;
      }
      leaf vdolive {
        tailf:info "VDOLive streaming video";
        type empty;
      }
      leaf vofr {
        tailf:info "voice over Frame Relay packets";
        type empty;
      }
      leaf winmx {
        tailf:info "WinMx file-sharing application";
        type empty;
      }
      leaf xwindows {
        tailf:info "X-Windows remote access";
        type empty;
      }

      // class-map * / match protocal attribute category *
      container attribute {
        tailf:info "Attribute based protocol match";
        list category {
          tailf:info "Category attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key category-type;
          leaf category-type {
            type enumeration {
              enum "voice-and-video" {
                tailf:info "Filter incoming connections";
              }
              enum "database" {
                tailf:info "Filter outgoing connections";
              }
              enum "email" {
                tailf:info "Email related applications";
              }
              enum "browsing" {
                tailf:info "Browsing related applications";
              }
              enum "trojan" {
                tailf:info "Trojan related applications";
              }
              enum "gaming" {
                tailf:info "Gaming related applications";
              }
              enum "anonymizers" {
                tailf:info "Anonymizers applications";
              }
              enum "backup-and-storage" {
                tailf:info "Backup and storage related applications";
              }
              enum "business-and-productivity-tools" {
                tailf:info "Business-and-productivity-tools related "+
                  "applications";
              }
              enum "epayement" {
                tailf:info "Epayement related applications";
              }
              enum "file-sharing" {
                tailf:info "File-sharing related applications";
              }
              enum "industrial-protocols" {
                tailf:info "Industrial-protocols related applications";
              }
              enum "instant-messaging" {
                tailf:info "Instant-messaging related applications";
              }
              enum "inter-process-rpc" {
                tailf:info "Inter-process-rpc related applications";
              }
              enum "internet-security" {
                tailf:info "Internet security related applications";
              }
              enum "layer3-over-ip" {
                tailf:info "Layer3-over-IP related applications";
              }
              enum "location-based-services" {
                tailf:info "Location-based-services related applications";
              }
              enum "net-admin" {
                tailf:info "Net-admin related applications";
              }
              enum "newsgroup" {
                tailf:info "Newsgroup related applications";
              }
              enum "other" {
                tailf:info "Other related applications";
              }
              enum "social-networking" {
                tailf:info "Social-networking related applications";
              }
              enum "software-updates" {
                tailf:info "Software updates and downloads related "+
                  "applications";
              }
            }
          }
        }
      }
    }

    // class-map * / match qos-group
    leaf-list qos-group {
      tailf:info "Qos-group";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<0-99>;;Qos Group value";
        range "0..99";
      }
    }

    // class-map * / match source-address
    container source-address {
      tailf:info "Source address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // class-map * / match vlan
    leaf-list vlan {
      tailf:info "VLANs to match";
      tailf:cli-range-list-syntax;
      type uint16 {
        tailf:info "<1-4094>;;VLAN id";
        range "1..4094";
      }
    }
  }

  // ip-name-server-grouping
  grouping ip-name-server-grouping {
    list name-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      max-elements 6;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Domain server IP address (maximum of 6)";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Domain server IPv6 address (maximum of 6)";
          }
        }
      }
    }
  }

  // ip-host-grouping
  grouping ip-host-grouping {
    list host-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key hostname;
      leaf hostname {
        tailf:cli-disallow-value "vrf";
        type string {
          tailf:info "WORD;;Name of host";
        }
      }
      leaf tcp-port-number {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Default telnet port number";
        }
      }
      leaf-list ip-address1 {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Host IP address";
        }
      }
      //additional  Append addresses
    }
  }

  // ip-dhcp-excluded-address-grouping
  grouping ip-dhcp-excluded-address-grouping {
    list low-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key low;
      leaf low {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Low IP address";
        }
      }
    }
    list low-high-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "low high";
      leaf low {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Low IP address";
        }
      }
      leaf high {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;High IP address";
        }
      }
    }
  }

  // ntp-peer-grouping
  grouping ntp-peer-grouping {
    list peer-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        tailf:cli-case-sensitive;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
          type string {
            tailf:info "WORD;;Hostname of peer";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 address of peer";
          }
        }
      }
      leaf burst {
        tailf:info "Send a burst when peer is reachable (Default)";
        type empty;
      }
      leaf iburst {
        tailf:info "Send a burst when peer is unreachable (Default)";
        type empty;
      }
      leaf "key" {
        tailf:info "Configure peer authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Peer key number";
          range "1..4294967295";
        }
      }
      leaf maxpoll {
        tailf:info "Maximum poll interval";
        type uint8 {
          tailf:info "<4-17>;;Poll value in Log2";
          range "4..17";
        }
      }
      leaf minpoll {
        tailf:info "Minimum poll interval";
        type uint8 {
          tailf:info "<4-17>;;Poll value in Log2";
          range "4..17";
        }
      }
      leaf normal-sync {
        tailf:info "Disable rapid sync at startup";
        type empty;
      }
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
        }
      }
    }
  }

  // sntp-server-grouping
  grouping sntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of server";
          }
          type string {
            tailf:info "WORD;;Hostname of peer";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 address of server";
          }
        }
      }
      leaf "key" {
        tailf:info "Configure server authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Server key number";
          range "1..4294967295";
        }
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
        }
      }
    }
  }


  // line-grouping
  grouping line-grouping {

    // line * / absolute-timeout
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes";
      }
    }

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      list access-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
          mandatory true;
        }
        leaf vrf-also {
          tailf:info "Same access list is applied for all VRFs";
          type empty;
        }
      }
    }

    // line * / activation-character
    container activation-character-choice {
      tailf:cli-drop-node-name;
      choice activation-character-choice {
        // line * / no activation-character
        leaf activation-character {
          tailf:info "Define the activation character";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        // line * / activation-character
        container activation-character-conf {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf activation-character {
            type string {
              tailf:info "CHAR or <0-127>;;Activation character or "+
                "its decimal equivalent";
            }
          }
        }
      }
    }

    // line * / escape-character
    leaf escape-character {
      tailf:info "Change the current line's escape character";
      type union {
        type uint8 {
          tailf:info "ASCII decimal equivalent";
        }
        type enumeration {
          enum BREAK {
            tailf:info "Cause escape on BREAK";
          }
          enum DEFAULT {
            tailf:info "Use default escape character";
          }
          enum NONE {
            tailf:info "Disable escape entirely";
          }
        }
      }
    }

    // line * / script
    container script {
      tailf:info "specify event related chat scripts to run on the line";
      leaf dialer {
        tailf:info "chat script to run whenever dialer makes an outgoing call";
        type string {
          tailf:info "WORD;;chat script name";
        }
        tailf:non-strict-leafref {
          path "/ios:chat-script/name";
        }
      }
    }

    // line * / modem
    container modem {
      tailf:info "Configure the Modem Control Lines";
      leaf enable {
        tailf:info "Console port is used for connecting modem";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf InOut {
        tailf:info "Configure line for incoming AND outgoing use of modem";
        type empty;
      }
      container autoconfigure {
        tailf:info "Automatically configure modem on line";
        leaf discovery {
          tailf:info "Attempt to determine modem type automatically";
          type empty;
        }
      }
    }

    // line * / exec
    container exec-choice {
      tailf:cli-drop-node-name;
      choice exec-choice {
        // line * / no exec
        leaf exec {
          tailf:info "Configure EXEC";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        // line * / exec prompt
        container exec-conf {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container exec {
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container prompt {
              tailf:info "EXEC prompt";
              leaf timestamp {
                tailf:info "Print timestamps for show commands";
                type empty;
              }
            }
          }
        }
      }
    }

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf minutes {
        tailf:info "<0-35791>;;Timeout in minutes";
        tailf:cli-drop-node-name;
        type uint32;
      }
      leaf seconds {
        tailf:info "<0-2147483>;;Timeout in seconds";
        tailf:cli-drop-node-name;
        type uint32;
      }
    }

    // line * /  session-disconnect-warning
    container session-disconnect-warning {
      tailf:info "Set warning countdown for session-timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Session timeout warning in seconds";
        }
      }
      leaf message {
        tailf:info "Optional warning message";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;One text line optional warning message";
        }
      }
    }

    // line * / logging
    container logging {
      tailf:info "Modify message logging facilities";
      // line * / logging synchronous
      container synchronous {
        tailf:info "Synchronized message output";
        //tailf:cli-display-separated;
        presence true;
      }
    }

    // line * / login
    container login {
      tailf:info "Enable password checking";
      tailf:cli-delete-when-empty;
      presence true;
      // line * / login local
      leaf local {
        type empty;
      }
      // line * / login authentication
      leaf authentication {
        type string;
      }
    }

    // line * / logout-warning
    leaf logout-warning {
      tailf:info "Set Warning countdown for absolute timeout of line";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Warning time in seconds";
      }
    }

    // line * / ipv6 access-class *
    container ipv6 {
      tailf:info "IPv6 options";
      list access-class {
        tailf:info "Filter connections based on an IPv6 access list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
      }
    }

    // line * / history size
    container history {
      tailf:info "Enable and control the command history function";
      leaf size {
        tailf:info "Set history buffer size";
        type uint16 {
          tailf:info "<0-256>;;Size of history buffer";
          range "0..256";
        }
      }
    }

    // line * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses password-07-grouping;
    }

    // line * / privilege
    container privilege {
      tailf:info "Change privilege level for line";
      leaf level {
        tailf:info "Assign default privilege level for line";
        type uint8 {
          tailf:info "<0-15>;;Default privilege level for line";
          range "0..15";
        }
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no "+
        "input traffic";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf session-timeout-value {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf "output" {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set async line stop bits";
      type enumeration {
        enum "1" {
          tailf:info "One stop bit";
        }
        enum "1.5" {
          tailf:info "One and one-half stop bits";
        }
        enum "2" {
          tailf:info "Two stop bits";
        }
      }
    }

    // line * / telnet
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of "+
          "a CR followed by a LF";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";
      tailf:cli-incomplete-no;
      // line * / transport input
      leaf-list "input" {
        tailf:info "Define which protocols to use when connecting "+
          "to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            tailf:info "DEC LAT protocol";
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
          enum lapb-ta {}
          enum mop {}
          enum v120 {}
        }
      }
      // line * / transport output
      leaf-list "output" {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            tailf:info "DEC LAT protocol";
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
          enum lapb-ta {}
          enum mop {}
          enum v120 {}
        }
      }
      // line * / transport preferred
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }

    // line * / rxspeed
    leaf rxspeed {
      tailf:info "Set the receive speed";
      type uint32 {
        tailf:info "<0-4294967295>;;Receive speed";
      }
    }

    // line * / txspeed
    leaf txspeed {
      tailf:info "Set the transmit speed";
      type uint32 {
        tailf:info "<0-4294967295>;;Transmit speed";
      }
    }

    // line * / length
    leaf "length" {
      tailf:info "Set number of lines on a screen";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing)";
        range "0..512";
      }
    }

    // line * / width
    leaf width {
      tailf:info "Set width of the display terminal";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "Number of characters on a screen line";
        range "0..512";
      }
    }

  }

  // queue-size-grouping
  grouping queue-size-grouping {
    leaf queue-size-1 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-2 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-3 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-4 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-5 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-6 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-7 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-8 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
  }

  // grouping interface-common-pre-grouping
  grouping interface-common-pre-grouping {

    // interface * / description
    leaf "description" {
      tailf:info "Interface specific description";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        length "0..240";
      }
    }

    // interface * / mac-address
    leaf mac-address {
      tailf:info "Manually set interface MAC address";
      type string {
        tailf:info "H.H.H;;MAC address";
      }
    }

  }

  // grouping interface-common-grouping
  grouping interface-common-grouping {

    // interface * / authentication
    // NOTE: Called 'dot1x' on some versions
    container authentication {
      tailf:info "set the port-control value";
      leaf port-control {
        type enumeration {
          enum auto {
            tailf:info "PortState will be set to AUTO";
          }
          enum force-authorized {
            tailf:info "PortState set to Authorized";
          }
          enum force-unauthorized {
            tailf:info "PortState will be set to UnAuthorized";
          }
        }
      }
    }

    // interface * / mab
    container mab {
      presence true;
      leaf eap {
        type empty;
      }
    }

    // interface * / l2protocol-tunnel
    container l2protocol-tunnel {
      tailf:info "Tunnel Layer2 protocols";
      tailf:cli-delete-when-empty;
      presence true;

      // interface * / l2protocol-tunnel cdp
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel drop-threshold
      container drop-threshold {
        tailf:info "Set drop threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
      }

      // interface * / l2protocol-tunnel shutdown-threshold
      container shutdown-threshold {
        tailf:info "Set shutdown threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf lldp {
          tailf:info "Link Layer Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
      }

      // interface * / l2protocol-tunnel stp
      leaf stp {
        tailf:info "Spanning Tree Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel vtp
      leaf vtp {
        tailf:info "Vlan Trunking Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel lldp
      leaf lldp {
        tailf:info "Link Layer Discovery Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel point-to-point
      container point-to-point {
        tailf:info "point-to-point L2 Protocol";
        leaf lacp {
          tailf:info "Link Aggregation Control Protocol";
          type empty;
        }
        leaf pagp {
          tailf:info "Port Aggregation Protocol";
          type empty;
        }
        leaf udld {
          tailf:info "Unidirectional Link Detection";
          type empty;
        }
      }
    }

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set encapsulation type for an interface";
      // interface * / encapsulation dot1Q
      container dot1Q {
        tailf:info "IEEE 802.1Q Virtual LAN";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;IEEE 802.1Q VLAN ID required";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:info "Configure this subinterface as a 1Q-in-1Q subinterface";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type union {
            type enumeration {
              enum any {
                tailf:info "All Inner VLAN IDs not configured on another "+
                  "subinterface";
              }
            }
            type string {
              tailf:info "Second (inner) VLAN IDs e.g. "+
                "100,200-300,400,500-600";
            }
          }
        }
        leaf native {
          tailf:info "Make this as native vlan";
          type empty;
        }
      }
      // interface * / encapsulation isl
      container isl {
        tailf:info "Inter Switch Link - Virtual LAN encapsulation";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4095>;;Virtual LAN Identifier.";
            range "1..4095";
          }
        }
      }
      // interface * / encapsulation ppp
      container ppp {
        tailf:info "Point-to-Point protocol";
        presence true;
      }
      // interface * / encapsulation slip
      container slip {
        tailf:info "Serial Line IP";
        presence true;
      }
      // interface * / encapsulation frame-relay
      container frame-relay {
        tailf:info "Frame Relay networks";
        tailf:cli-delete-when-empty;
        presence true;
        leaf IETF {
          tailf:info "Use RFC1490/RFC2427 encapsulation";
          tailf:cli-full-command;
          type empty;
        }
        leaf MFR {
          tailf:info "Multilink Frame Relay bundle interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-full-command;
          type uint32;
          tailf:non-strict-leafref {
            path "/ios:interface/MFR/name";
          }
        }
      }
      // interface * / encapsulation hdlc
      container hdlc {
        tailf:cli-delete-when-empty;
        presence true;
      }
    }

    // interface * / frame-relay
    container frame-relay {
      leaf lmi-type {
        tailf:cli-full-command;
        type enumeration {
          enum ansi {
          }
          enum cisco {
          }
          enum q933a {
          }
        }
      }
      leaf intf-type {
        type enumeration {
          enum dce {
          }
          enum dte {
          }
          enum nni {
          }
        }
      }
      container interface-dlci {
        tailf:info "Define a DLCI on an interface/subinterface";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-fr-dlci";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf dlci {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<16-1007>;;Define a switched or locally "+
              "terminated DLCI";
          }
        }
        leaf encapsulation {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum cisco {
              tailf:info "Use CISCO Encapsulation";
            }
            enum IETF {
              tailf:info "Use RFC1490/RFC2427 Encapsulation";
            }
          }
        }
      }
    }

    // interface * / fair-queue
    container fair-queue {
      tailf:info "Enable Fair Queuing on an Interface";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf congestive-discard-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4096>;;Congestive Discard Threshold";
        }
      }
      leaf dynamic-queues {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<16-4096>;;Number Dynamic Conversation Queues";
        }
      }
      leaf reservable-queues {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-1000>;;Number Reservable Conversation Queues";
        }
      }
    }

    // interface * / flowcontrol
    container flowcontrol {
      tailf:info "Configure flow operation.";
      leaf receive {
        tailf:info "Configure receiving flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }
      leaf send {
        tailf:info "Configure sending flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }
    }

    // interface * / keepalive
    choice keepalive-choice {
      // interface * / no keepalive
      leaf keepalive {
        tailf:info "Enable keepalive";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // interface * / keepalive <period>
      container keepalive-period {
        tailf:cli-drop-node-name;
        leaf keepalive {
          tailf:info "Enable keepalive";
          type uint16 {
            tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
            range "0..32767";
          }
          default 10;
        }
      }
      // interface * / keepalive <period> [retries]
      container keepalive-period-retries {
        tailf:cli-drop-node-name;
        container keepalive {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf period {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
              range "0..32767";
            }
          }
          leaf retries {
            tailf:cli-drop-node-name;
            type uint8 {
              range "1..255";
            }
          }
        }
      }
    }

    // interface * / snmp
    container snmp {
      tailf:info "Modify SNMP interface parameters";
      container ifindex {
        tailf:info "Persist ifindex for the interface";
        leaf persist {
          tailf:info "Enable/Disable ifIndex persistence ";
          type empty;
        }
      }
      // interface * / snmp trap
      container trap {
        tailf:info "Allow a specific SNMP trap";
        // interface * / no snmp trap link-status
        leaf link-status {
          tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
        container link-status-capas {
          tailf:cli-drop-node-name;
          container link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            container permit {
              tailf:info "Permit the following capability";
              leaf duplicates {
                tailf:info "Permit duplicate SNMP LINKUP and LINKDOWN traps";
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / flow-sampler
    container flow-sampler {
      tailf:info "Attach flow sampler to the interface";
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of the flow sampler";
        }
        tailf:non-strict-leafref {
          path "/ios:flow-sampler-map/name";
        }
      }
      container egress {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Name of the flow sampler";
          }
          tailf:non-strict-leafref {
            path "/ios:flow-sampler-map/name";
          }
        }
        leaf egress {
          tailf:info "Egress flow sampler";
          type empty;
        }
      }
    }

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-999>;;Milliseconds";
            range "50..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-999>;;Milliseconds";
            range "50..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }

    // interface * / bandwidth
    container bandwidth {
      tailf:info "Set bandwidth informational parameter";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf inherit {
        tailf:cli-optional-in-sequence;
        tailf:info "Specify how bandwidth is inherited";
        type empty;
      }
      leaf kilobits {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-10000000>;;Bandwidth in kilobits";
          range "1..10000000";
        }
      }
    }

    // interface * / cdp
    container cdp {
      tailf:info "CDP interface subcommands";

      // interface * / no cdp enable
      leaf enable {
        tailf:info "Enable CDP on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / cdp tlv
      container tlv {
        tailf:info "Enable exchange of specific tlv information";
        container app {
          tailf:info "Enable/Configure Application TLV";
          tailf:cli-display-separated;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-sequence-commands;
          presence true;
          leaf tlvtype {
            tailf:info "Configure APP TLV";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "Configure App TLV Type information";
              range "1001..65535";
            }
          }
          leaf "value" {
            tailf:info "Configure App TLV Value information";
            type string {
              tailf:info "WORD;;Configure App TLV value information";
            }
          }
        }
        leaf server-location {
          tailf:info "Enable CDP location server on interface";
          tailf:cli-full-command;
          type empty;
        }
        leaf location {
          tailf:info "Exchange location information";
          tailf:cli-full-command;
          type empty;
        }
        // log
      }
    }

    // interface * / mop
    container mop {
      tailf:info "DEC MOP server commands";
      // interface * / no mop enabled
      leaf xenabled {
        tailf:alt-name enabled;
        tailf:info "Enable MOP for interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "Enable event dampening";
      presence "true";
      leaf dampening-time {
        tailf:cli-drop-node-name;
        tailf:cli-delete-container-on-delete;
        tailf:info "<1-30>;;Half-life time for penalty";
        type uint16 {
          range 1..30;
        }
      }
    }

    // interface * / hold-queue *
    list hold-queue {
      tailf:info "Set hold queue depth";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Input queue";
          }
          enum out {
            tailf:info "Output queue";
          }
        }
      }
      leaf queue-length {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type uint16 {
          tailf:info "<0-4096>;;Queue length";
          range "0..4096";
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "Configure MPLS interface parameters";

      // interface * / mpls accounting experimental
      container accounting {
        tailf:info "Enable MPLS accounting on this interface";
        container experimental {
          tailf:info "Count packets by MPLS experimental value on "
            +"this interface";
          leaf "input" {
            tailf:info "received packets";
            type empty;
          }
          leaf "output" {
            tailf:info "transmitted packets";
            type empty;
          }
        }
      }

      // interface * / mpls bgp forwarding
      container bgp {
        tailf:info "MPLS BGP";
        leaf forwarding {
          tailf:info "Configure MPLS forwarding for directly "
            +"connected BGP peers";
          type empty;
        }
      }

      // interface * / mpls label protocol
      container label {
        tailf:info "Label properties";
        leaf protocol {
          tailf:info "Configure label/tag distribution "
            +"protocol (LDP/TDP)";
          type enumeration {
            enum both {
              tailf:info "Use LDP or TDP (Adapt to peer "
                +"on multiaccess interface)";
            }
            enum ldp {
              tailf:info "Use LDP (default)";
            }
            enum tdp {
              tailf:info "Use TDP";
            }
          }
        }
      }

      // interface * / mpls ldp
      container ldp {
        tailf:info "Configure Label Distribution Protocol "
          +"(LDP) parameters";
        container discovery {
          tailf:info "Configure interface LDP Discovery parameters";
          // interface * / mpls ldp discovery transport-address
          leaf transport-address {
            tailf:info "Specify interface LDP transport address";
            type ldp-discovery-address-type;
          }
        }
      }

      // interface * / mpls mtu
      leaf mtu {
        tailf:info "Set MPLS Maximum Transmission Unit";
        tailf:cli-full-command;
        type union {
          type uint16 {
            tailf:info "<1501-1524>;;MTU (baby giants bytes)";
            range "1501..1524";
          }
          type uint16 {
            tailf:info "<64-1500>;;MTU (bytes)";
            range "64..1500";
          }
          type uint16 {
            tailf:info "<64-9216>;;MTU size in bytes";
            range "64..9216";
          }
        }
        default 1500;
      }

      // interface * / mpls traffic-eng
      container traffic-eng {
        tailf:info "Configure Traffic Engineering parameters";

        // interface * / mpls traffic-eng administrative-weight
        leaf administrative-weight {
          tailf:info "Set the administrative weight for the "
            +"interface";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Weight";
            range "0..4294967295";
          }
        }

        // interface * / mpls traffic-eng backup-path
        leaf backup-path {
          tailf:info "Configure an MPLS TE backup for this interface";
          type string {
            tailf:info "Tunnel;;Tunnel interface";
          }
          //FIXME: leafref interface Tunnel *
        }

        // interface * / mpls traffic-eng attribute-flags
        leaf attribute-flags {
          tailf:info "Set user-defined interface "
            +"attibute flags";
          tailf:cli-full-command;
          type string {
            tailf:info "<0x0-0xFFFFFFFF>;;Attribute flags";
          }
        }

        // interface * / mpls traffic-eng flooding
        container flooding {
          tailf:info "Set flooding parameters";
          container thresholds {
            tailf:info "Set flooding thresholds";
            leaf-list down {
              tailf:info "Set the thresholds for decreased "
                +"resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "<0-100>;;decreased bandwidth "
                  +"usage (percent)";
                range "0..100";
              }
            }
            leaf-list up {
              tailf:info "Set the thresholds for increased "
                +"resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "<0-100>;;increased bandwidth usage "
                  +"(percent)";
                range "0..100";
              }
            }
          }
        }

        // interface * / mpls traffic-eng tunnels
        leaf tunnels {
          tailf:info "enable MPLS Traffic Engineering tunnels";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / mpls ip
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / isis
    container isis {
      tailf:info "IS-IS commands";

      // interface * / isis bfd
      container bfd {
        tailf:info "Bidirectional Forwarding Protocol";
        presence true;
      }

      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
        default level-1-2;
      }

      // interface * / isis network point-to-point
      leaf network {
        tailf:info "Network type";
        tailf:cli-full-command;
        type enumeration {
          enum point-to-point {
            tailf:info "Specify ISIS point-to-point network";
          }
        }
      }

      // interface * / isis metric
      choice metric-choice {
        case default-case {
          leaf metric {
            tailf:info "Configure the metric for interface";
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
          }
        }
        case level-case {
          container metric-level {
            tailf:cli-drop-node-name;
            list metric {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key level;
              leaf level {
                type enumeration {
                  enum level-1 {
                    tailf:info "Apply metric to level-1 links";
                  }
                  enum level-2 {
                    tailf:info "Apply metric to level-2 links";
                  }
                }
              }
              leaf "default" {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint32 {
                  tailf:info "<1-16777214>;;Default metric";
                  range "1..16777214";
                }
              }
            }
          }
        }
      }

      uses router-isis-interface-grouping;

      // interface * / isis ipv6 metric
      container ipv6 {
        tailf:info "IPv6 interface configuration";
        container metric-level {
          tailf:cli-drop-node-name;
          //FIXME: choice of below & leaf metric
          list metric {
            tailf:info "Configure the metric for interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Apply metric to level-1 links";
                }
                enum level-2 {
                  tailf:info "Apply metric to level-2 links";
                }
              }
            }
            leaf "value" {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type union {
                type uint32 {
                  tailf:info "<1-16777214>;;Default metric";
                  range "1..16777214";
                }
                type enumeration {
                  enum maximum {
                    tailf:info "Maximum metric. All routers will exclude "+
                      "this link from their SPF";
                  }
                }
              }
            }
          }
        }
      }
    }

    // interface * / vrf forwarding
    // interface * / ip vrf forwarding
    choice vrf-choice {
      container ip-vrf {
        tailf:cli-drop-node-name;
        container ip {
          container vrf {
            leaf forwarding {
              tailf:info "Configure forwarding table";
              tailf:callpoint interface-vrf-hook { tailf:set-hook node; }
              type string {
                tailf:info "WORD;;VRF name";
              }
              tailf:non-strict-leafref {
                path "/ios:ip/vrf/name";
              }
            }
          }
        }
      }
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        // interface * / vrf forwarding
        leaf forwarding {
          tailf:info "Configure forwarding table";
          tailf:callpoint interface-vrf-hook { tailf:set-hook node; }
          type string {
            tailf:info "WORD;;VRF name";
          }
          tailf:non-strict-leafref {
            path "/ios:vrf/definition/name";
          }
        }
      }
    }

    // interface * / ip
    container ip {
      tailf:info "Interface Internet Protocol config commands";

      // interface * / ip access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:code-name "access_group_direction_in";
              tailf:info "inbound packets";
            }
            enum out {
              tailf:code-name "access_group_direction_out";
              tailf:info "outbound packets";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
      }

      // interface * / ip accounting
      container accounting {
        tailf:info "Enable IP accounting on this interface";
        tailf:cli-delete-when-empty;
        presence true;
        leaf access-violations {
          tailf:info "Account for IP packets violating access lists on this"+
            " interface";
          tailf:cli-full-command;
          type empty;
        }
        leaf output-packets {
          tailf:info "Account for IP packets output on this interface";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / ip vrf
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        leaf receive {
          tailf:info "Add Interface Address into VRF Table";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Table name";
          }
        }
        leaf sitemap {
          tailf:info "Configure route-map for routes"+
            "received from this site";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Name of the route-map";
          }
          // Note: no dependency to /ios:route-map
        }
      }

      // interface * / ip address
      choice address-choice {
        // interface * / ip unnumbered
        leaf unnumbered {
          tailf:info "Enable IP processing without an explicit address";
          type string;
        }
        // interface * / no ip address
        container no-address {
          tailf:cli-drop-node-name;
          leaf address {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
        // interface * / ip address
        container address {
          tailf:info "Set the IP address of an interface";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          choice address-choice {
            case fixed-case {
              // interface * / ip address a.b.c.d m.a.s.k
              container primary {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf address {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  tailf:cli-incomplete-no;
                  tailf:cli-diff-dependency "/ios:vrf/definition";
                  tailf:cli-diff-dependency "../../../../vrf/forwarding";
                  mandatory true;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  mandatory true;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
              }
              // interface * / ip address a.b.c.d m.a.s.k secondary
              list secondary {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                tailf:cli-diff-dependency "../primary/address";
                key "address mask";
                leaf address {
                  tailf:cli-incomplete-no;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
                leaf secondary {
                  tailf:info "Make this IP address a secondary address";
                  type empty;
                }
              }
            }
            // interface * / ip address dhcp
            case dhcp-case {
              container dhcp {
                tailf:info "IP Address negotiated via DHCP";
                tailf:cli-sequence-commands;
                presence true;
                container client-id {
                  tailf:info "Specify client-id to use";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  uses interface-name-grouping;
                }
                leaf hostname {
                  tailf:info "Specify value for hostname option";
                  type string {
                    tailf:info "WORD;;hostname string";
                  }
                }
              }
            }
            // interface * / ip address negotiated
            case negotiated-case {
              container negotiated {
                tailf:info "IP Address negotiated over PPP";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence true;
                leaf previous {
                  tailf:info "IPCP attempts to negotiate previous address "+
                    "assigned";
                  type empty;
                }
              }
            }
          }
        }
      }

      // interface * / ip directed-broadcast
      container directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        tailf:cli-delete-when-empty;
        presence true;
        leaf access-list {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-199>;;A standard IP access list "+
                "number";
              range "1..199";
            }
            type uint16 {
              tailf:info "<1300-2699>;;A standard IP expanded "+
                "access list number";
              range "1300..2699";
            }
          }
        }
      }

      // interface * / ip router
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ip flow
      container flow {
        tailf:info "NetFlow related commands";
        leaf ingress {
          tailf:info "Enable inbound NetFlow";
          type empty;
        }
        leaf egress {
          tailf:info "Enable outbound NetFlow";
          type empty;
        }
        // monitor
      }

      // interface * / ip helper-address
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice helper-choice {
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf vrf {
            tailf:info "VRF name for helper-address (if different from "+
              "interface VRF)";
            tailf:cli-optional-in-sequence;
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP destination address";
          }
        }
      }

      // interface * / ip ospf
      container ospf {
        tailf:info "OSPF interface commands";

        // interface * / ip ospf *
        list process-id {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
            }
          }
          leaf area {
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf secondaries {
            tailf:info "Include or exclude secondary IP addresses";
            type empty;
          }
          leaf none {
            tailf:info "Do not include secondary IP addresses";
            type empty;
          }
        }

        // interface * / ip ospf authentication message-digest
        container authentication {
          tailf:info "Enable authentication";
          tailf:cli-delete-when-empty;
          presence true;
          leaf option {
            tailf:cli-drop-node-name;
            type enumeration {
              enum message-digest {
                tailf:info "Use message-digest authentication";
              }
              enum "null" {
                tailf:info "Use no authentication";
              }
            }
          }
        }

        // interface * / ip ospf message-digest-key *
        list message-digest-key {
          tailf:info "Message digest authentication password (key)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          leaf md5 {
            tailf:info "Use MD5 algorithm";
            type empty;
          }
          leaf enc-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<0-7>;;Encryption type "+
                "(0 for not yet encrypted, 7 for proprietary)";
              range "0..7";
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The OSPF password (key) (maximum 16 characters)";
            }
          }
        }

        // interface * / ip ospf network
        leaf network {
          tailf:info "Network type";
          tailf:cli-full-command;
          type enumeration {
            enum broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum non-broadcast {
              tailf:info "Specify OSPF NBMA network";
            }
            enum point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
            }
            enum point-to-point {
              tailf:info "Specify OSPF point-to-point network";
            }
          }
        }

        // interface * / ip ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ip ospf bfd
        container bfd {
          tailf:info "BFD interface configuration commands";
          presence true;
          leaf enable {
            tailf:cli-full-command;
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                tailf:info "Disable BFD for this interface";
              }
            }
          }
        }

        // interface * / ip ospf cost
        leaf cost {
          tailf:info "Interface cost";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;Cost";
            range "1..65535";
          }
        }

        // interface * / ip ospf priority
        leaf priority {
          tailf:info "Router priority";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority";
          }
        }
      }

      // interface * / ip pim
      container pim {
        tailf:info "PIM interface commands";
        // interface * / ip pim query-interval
        leaf query-interval {
          tailf:info "PIM router query interval";
          type uint16 {
            tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
            range "1..65535";
          }
        }
        // interface * / ip pim sparse-mode
        leaf sparse-mode {
          tailf:info "Enable PIM sparse-mode operation";
          tailf:cli-diff-dependency "/ios:ip/multicast-routing";
          type empty;
        }
        // interface * / ip pim dr-priority
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to "+
              "larger value";
          }
        }
        // interface * / ip pim snooping
        leaf snooping {
          tailf:info "PIM Snooping enable for Catalyst Vlan";
          type empty;
        }
      }

      // interface * / ip multicast
      container multicast {
        tailf:info "IP multicast interface commands";
        // interface * / ip multicast boundary *
        list boundary {
          tailf:info "Boundary for administratively scoped multicast addresses";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key access-list;
          leaf access-list {
            type exp-ip-acl-type;
          }
        }
      }

      // interface * / ip policy
      container policy {
        tailf:info "Enable policy routing";
        // interface * / ip policy route-map
        leaf route-map {
          tailf:info "Policy route-map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // interface * / no ip unreachables
      leaf unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // interface * / no ip proxy-arp
      leaf proxy-arp {
        tailf:info "Enable proxy ARP";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // interface * / no ip route-cache
      container route-cache-conf {
        tailf:cli-drop-node-name;
        leaf route-cache {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface * / ip route-cache
      container route-cache {
        tailf:info "Enable fast-switching cache for outgoing packets";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;

        // interface * / no ip route-cache cef
        leaf cef {
          tailf:info "Enable Cisco Express Forwarding";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / ip route-cache flow
        leaf flow {
          tailf:info "Enable Flow fast-switching cache";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }

        // interface * / ip route-cache policy
        leaf policy {
          tailf:info "Enable fast-switching policy cache for outgoing packets";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }

        // interface * / ip route-cache same-interface
        leaf same-interface {
          tailf:info "Enable fast-switching on the same interface";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }
      }

      // interface * / ip igmp
      container igmp {
        tailf:info "IGMP interface commands";

        // interface * / ip igmp join-group
        list join-group {
          tailf:info "IGMP join multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf source {
            tailf:info "Include SSM source";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP source address";
            }
          }
        }

        // interface * / ip igmp static-group
        container static-group {
          tailf:info "IGMP static multicast group";
          list groups {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            key name;
            leaf name {
              tailf:cli-suppress-range;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP group address";
                }
                type enumeration {
                  enum "*" {
                    tailf:info "Populated for all groups";
                  }
                }
              }
            }
          }
          list class-map {
            tailf:info "Class map of type multicast-flows";
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Name of class-map of type multicast-flows";
              }
              tailf:non-strict-leafref {
                path "/ios:class-map/name";
              }
            }
          }
        }

        // interface * / ip igmp version
        leaf version {
          tailf:info "IGMP version";
          type uint8 {
            tailf:info "<1-3>;;version number";
            range "1..3";
          }
        }

        // interface * / ip igmp access-group
        leaf access-group {
          tailf:info "IGMP group access group";
          type exp-ip-acl-type;
        }
      }

      // interface * / ip redirects
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        type empty;
      }

      // interface * / ip nhrp
      container nhrp {
        tailf:info "NHRP interface subcommands";
        leaf network-id {
          tailf:info "NBMA network identifier";
          type uint32 {
            tailf:info "<1-4294967295>;;Network identifier";
          }
        }
        container shortcut {
          tailf:info "Enable shortcut switching";
          tailf:cli-delete-when-empty;
          presence true;
          leaf virtual-template {
            type uint16 {
            }
          }
          //FIXME: dependency?
        }
        container redirect {
          tailf:info "Enable NHRP redirect traffic indication";
          tailf:cli-delete-when-empty;
          presence true;
          leaf timeout {
            tailf:info "Specify interval over which to throttle";
            type uint8 {
              tailf:info "<2-30>;;Interval in seconds";
              range "2..30";
            }
          }
        }

      }

      // interface * / ip tcp
      container tcp {
        tailf:info "TCP header compression and other parameters";
        // interface * / ip tcp adjust-mss
        leaf adjust-mss {
          tailf:info "Adjust the mss of transit packets";
          type uint16 {
            tailf:info "<500-1460>;;Maximum segment size in bytes";
            range "500..1460";
          }
        }
        // interface * / ip tcp header-compression
        container header-compression {
          tailf:info "Enable TCP header compression";
          tailf:cli-delete-when-empty;
          presence true;
          leaf "type" {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ietf-format {
                tailf:info "Compressing using IETF format";
              }
              enum iphc-format {
                tailf:info "Using PPP  IPHC compression for TCP/UDP/RTP";
              }
              enum passive {
                tailf:info "Compress only for destinations which send "+
                  "compressed headers";
              }
            }
          }
        }
      }

      // interface * / ip rtp
      container rtp {
        tailf:info "RTP parameters";
        container header-compression {
          tailf:info "Enable RTP header compression";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf "type" {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum ietf-format {
                tailf:info "Compressing using IETF format";
              }
              enum iphc-format {
                tailf:info "Compress using IPHC format";
              }
              enum passive {
                tailf:info "Compress only for destinations which send "+
                  "compressed headers";
              }
            }
          }
          leaf periodic-refresh {
            tailf:info "Periodic context refresh";
            type empty;
          }
        }
        leaf compression-connections {
          tailf:info "Maximum number of compressed connections";
          type uint16 {
            tailf:info "<1-1000>;;Number of connections";
            range "1..1000";
          }
        }
      }

      // interface * / ip mobile
      container mobile {
        tailf:info "Mobile IP support";

        // interface * / ip mobile router-service
        container router-service {
          tailf:info "Mobile router support";

          // interface * / ip mobile router-service roam
          container roam {
            tailf:info "Roaming interface";
            tailf:cli-diff-dependency "/ios:router/mobile";
            presence true;
            leaf priority {
              tailf:info "Priority level";
              type uint8 {
                tailf:info "<0-255>;;Priority level";
              }
            }
          }

          // interface * / ip mobile router-service description
          leaf "description" {
            tailf:info "roaming interface description";
            tailf:cli-multi-value;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;roaming interface description";
            }
          }

          // interface * / ip mobile router-service link-type
          leaf link-type {
            tailf:info "Link type of the roaming interface";
            type string; //fixme: enum
          }

          // interface * / ip mobile router-service tunnel
          container tunnel {
            tailf:info "Tunnel parameters";
            leaf mode {
              tailf:info "Tunnel encapsulation mode";
              type enumeration {
                enum gre {
                  tailf:info "Generic Routing Encapsulation";
                }
                enum ipip {
                  tailf:info "IP-in-IP Encapsulation";
                }
              }
            }
          }

          // interface * / ip mobile router-service collocated
          container collocated {
            tailf:info "Collocated care-of address options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf gateway {
              tailf:info "Default gateway for static collocated "+
                "care-of address";
              tailf:cli-optional-in-sequence;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address to use as the default gateway";
              }
            }
            leaf ccoa-only {
              tailf:info "Only register a collocated CoA";
              tailf:cli-optional-in-sequence;
              type empty;
            }

            // interface * / ip mobile router-service collocated registration
            container registration {
              tailf:info "Registration options";
              tailf:cli-break-sequence-commands;
              leaf retry {
                tailf:info "Retry interval in seconds (1-65535)";
                type uint16 {
                  tailf:info "<1-65535>;;Seconds (default 60; 65535 = never)";
                  range "1..65535";
                }
                default 60;
              }
              container nat {
                tailf:info "NAT traversal settings";
                container traversal {
                  tailf:info "Enable NAT traversal support";
                  tailf:cli-compact-syntax;
                  presence true;
                  leaf keepalive {
                    tailf:info "Keepalive message frequency (sec)";
                    type uint16 {
                      tailf:info "<0-65535>;;keepalive value";
                    }
                  }
                  leaf force {
                    tailf:info "Force home agent to use UDP encapsulation "+
                      "for the tunnel";
                    type empty;
                  }
                }
              }
            }
            leaf encapsulation {
              type enumeration {
                enum slip {}
                enum ppp {}
              }
            }
          }
        }
      }

      // interface * / ip virtual-reassembly
      container virtual-reassembly {
        tailf:info "Enable Virtual Fragment Reassembly";
        tailf:cli-compact-syntax;
        leaf max-reassemblies {
          type uint32; // number
        }
        leaf max-fragments {
          tailf:info "<1-64>;;Number of fragments per datagram";
          type uint8 {
            tailf:info "<1-64>;;Number of fragments per datagram";
            range "1..64";
          }
        }
        leaf timeout {
          type uint32; // seconds
        }
        leaf drop-fragments {
          tailf:info "Drop all the incoming fragments";
          type empty;
        }
        leaf in {
          type empty;
        }
        leaf out {
          type empty;
        }
      }

      // interface * / ip dhcp
      container dhcp {
        tailf:info "Configure DHCP parameters for this interface";

        // interface * / ip dhcp relay
        container relay {
          tailf:info "DHCP relay configuration parameters";
          container information {
            tailf:info "DHCP relay information option";
            container check-reply {
              tailf:info "Validate relay information in BOOTREPLY";
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }
            container option {
              tailf:info "DHCP relay information option";
              leaf subscriber-id {
                tailf:info "Subscriber identifier sub option";
                type string {
                  tailf:info "WORD;;Subscriber identifier string";
                }
              }
            }
            container option-insert {
              tailf:info "Insert relay information in BOOTREQUEST";
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }
            leaf policy-action {
              tailf:info "Define reforwarding policy";
              type enumeration {
                enum drop {
                  tailf:info "Do not forward BOOTREQUEST message";
                }
                enum encapsulate {
                  tailf:info "Encapsulate existing information";
                }
                enum keep {
                  tailf:info "Leave existing information alone";
                }
                enum replace {
                  tailf:info "Replace existing information";
                }
              }
            }
            leaf trusted {
              tailf:info "Received DHCP packet may contain relay info option "
                +"with zero giaddr";
              type empty;
            }
          }
        }

        // interface * / ip dhcp snooping
        container snooping {
          tailf:info "DHCP Snooping";

          // interface * / ip dhcp snooping limit
          container limit {
            tailf:info "DHCP Snooping limit";
            leaf rate {
              tailf:info "DHCP Snooping limit";
              type uint16 {
                tailf:info "<1-2048>;;DHCP snooping rate limit";
                range "1..2048";
              }
            }
          }

          // interface * / ip dhcp snooping trust
          leaf trust {
            tailf:info "DHCP Snooping trust config";
            type empty;
          }

          // interface * / ip dhcp snooping vlan *
          list vlan {
            tailf:info "DHCP Snooping vlan";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping vlan";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              tailf:cli-flatten-container;
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id (3-63 "
                          +"chars)";
                        length "3..63";
                      }
                    }
                  }
                }
              }
            }
          }

          // interface * / ip dhcp snooping bridge-domain *
          list bridge-domain {
            tailf:info "DHCP Snooping bridge-domain";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping bridge-domain number";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              tailf:cli-flatten-container;
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ip mtu
      leaf mtu {
        tailf:info "Set IP Maximum Transmission Unit";
        type uint16 {
          tailf:info "<68-9198>;;MTU (bytes)";
          range "68..9198";
        }
      }

      // interface * / ip nat
      container nat {
        tailf:info "NAT interface commands";
        leaf allow-static-host {
          tailf:info "Allow static-ip clients";
          type empty;
        }
        leaf enable {
          tailf:info "Enable Address Translation (NVI)";
          type empty;
        }
        choice nat-choice {
          leaf inside {
            tailf:info "Inside interface for address translation";
            type empty;
          }
          leaf outside {
            tailf:info "Outside interface for address translation";
            type empty;
          }
        }
      }

      // interface * / ip rsvp
      container rsvp {
        tailf:info "RSVP Interface Commands";

        // interface * / ip rsvp bandwidth
        container bandwidth {
          tailf:info "RSVP Reservable Bandwidth (kbps)";
          tailf:cli-reset-container;
          presence true;
        }

        // interface * / ip rsvp signalling hello
        container signalling {
          tailf:info "RSVP signalling";
          container hello {
            tailf:info "Enable neighbor-down detection";
            presence true;
            // interface * / ip rsvp signalling hello graceful-restart
            container graceful-restart {
              tailf:info "Configure RSVP Graceful Restart";
              presence true;
            }
          }
        }

        // interface * / ip rsvp resource-provider
        container resource-provider {
          tailf:info "RSVP resource provider";
          choice resource-provider-choice {
            leaf none {
              tailf:info "Associates NO resources with reservations";
              type empty;
            }
            leaf wfq {
              tailf:info "Associates WFQ resources with reservations";
              type enumeration {
                enum interface {
                  tailf:info "Associates WFQ queues and bandwidth at the "+
                    "interface level with reservations";
                }
                enum pvc {
                  tailf:info "Associates WFQ queues and bandwidth at the "+
                    "PVC level with reservations";
                }
              }
            }
          }
        }
      }

      // interface * / ip verify
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container reverse-path {
            tailf:info "Reverse path validation of source address "+
              "(old command format)";
            presence true;
          }
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the "
                +"source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which"
                    +" packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability "+
                "in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking "+
                "source address";
              type empty;
            }

          }
        }
      }

      // interface * / ip rip
      container rip {
        tailf:info "Router Information Protocol";

        // interface * / ip rip receive version
        container receive {
          tailf:info "advertisement reception";
          leaf version {
            tailf:info "version control";
            type enumeration {
              enum "1" {
                tailf:info "RIP version 1";
              }
              enum "2" {
                tailf:info "RIP version 2";
              }
            }
          }
        }

        // interface * / ip rip authentication
        container authentication {
          tailf:info "Authentication control";

          // interface * / ip rip authentication mode
          leaf mode {
            tailf:info "Authentication mode";
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text authentication";
              }
            }
          }

          // interface * / ip rip authentication key-chain
          leaf key-chain {
            tailf:info "Authentication key-chain";
            type string {
              tailf:info "LINE;;name of key-chain";
            }
            tailf:non-strict-leafref {
              path "/ios:key/chain/name";
            }
          }
        }
      }
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";

      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        choice address-choice {
          case autoconfig-case {
            container autoconfig {
              tailf:info "Obtain address using autoconfiguration";
              presence true;
              leaf "default" {
                tailf:info "Insert default route";
                type empty;
              }
            }
          }
          case manual-case {
            list prefix-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "prefix";
              leaf prefix {
                type ios:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;"+
                    "IPv6 prefix";

                }
              }
              leaf anycast {
                tailf:info "Configure as an anycast";
                tailf:cli-full-command;
                type empty;
              }
              leaf eui-64 {
                tailf:info "Use eui-64 interface identifier";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        type empty;
      }

      // interface * / ipv6 traffic-filter *
      list traffic-filter {
        tailf:info "Access control list for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "inbound packets";
            }
            enum "out" {
              tailf:info "outbound packets";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }

      // interface * / ipv6 nd
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";

        // interface * / ipv6 nd dad
        container dad {
          tailf:info "Duplicate Address Detection";
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts";
              range "0..600";
            }
          }
        }

        // interface * / ipv6 nd prefix
        container "prefix" {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";

          // interface * / ipv6 nd prefix *
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key ipv6-prefix;
            leaf ipv6-prefix {
              type union {
                type inet:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type enumeration {
                  enum "default" {
                    tailf:info "Specify prefix default parameters";
                  }
                }
              }
            }
            // interface * / ipv6 nd prefix * no-advertise
            choice advertise-choice {
              case no-advertise {
                leaf no-advertise {
                  tailf:info "Do not advertise prefix";
                  tailf:cli-full-command;
                  type empty;
                }
              }
              case advertise {
                // interface * / ipv6 nd prefix * <valid-lifetime>
                leaf valid-lifetime {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type union {
                    type enumeration {
                      enum "infinite" {
                        tailf:info "Infinite Valid Lifetime";
                      }
                    }
                    type uint32 {
                      tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
                    }
                  }
                }
                // interface * / ipv6 nd prefix * <preferred-lifetime>
                leaf preferred-lifetime {
                  tailf:cli-drop-node-name;
                  type union {
                    type enumeration {
                      enum "infinite" {
                        tailf:info "Infinite Preferred Lifetime";
                      }
                    }
                    type uint32 {
                      tailf:info "<0-4294967295>;;Preferred Lifetime (secs)";
                    }
                  }
                }
                // interface * / ipv6 nd prefix * off-link
                leaf off-link {
                  tailf:cli-break-sequence-commands;
                  tailf:info "Prefix is offlink";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-autoconfig
                leaf no-autoconfig {
                  tailf:info "Do not use prefix for autoconfiguration";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-rtr-address
                leaf no-rtr-address {
                  tailf:info "Do not send full router address in prefix advert";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-onlink
                leaf no-onlink {
                  tailf:info "Do not use prefix for onlink determination";
                  type empty;
                }
              }
            }
          }
        }

        // interface * / ipv6 nd managed-config-flag
        leaf managed-config-flag {
          tailf:info "Hosts should use DHCP for address config";
          type empty;
        }

        // interface * / ipv6 nd other-config-flag
        leaf other-config-flag {
          tailf:info "Hosts should use DHCP for non-address config";
          type empty;
        }

        // interface * / ipv6 nd ra
        container ra {
          tailf:info "Router Advertisement control";

          // interface * / ipv6 nd ra suppress
          container suppress {
            tailf:info "Suppress IPv6 Router Advertisements";
            tailf:cli-delete-when-empty;
            presence true;
            leaf all {
              tailf:info "Suppress all ipv6 Router advertisements";
              type empty;
            }
          }

          // interface * / ipv6 nd ra interval
          container interval {
            choice interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<4-1800>;;RA Interval (sec)";
                  range "4..1800";
                }
              }
              leaf msec {
                tailf:info "Interval in milliseconds";
                type uint32 {
                  tailf:info "<70-1800000>;;RA Interval (msec)";
                  range "70..1800000";
                }
              }
            }
          }
        }
      }

      // interface * / ipv6 mld
      container mld {
        tailf:info "interface commands";

        // interface * / ipv6 mld access-group
        leaf access-group {
          tailf:info "source, group membership access";
          type string {
            tailf:info "WORD;;Named access list specifying access group range";
          }
        }
      }

      // interface * / no ipv6 redirects
      leaf redirects {
        tailf:info "Enable sending of ICMP Redirect messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no ipv6 unreachables
      leaf unreachables {
        tailf:info "Enable sending of ICMP Unreachable messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ipv6 router isis
      container router {
        tailf:info "IPv6 Router interface commands";
        container isis {
          tailf:info "isis  IS-IS Routing for IPv6";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ipv6 ospf
      container ospf {
        tailf:info "OSPF interface commands";
        // interface * / ipv6 ospf *
        list process {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
                range "0..4294967295";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf instance {
            tailf:info "Set the OSPF instance";
            type union {
              type uint8 {
                tailf:info "<0-31>;;Instance ID";
                range "0..31";
              }
              type uint8 {
                tailf:info "<32-255>;;Instance ID (DEPRECATED!)";
                range "32..255";
              }
            }
          }
        }

        // interface * / ipv6 ospf bfd
        container bfd {
          tailf:info "Enable BFD on this interface";
          presence true;
          leaf disable {
            tailf:info "Disable BFD on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf cost
        leaf cost {
          tailf:info "Route cost of this interface";
          type uint16 {
            tailf:info "<1-65535>;;Route cost of this interface";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf database-filter
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding";
          choice database {
            leaf all {
              tailf:info "Filter all LSA";
              type enumeration {
                enum out {
                  tailf:info "Outgoing LSA";
                }
              }
            }
            leaf disable {
              tailf:info "Disable LSA Filter on this interface";
              type empty;
            }
          }
        }

        // interface * / ipv6 ospf dead-interval
        leaf dead-interval {
          tailf:info "Interval after which a neighbor is declared dead";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf demand-circuit
        container demand-circuit {
          tailf:info "OSPF demand circuit";
          presence true;
          leaf disable {
            tailf:info "Disable demand circuit on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf flood-reduction
        container flood-reduction {
          tailf:info "OSPF Flood Reduction";
          presence true;
          leaf disable {
            tailf:info "Disable Flood Reduction on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf mtu-ignore
        container mtu-ignore {
          tailf:info "Ignores the MTU in DBD packets";
          presence true;
          leaf disable {
            tailf:info "Disable Ingore MTU on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf priority
        leaf priority {
          tailf:info "Router priority";
          type uint16 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf retransmit-interval {
          tailf:info "Time between retransmitting lost link state "+
            "advertisements";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf transmit-delay {
          tailf:info "Link state transmit delay";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }
      }

      // interface * / ipv6 mtu
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        type uint16 {
          tailf:info "<1280-9198>;;MTU (bytes)";
          range "1280..9198";
        }
      }

      // interface * / ipv6 crypto map
      container crypto {
        tailf:info "Encryption/Decryption commands";
        container map {
          tailf:info "Assign a Crypto Map";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/map/name";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            when "../redundancy";
            type empty;
          }
        }
      }

      // interface * / ipv6 verify
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ipv6 verify unicast reverse-path
          container reverse-path {
            tailf:info "Reverse path validation of source address "+
              "(old command format)";
            tailf:cli-delete-when-empty;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }
      }

      // interface * / ipv6 dhcp
      container dhcp {
        tailf:info "IPv6 DHCP interface subcommands";

        // interface * / ipv6 dhcp relay destination *
        container relay {
          tailf:info "Act as an IPv6 DHCP relay agent";
          list destination {
            tailf:info "Configure relay destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key ipv6-address;
            leaf ipv6-address {
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
            }
            leaf source-address {
              tailf:info "Configure source address to use for relay-forward";
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 src address";
              }
            }
            leaf link-address {
              tailf:info "Configure link-address to use for relay-forward";
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 link address";
              }
            }
          }
        }
      }

    }

    // interface * / delay
    leaf delay {
      tailf:info "Specify interface throughput delay";
      type uint32 {
        tailf:info "<1-16777215>;;Throughput delay (tens of microseconds)";
      }
    }

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      type uint16 {
        tailf:info "<30-600>;;Load interval delay in seconds";
        range "0..600";
      }
    }

    // interface * / logging
    container logging {
      tailf:info "Configure logging for interface";
      container event {
        tailf:info "Interface events";
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          tailf:cli-full-command;
          type empty;
        }
        leaf subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / max-reserved-bandwidth
    leaf max-reserved-bandwidth {
      tailf:info "Maximum Reservable Bandwidth on an Interface";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-100>;;Max. reservable bandwidth as percent of "+
          "interface bandwidth";
        range "1..100";
      }
    }

    // interface * / mls
    container mls {
      tailf:info "mls sub/interface commands";

      // interface * / mls qos
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
        // interface * / mls qos trust
        leaf trust {
          tailf:info "trust keyword";
          tailf:cli-full-command;
          type enumeration {
            enum "cos" {
              tailf:info "cos keyword";
            }
            enum "dscp" {
              tailf:info "dscp keyword";
            }
            enum ip-precedence {
              tailf:info "ip-precedence keyword";
            }
          }
        }
        // interface * / mls qos vlan-based
        leaf vlan-based {
          tailf:info "vlan-based keyword";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the interface Maximum Transmission Unit (MTU)";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-18000>;;MTU size in bytes";
        range "64..18000";
      }
    }

    // interface * / ntp
    container ntp {
      tailf:info "Configure NTP";

      // interface * / ntp broadcast
      container broadcast {
        tailf:info "Configure NTP broadcast service";
        //tailf:cli-delete-when-empty;
        presence true;
        container client {
          tailf:info "Listen to NTP broadcasts";
          tailf:cli-full-command;
          presence true;
        }

        // interface * / ntp broadcast destination [version] [key] *
        list destination {
          tailf:info "Configure broadcast destination address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key address;
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf "key" {
            tailf:info "Configure broadcast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Broadcast key number";
            }
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination broadcast IP address";
            }
          }
        }
        container version-key {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf "key" {
            tailf:info "Configure broadcast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Broadcast key number";
            }
          }
        }
      }

      // interface * / ntp disable
      leaf disable {
        tailf:info "Disable NTP traffic (both IP and IPv6)";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ntp multicast
      container multicast {
        tailf:info "Configure NTP multicast service";
        tailf:cli-display-separated;
        tailf:cli-compact-syntax;
        presence true;

        // interface * / ntp multicast *
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key group-address;
          leaf group-address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Multicast group IPv6 address";
              }
            }
          }
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf "key" {
            tailf:info "Configure multicast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Multicast key number";
            }
          }
          leaf ttl {
            tailf:info "TTL of the multicast packet";
            type uint8 {
              tailf:info "<1-255>;;TTL";
              range "1..255";
            }
          }
        }

        // interface * / ntp multicast version
        leaf version {
          tailf:info "Configure NTP version";
          type uint8 {
            tailf:info "<1-4>;;NTP version number";
            range "1..4";
          }
        }

        // interface * / ntp multicast key
        leaf "key" {
          tailf:info "Configure multicast authentication key";
          type uint32 {
            tailf:info "<0-4294967295>;;Multicast key number";
          }
        }

        // interface * / ntp multicast ttl
        leaf ttl {
          tailf:info "TTL of the multicast packet";
          type uint8 {
            tailf:info "<1-255>;;TTL";
            range "1..255";
          }
        }

        // interface * / ntp multicast client *
        container client-list {
          tailf:cli-drop-node-name;
          leaf-list client {
            tailf:info "Listen to NTP multicasts";
            tailf:cli-list-syntax;
            tailf:cli-suppress-list-no;
            tailf:cli-incomplete-no;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast client IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Multicast client IPv6 address";
              }
            }
          }
        }

        // interface * / ntp multicast client
        leaf client {
          tailf:info "Listen to NTP multicasts";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / power
    container power {
      //tailf:info
      container inline {
        //tailf:info
        leaf consumption {
          tailf:cli-full-command;
          type uint16 {
            //tailf:info
            range "4000..15400";
          }
        }
      }
    }

    // interface * / rate-limit
    list rate-limit {
      tailf:info "Rate Limit";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "dir bps bc be conform-action exceed-action";
      leaf dir {
        type enumeration {
          enum "input" {
            tailf:info "Rate limit on input";
          }
          enum "output" {
            tailf:info "Rate limit on output";
          }
        }
      }
      leaf dscp {
        tailf:info "Match dscp value";
        type uint8 {
          tailf:info "<0-63>;;dscp";
          range "0..63";
        }
      }
      //todo: [access-group [rate-limit] acl-index]
      leaf bps {
        tailf:info "<8000-2000000000>;;Bits per second";
        type police-bps-type;
      }
      leaf bc {
        type uint32 {
          tailf:info "<1000-512000000>;;Normal burst bytes";
          range "1000..512000000";
        }
      }
      leaf be {
        type uint32 {
          tailf:info "<2000-1024000000>;;Maximum burst bytes";
          range "2000..1024000000";
        }
      }
      leaf conform-action {
        tailf:cli-expose-key-name;
        type enumeration {
          enum transmit;
        }
      }
      leaf exceed-action {
        tailf:cli-expose-key-name;
        type enumeration {
          enum drop;
        }
      }
    }

    // interface * / service-policy
    container service-policy {
      tailf:info "Configure QoS Service Policy";

      // interface * / service-policy history
      leaf history {
        tailf:cli-full-command;
        tailf:info "Keep history of QoS metrics";
        type empty;
      }

      // interface * / service-policy input
      // interface * / service-policy output
      uses service-policy-grouping;

      // interface * / service-policy type
      container "type" {
        tailf:info "Configure CPL Service Policy";

        // interface * / service-policy type performance-monitor
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "input" {
                tailf:info "Assign policy-map to the input of an interfcae";
              }
              enum "output" {
                tailf:info "Assign policy-map to the output of an interfcae";
              }
            }
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;policy-map name";
            }
            tailf:non-strict-leafref {
              path "/ios:policy-map/name";
            }
          }
        }
      }
    }

    // interface * / shutdown
    leaf shutdown {
      // Note: default to "no shutdown" in order to be able to bring if up.
      tailf:info "Shutdown the selected interface";
      tailf:cli-full-command;
      tailf:cli-show-no;
      type empty;
    }

    // interface * / standby
    container standby {
      tailf:info "HSRP interface configuration commands";
      // interface * / standby version
      leaf version {
        tailf:info "HSRP version";
        tailf:cli-full-command;
        type enumeration {
          tailf:info "<1-2>;;Version number";
          enum "1";
          enum "2";
        }
      }
      // interface * / standby bfd
      leaf bfd {
        tailf:info "Enable HSRP BFD";
        type empty;
      }
      // interface * / standby delay
      container delay {
        tailf:info "HSRP initialisation delay";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum delay";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
        leaf reload {
          tailf:info "Delay after reload";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
      }
      // interface * / standby mac-refresh
      leaf mac-refresh {
        tailf:info "Refresh MAC cache on switch by periodically sending packet "
          +"from virtual mac address";
        type uint8 {
          tailf:info "<0-255>;;Interval to refresh MAC cache";
          range "0..255";
        }
      }

      // interface * / standby use-bia
      container use-bia {
        tailf:info "HSRP uses interface's burned in address";
        presence true;
        container scope {
          tailf:info "Specify the scope of use-bia";
          leaf interface {
            tailf:info "Use-bia applies to all groups on this interface or sub-"
              +"interface";
            type empty;
          }
        }
      }

      // interface * / standby *
      list standby-list {
        //FIXME: key 0 can be ignored (default)
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key group-number;
        leaf group-number {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<0-255>;;group number";
          }
        }
        container authentication {
          tailf:info "Authentication";
          choice auth {
            leaf word {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "md5|text";
              type string {
                tailf:info "WORD;;Plain text authentication string "
                  +"(8 chars max)";
              }
            }
            container md5 {
              tailf:info "Use MD5 authentication";
              leaf key-chain {
                tailf:info "Set key chain";
                type string {
                  tailf:info "WORD;;Name of key-chain";
                }
              }
              container key-string {
                tailf:info "Set key string";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf encrypt {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum 0 {
                      tailf:info "Specifies an UNENCRYPTED key string will "
                      +"follow";
                    }
                    enum 7 {
                      tailf:info "Specifies a HIDDEN key string will follow";
                    }
                  }
                }
                leaf string {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;Key string (64 chars max)";
                  }
                }
                leaf timeout {
                  tailf:info "Set timeout";
                  type uint16 {
                    tailf:info "<0-32767>;;Timeout until only accepting "
                      +"new key (seconds)";
                    range "0..32767";
                  }
                }
              }
            }
            leaf text {
              tailf:info "Plain text authentication";
              type string {
                tailf:info "WORD;;Plain text authentication string "
                  +"(8 chars max)";
              }
            }
          }
        }
        leaf follow {
          tailf:info "Name of HSRP group to follow";
          type string {
            tailf:info "WORD;;name string (25 chars. max)";
          }
        }
        container ip {
          tailf:info "Enable HSRP and set the virtual IP address";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Virtual IP address";
            }
          }
          leaf secondary {
            tailf:info "Make this IP address a secondary virtual IP address";
            type empty;
          }
        }
        leaf ipv6 {
          tailf:info "Enable HSRP IPv6";
          type union {
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 link-local address";
            }
            type ios:ipv6-prefix;
            type enumeration {
              enum autoconfig {
                tailf:info "Obtain address using autoconfiguration";
              }
            }
          }
        }
        leaf mac-address {
          tailf:info "Virtual MAC address";
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }
        leaf name {
          tailf:info "Redundancy name string";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;name string";
          }
        }
        container preempt {
          tailf:info "Overthrow lower priority Active routers";
          tailf:cli-delete-when-empty;
          presence true;
          container delay {
            tailf:info "Wait before preempting";
            tailf:cli-compact-syntax;
            leaf minimum {
              tailf:info "Delay at least this long";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for minimum delay";
                range "0..3600";
              }
            }
            leaf reload {
              tailf:info "Delay after reload";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for reload delay";
                range "0..3600";
              }
            }
            leaf sync {
              tailf:info "Wait for IP redundancy client";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for sync delay";
                range "0..3600";
              }
            }
          }
        }
        leaf priority {
          tailf:info "Priority level";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority value";
          }
        }
        container redirect {
          tailf:info "Configure sending of ICMP Redirect messages with an HSRP "
            +"virtual IP address as the gateway IP address";
          container advertisement {
            tailf:info "Redirect advertisement messages";
            container authentication {
              tailf:info "Authentication";
              container md5 {
                tailf:info "Use MD5 authentication";
                leaf key-chain {
                  tailf:info "Set key chain";
                  type string {
                    tailf:info "WORD;;Name of key-chain";
                  }
                }
                container key-string {
                  tailf:info "Set key string";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf encrypt {
                    tailf:cli-drop-node-name;
                    type enumeration {
                      enum "0" {
                        tailf:info "Specifies an UNENCRYPTED key string will "
                          +"follow";
                      }
                      enum "7" {
                        tailf:info "Specifies a HIDDEN key string will follow";
                      }
                    }
                  }
                  leaf string {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;;Key string (64 chars max)";
                    }
                  }
                  leaf timeout {
                    tailf:info "Set timeout";
                    type uint16 {
                      tailf:info "<0-32767>;;Timeout until only accepting "
                        +"new key (seconds)";
                      range "0..32767";
                    }
                  }
                }
              }
            }
          }
          container timers {
            tailf:info "Adjust redirect timers";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf advertisement {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<10-180>;;Passive router advertisement interval in "
                  +"seconds";
                range "10..180";
              }
            }
            leaf holddown {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<30-3600>;;Passive router holddown interval in "
                  +"seconds";
                range "30..3600";
              }
            }
          }
          leaf unknown {
            tailf:info "Redirect to non-HSRP routers";
            type empty;
          }
        }
        container timers {
          tailf:info "Hello and hold timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          container hello-interval {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hello-interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-254>;;Hello interval in seconds";
                  range "1..254";
                }
              }
              leaf msec {
                tailf:info "Specify hello interval in milliseconds";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<15-999>;;Hello interval in milliseconds";
                  range "15..999";
                }
              }
            }
          }
          container hold-time {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hold-time-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Hold time in seconds";
                  range "1..255";
                }
              }
              leaf msec {
                tailf:info "Specify hold time in milliseconds";
                type uint16 {
                  tailf:info "<50-3000>;;Hello interval in milliseconds";
                  range "50..3000";
                }
              }
            }
          }
        }
        // interface * / standby * / track *
        list track {
          //FIXME: key 0 can be ignored (default)
          tailf:info "Priority tracking";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type union {
              type uint16 {
                tailf:info "<0-500>;;Tracked object number";
              }
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
          }
          choice options {
            case interface {
              leaf priority-decrement {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-255>;;Decrement value";
                }
              }
            }
            case group-number {
              leaf decrement {
                tailf:info "Priority decrement";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-255>;;Decrement value";
                }
              }
              leaf shutdown {
                tailf:info "Shutdown group";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";
      // interface * / storm-control action
      container action {
        tailf:info "Action to take for storm-control";
        leaf shutdown {
          tailf:info "Shutdown this interface if a storm occurs";
          tailf:cli-full-command;
          type empty;
        }
        leaf trap {
          tailf:info "Send SNMP trap if a storm occurs";
          tailf:cli-full-command;
          type empty;
        }
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          tailf:cli-full-command;
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "+
              "of bandwidth";
            range "0..100";
          }
        }
      }
      // interface * / storm-control broadcast
      container broadcast {
        tailf:info "Broadcast address storm control";
        // interface * / storm-control broadcast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "+
              "of bandwidth";
            range "0..100";
          }
        }
        uses storm-control-level-bps-pps-grouping;
        // interface * / storm-control broadcast include multicast
        container "include" {
          tailf:info "include other traffic types";
          leaf multicast {
            tailf:info "Suppress broadcast and multicast traffic";
            type empty;
          }
        }
      }

      // interface * / storm-control multicast
      container multicast {
        tailf:info "Multicast address storm control";
        // interface * / storm-control multicast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as "+
              "percentage of bandwidth";
            range "0..100";
          }
        }
        uses storm-control-level-bps-pps-grouping;
      }

      // interface * / storm-control unicast
      container unicast {
        tailf:info "Unicast address storm control";
        // interface * / storm-control unicast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as "+
              "percentage of bandwidth";
            range "0..100";
          }
        }
        uses storm-control-level-bps-pps-grouping;
      }
    }

    // interface * / wrr-queue
    container wrr-queue {
      tailf:info "Configure weighted round-robin xmt queues";

      // interface * / wrr-queue bandwidth
      container bandwidth {
        tailf:info "Configure WRR minimum bandwidth with weights or "
          +"percentages";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice bandwidth-choice {
          case a {
            leaf weight-1 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-2 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-3 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-4 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-5 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-6 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-7 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
          }
          case b {
            container percent {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf percent-1 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-2 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-3 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-4 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-5 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-6 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-7 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
            }
          }
        }
      }

      // interface * / wrr-queue dscp-map *
      list dscp-map {
        tailf:info "Configure dscp-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "queue threshold";
        leaf queue {
          type uint8 {
            tailf:info "<1-7>;;enter dscp-map queue id";
          }
        }
        leaf threshold {
          type uint8 {
            tailf:info "<1-4>;;enter dscp-map threshold id";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "value";
          leaf "value" {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }

      // interface * / wrr-queue cos-map *
      list cos-map {
        tailf:info "Configure cos-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "queue-id threshold-id";
        leaf queue-id {
          type uint8 {
            tailf:info "<1-3>;;enter cos-map queue id";
            range "1..3";
          }
        }
        leaf threshold-id {
          type uint8 {
            tailf:info "<1-8>;;enter cos-map threshhold id";
            range "1..8";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values "
              +"total)";
            range "0..7";
          }
        }
      }

      // interface * / wrr-queue queue-limit
      container queue-limit {
        tailf:info "Configure queue-limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf weight-a {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-b {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-c {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-d {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-e {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-f {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-g {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
      }

      // interface * / wrr-queue random-detect
      container random-detect {
        tailf:info "Configure random-detect";
        list max-threshold {
          tailf:info "Max threshold for WRED";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;enter queue id";
              range "1..3";
            }
          }
          uses queue-size-grouping;
        }
        list min-threshold {
          tailf:info "Min threshold for WRED";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;enter queue id";
              range "1..3";
            }
          }
          uses queue-size-grouping;
        }
      }

      // interface * / wrr-queue threshold *
      list threshold {
        tailf:info "Configure queue tail-drop thresholds";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;enter queue id";
            range "1..3";
          }
        }
        uses queue-size-grouping;
      }
    }

    // interface * / priority-queue
    container priority-queue {
      tailf:info "Configure priority scheduling";

      // interface * / priority-queue queue-limit
      leaf queue-limit {
        tailf:info "configure priority queue limit";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }

      // interface * / priority-queue dscp-map *
      list dscp-map {
        tailf:info "Configure dscp-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-1>;;enter priority queue id";
            range "1";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "value";
          leaf "value" {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }

      // interface * / priority-queue cos-map *
      container cos-map {
        tailf:info "Configure cos-map for a queue";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-1>;;enter cos-map queue id";
            range "1";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values "
              +"total)";
            range "0..7";
          }
        }
      }

      // interface * / priority-queue out
      leaf out {
        tailf:info "egress priority queue";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / rep
    container rep {
      tailf:info "Resilient Ethernet Protocol characteristics";

      container block {
        tailf:info "Block port & VLANs for VLAN Load-balancing";
        container port {
          tailf:info "Specify port for VLAN Load-balancing";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice port-choice {
            leaf neighbor-offset {
              tailf:cli-drop-node-name;
              type int16 {
                tailf:info "<-256 - 256>;;Neighbor offset";
                range "-256..256";
              }
            }
            leaf id {
              tailf:info "REP port ID";
              type string {
                tailf:info "WORD;;REP port ID (16 digit hexadecimal number)";
              }
            }
            leaf preferred {
              tailf:info "Preferred flag";
              type empty;
            }
          }
          leaf vlan {
            tailf:info "VLANs to block";
            type union {
              type string {
                tailf:info "WORD;;VLAN list (1-4094) ex: 1-65,72,300-320";
              }
              type enumeration {
                enum all {
                  tailf:info "All VLANs";
                }
              }
            }
          }
        }
      }
      container preempt {
        tailf:info "Preemption options";
        leaf delay {
          tailf:info "Delay timer in seconds";
          type uint16 {
            tailf:info "<15-300>;;number of seconds before automatic "
              +"preemption takes place";
            range "15..300";
          }
        }
      }
      container segment {
        tailf:info "REP segment ID";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-1024>;;Between 1 and 1024";
            range "1..1024";
          }
        }
        leaf edge {
          tailf:info "Edge Port";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf primary {
          tailf:info "Primary Edge Port";
          tailf:cli-optional-in-sequence;
          when "../edge" {
            tailf:dependency "../edge";
          }
          type empty;
        }
        leaf preferred {
          tailf:info "Preferred Alternate Port";
          type empty;
        }
      }
      container stcn {
        tailf:info "Segment Topology Change Notification";
        leaf segment {
          tailf:info "for REP segment";
          type string {
            tailf:info "WORD;;segment ID list (1-1024) ex: 1-3,6-9";
          }
        }
        leaf stp {
          tailf:info "for STP network";
          type empty;
        }
      }
    }

    // interface * / rcv-queue
    container rcv-queue {
      tailf:info "Configure receive queue(s)";
      list cos-map {
        tailf:info "Configure cos-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "queue-id threshold-id";
        leaf queue-id {
          type uint8 {
            tailf:info "<1-3>;;enter cos-map queue id";
            range "1..3";
          }
        }
        leaf threshold-id {
          type uint8 {
            tailf:info "<1-8>;;enter cos-map threshhold id";
            range "1..8";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values "
              +"total)";
            range "0..7";
          }
        }
      }
    }

    // interface * / udld
    container udld {
      tailf:info "Configure UDLD enabled or disabled and ignore global UDLD "
        +"setting";
      container port {
        tailf:info "Enable UDLD protocol on this interface despite global UDLD "
          +"setting";
        tailf:cli-delete-when-empty;
        presence true;
        choice port-choice {
          leaf aggressive {
            tailf:info "Enable UDLD protocol in aggressive mode on this "
              +"interface despite global UDLD setting";
            type empty;
          }
          leaf disable {
            tailf:info "Disable UDLD protocol on this interface despite global "
              +"UDLD setting";
            type empty;
          }
        }
      }
    }

    // interface * / peer
    container peer {
      tailf:info "Peer parameters for point to point interfaces";
      container "default" {
        tailf:info "Specify default parameters";
        container ip {
          tailf:info "Specify default IP parameters";
          // interface * / peer default ip address
          container address {
            tailf:info "Specify default IP address";
            choice address-choice {
              leaf dhcp {
                tailf:info "Use DHCP proxy client mechanism to allocate a peer "
                  +"IP address";
                type empty;
              }
              container dhcp-pool {
                tailf:info "Use local DHCP pools to allocate a peer IP address";
                presence true;
                leaf pools {
                  tailf:cli-drop-node-name;
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;List of one or more DHCP address pools";
                  }
                }
              }
              container pool {
                tailf:info "Use IP pool mechanism to allocate a peer IP "
                  +"address";
                presence true;
                leaf pools {
                  tailf:cli-drop-node-name;
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;List of one or more DHCP address pools";
                  }
                }
              }
            }
          }
        }
      }
    }

    // interface * / clns
    container clns {
      tailf:info "CLNS interface subcommands";

      // interface * / no clns route-cache
      leaf route-cache {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / dsu
    container dsu {
      // interface * / dsu bandwidth
      leaf bandwidth {
        tailf:cli-full-command;
        type uint32;
      }
    }

    // interface * / isdn
    container isdn {
      tailf:info "ISDN Interface configuration commands";
      // interface * / isdn switch-type
      leaf switch-type {
        tailf:info "Select the Interface ISDN switch type";
        tailf:cli-full-command;
        type string {
          pattern "primary.*";
        }
      }
      // interface * / isdn protocol-emulate
      leaf protocol-emulate {
        tailf:info "Protocol (L2/L3) emulation network/user side";
        tailf:cli-full-command;
        type enumeration {
          enum network {
            tailf:info "ISDN protocol emulation network side";
          }
          enum user {
            tailf:info "ISDN protocol emulation user side (default)";
          }
        }
      }
      // interface * / isdn incoming-voice
      container incoming-voice {
        tailf:info "Specify options for incoming calls.";
        choice incoming-voice-choice {
          leaf voice {
            tailf:info "Incoming voice calls will be handled as voice.";
            type empty;
          }
          container data {
            tailf:info "Incoming voice calls will be handled as data.";
            tailf:cli-delete-when-empty;
            presence true;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "56" {
                  tailf:info "56  B Channel Bandwidth of 56Kb/s";
                }
                enum "64" {
                  tailf:info "64  B Channel Bandwidth of 64Kb/s";
                }
              }
            }
          }
          container modem {
            tailf:info "Incoming voice calls will be handled as modems.";
            tailf:cli-delete-when-empty;
            presence true;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "56" {
                  tailf:info "56  B Channel Bandwidth of 56Kb/s  ";
                }
                enum "64" {
                  tailf:info "64  B Channel Bandwidth of 64Kb/s";
                }
              }
            }
          }
        }
      }
      // interface * / isdn supp-service
      container supp-service {
        tailf:info "Specify the subscribed supplementary service";
        container name {
          tailf:info "Specify the subscribed name service";
          container calling {
            tailf:info "calling name service";
            tailf:cli-delete-when-empty;
            presence true;
          }
        }
      }
    }

    // interface * / trunk-group
    leaf trunk-group {
      tailf:info "Configure interface to be in a trunk group";
      type string {
        tailf:info "WORD;;Trunk group label";
      }
      tailf:non-strict-leafref {
        path "/ios:trunk/group/name";
      }
    }

    // interface * / crypto
    container crypto {
      tailf:info "Encryption/Decryption commands";

      // interface * / crypto map
      container map {
        tailf:info "Assign a Crypto Map";
        container ipv4 {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "ipv6";
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/map/name";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            when "../redundancy";
            type empty;
          }
        }
        container ipv6 {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/map/name";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            when "../redundancy";
            type empty;
          }
        }
      }
    }

    // interface * / no routing dynamic
    container routing {
      tailf:info "Per-interface routing configuration";
      leaf dynamic {
        tailf:info "participates in routing protocols";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

  }
  // grouping interface-common-grouping


  // interface-tunnel-grouping
  grouping interface-tunnel-grouping {
    container tunnel {
      tailf:info "protocol-over-protocol tunneling";

      // interface * / tunnel source
      leaf source {
        tailf:info "source of tunnel packets";
        type string; // interface or address
      }

      // interface * / tunnel destination
      leaf destination {
        tailf:info "destination of tunnel";
        type host-v4v6-type;
      }

      // interface * / tunnel mode
      container mode {
        tailf:info "tunnel encapsulation method";
        choice mode-choice {
          // interface * / tunnel mode ipsec
          container ipsec {
            tailf:info "IPSec tunnel encapsulation";
            container ipv4 {
              tailf:info "over IPv4";
                tailf:cli-delete-when-empty;
                presence true;
            }
          }
          // interface * / tunnel mode mpls
          container mpls {
            container traffic-eng {
              tailf:cli-delete-when-empty;
              presence true;
              leaf gre-ip {
                type empty;
              }
            }
          }
        }
      }

      // interface * / tunnel path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Enable Path MTU Discovery on tunnel";
        presence true;
      }

      // interface * / tunnel protection
      container protection {
        tailf:info "Enable tunnel protection";
        container ipsec {
          tailf:info "Use ipsec to protect this tunnel interface";
          leaf profile {
            tailf:info "Determine the ipsec policy profile to use.";
            type string {
              tailf:info "WORD;;IPSec policy profile";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/ipsec/profile/name";
            }
          }
        }
      }

      // interface * / tunnel mpls
      container mpls {
        container traffic-eng {
          container affinity {
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf attributes {
              tailf:cli-drop-node-name;
              type string;
            }
            leaf mask {
              type string;
            }
          }
          container autoroute {
            leaf announce {
              tailf:cli-full-command;
              type empty;
            }
          }
          container priority {
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf setup-priority {
              tailf:cli-drop-node-name;
              type uint8 {
                range "0..7";
              }
            }
            leaf hold-priority {
              tailf:cli-drop-node-name;
              type uint8 {
                range "0..7";
              }
            }
          }
          leaf bandwidth {
            tailf:cli-full-command;
            type uint32 {
            }
          }
          list path-option {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint32;
            }
            choice path-option-choice {
              container dynamic {
                presence true;
              }
              container explicit {
                tailf:cli-compact-syntax;
                choice explicit-choice {
                  leaf name {
                    type string;
                  }
                  leaf identifier {
                    type uint32;
                  }
                }
              }
            }
            container lockdown {
              presence true;
            }
          }
          container fast-reroute {
            presence true;
          }
        }
      }

    }
  }


  // interface-ethernet-pre-grouping
  grouping interface-ethernet-pre-grouping {

    // interface * / port-type
    leaf port-type {
      tailf:info "Set port type";
      type enumeration {
        enum eni {
          tailf:info "Set port-type to ENI";
        }
        enum nni {
          tailf:info "Set port-type to NNI";
        }
        enum uni {
          tailf:info "Set port-type to UNI";
        }
      }
    }
  }

  // interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / media-type
    leaf media-type {
      tailf:info "Media type";
      tailf:cli-full-command;
      type enumeration {
        enum rj45 {
          tailf:info "Copper";
        }
        enum sfp {
          tailf:info "Fiber";
        }
        enum auto-select {
          tailf:info "Auto Select";
        }
      }
    }

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Specify delay for interface transitions";
      choice delay-choice {
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-60>;;Carrier Transitions delay seconds";
            range "0..60";
          }
        }
        leaf msec {
          tailf:info "delay specified in milliseconds";
          type uint16 {
            tailf:info "<0-1000>;;Carrier Transitions delay milliseconds";
            range "0..1000";
          }
        }
      }
    }

    // interface * / channel-group
    container channel-group {
      tailf:info "Add this interface to an Etherchannel group";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / channel-protocol
    leaf channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      type enumeration {
        enum lacp {
          tailf:info "Prepare interface for LACP protocol";
        }
        enum pagp {
          tailf:info "Prepare interface for PAgP protocol";
        }
      }
    }

    // interface * / ethernet
    container ethernet {
      tailf:info "Ethernet interface parameters";

      // interface * / ethernet oam
      container oam {
        tailf:info "To enable Ethernet Link OAM";
        presence true;
        leaf max-rate {
          type uint8 {
            tailf:info "Maximum number of OAM PDUs sent per second";
            range "1..10";
          }
        }
        leaf min-rate {
          type uint8 {
            tailf:info "Minimum transmission rate in seconds";
            range "1..10";
          }
        }
        leaf mode {
          type enumeration {
            enum "active" {
              tailf:info "Active OAM client mode";
            }
            enum "passive" {
              tailf:info "Passive OAM client mode";
            }
          }
        }
        leaf timeout {
          type uint8 {
            tailf:info "OAM client timeout in seconds";
            range "2..30";
          }
        }
      }

      // interface * / ethernet dot1ad
      container dot1ad {
        tailf:info "dot1ad port";
        choice dot1ad-choice {
          leaf nni {
            tailf:info "dot1ad nni port";
            type empty;
          }
          container uni {
            tailf:info "dot1ad uni";
            choice uni-choice {
              container c-port {
                tailf:info "dot1ad uni customer bridge port";
                tailf:cli-delete-when-empty;
                presence true;
                leaf isolate {
                  tailf:info "split horizon";
                  type empty;
                }
              }
              container s-port {
                tailf:info "dot1ad uni s bridge port";
                tailf:cli-delete-when-empty;
                presence true;
                leaf isolate {
                  tailf:info "split horizon";
                  type empty;
                }
              }
            }
          }
        }
      }

      // interface * / ethernet cfm mep domain ? mpid *
      container cfm {
        tailf:info "Ethernet CFM interface commands";
        container mep {
          tailf:info "Maintenance End Point";
          list mep-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key mpid;
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }
            leaf domain {
              tailf:info "maintenance domain";
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            // interface * / ethernet cfm mep domain ? mpid * service
            container service {
              tailf:info "Maintenance Association within Domain";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              choice service-choice {
                leaf short-ma-name {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;service instance id - short MA name";
                  }
                }
                leaf number {
                  tailf:info "Maintenance Association number value";
                  type uint16 {
                    tailf:info "<0-65535>;;Maintenance Association number";
                  }
                }
              }
            }
          }
        }
      }
    }

    // interface * / negotiation auto
    container negotiation {
      tailf:info "Select autonegotiation mode";
      leaf auto {
        tailf:info "Enable link autonegotiation";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // interface * / synchronous
    container synchronous {
      tailf:info "Synchronous";
      leaf mode {
        tailf:info "Mode";
        type empty;
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operation.";
      tailf:cli-no-value-on-delete;
      tailf:cli-diff-dependency "../media-type";
      type enumeration {
        enum auto {
          tailf:code-name "duplex_auto";
          tailf:info "Enable AUTO duplex configuration";
        }
        enum full {
          tailf:code-name "duplex_full";
          tailf:info "Force full duplex operation";
        }
        enum half {
          tailf:code-name "duplex_half";
          tailf:info "Force half-duplex operation";
        }
      }

    }

    // interface * / full-duplex
    // NOTE: results in "duplex full"
    leaf full-duplex {
      tailf:info "Configure full-duplex operational mode";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / speed
    leaf speed {
      tailf:info "Configure speed operation.";
      tailf:cli-diff-dependency "../media-type";
      type enumeration {
        enum "10" {
          tailf:info "Force 10 Mbps operation";
        }
        enum "100" {
          tailf:info "Force 100 Mbps operation";
        }
        enum "1000" {
          tailf:info "Force 1000 Mbps operation";
        }
        enum "auto" {
          tailf:info "Enable AUTO speed configuration";
        }
        enum "nonegotiate" {
        }
      }
    }

    // interface * / xconnect
    uses interface-xconnect-grouping;

    // interface * / pppoe
    container pppoe {
      tailf:info "pppoe interface subcommands";
      container enable {
        tailf:info "Enable pppoe";
        presence true;
        leaf group {
          tailf:info "attach a BBA group";
          type union {
            type string {
              tailf:info "WORD;;BBA Group name";
            }
            type enumeration {
              enum global {
                tailf:info "Attach global PPPoE group";
              }
            }
          }
        }
      }
      leaf max-sessions {
        tailf:info "Maximum PPPOE sessions";
        type uint16 {
          tailf:info "<1-4085>;;Maximum PPPOE sessions";
          range "1..4085";
        }
      }
    }

    // interface * / service instance * ethernet
    container service {
      tailf:info "Configure Ether Service";
      tailf:cli-diff-dependency "../switchport";
      list instance {
        tailf:info "Configure Ether Service Instance";
        tailf:cli-mode-name "config-if-srv";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../switchport";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;Service Instance Identifier";
            range "1..4294967295";
          }
        }
        leaf trunk {
          tailf:cli-optional-in-sequence;
          tailf:cli-prefix-key;
          type empty;
        }
        leaf ethernet {
          tailf:info "Configure an Ethernet Instance";
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf ethernet-evc-name {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;Attach an EVC to the service instance";
          }
          tailf:non-strict-leafref {
            path "/ios:ethernet/evc/name";
          }
        }

        // interface * / service instance * ethernet / description
        leaf "description" {
          tailf:cli-break-sequence-commands;
          tailf:info "Service instance specific description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this "+
              "service instance";
            length "0..240";
          }
        }

        // interface * / service instance * ethernet / evc-name
        leaf evc-name {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;Attach an EVC to the service instance";
            length "1..100";
          }
        }

        // interface * / service instance * ethernet / encapsulation
        container encapsulation {
          tailf:info "Configure ethernet frame match criteria";

          // interface * / service instance * ethernet / encapsulation dot1q
          container dot1q {
            tailf:info "IEEE 802.1Q Virtual LAN or S-VLAN";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf-list id {
              tailf:cli-drop-node-name;
              tailf:cli-replace-all;
              tailf:cli-range-list-syntax;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  // note: warning, may be replaced on device?
                  enum any {
                    tailf:info "For all VLANS [1-4094]";
                  }
                }
              }
            }
            // [second-dot1q]
            leaf second-dot1q {
              tailf:cli-break-sequence-commands;
              tailf:info "inner 802.1Q Virtual LAN or C-VLAN";
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "For all VLANS [1-4094]";
                  }
                }
              }
            }
            // [cos]
            leaf cos {
              tailf:info "cos Vlan";
              type uint8 {
                tailf:info "<0-7>;;cos values";
                range "0..7";
              }
            }
            // [etype]
            leaf etype {
              tailf:info "payload ethertype after Vlan Field";
              type enumeration {
                enum ipv4 {
                  tailf:info "IPv4";
                }
                enum ipv6 {
                  tailf:info "IPv6";
                }
                enum pppoe-all {
                  tailf:info "PPPoE ALL";
                }
                enum pppoe-discovery {
                  tailf:info "PPPoE Discovery Stage";
                }
                enum pppoe-session {
                  tailf:info "PPPoE Session Stage";
                }
              }
            }
          }

          // interface * / service instance * ethernet / encapsulation dot1ad
          container dot1ad {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf-list id {
              tailf:cli-drop-node-name;
              tailf:cli-replace-all;
              tailf:cli-range-list-syntax;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;VLAN id";
                  range "1..4094";
                }
              }
            }
          }

          // interface * / service instance * ethernet / encapsulation untagged
          container untagged {
            tailf:info "Untagged encapsulation";
            presence true;
          }

          // interface * / service instance * ethernet / encapsulation default
          container "default" {
            tailf:info "catch-all unconfigured encapsulation";
            presence true;
          }
        }

        // interface * / service instance * ethernet / rewrite
        container rewrite {
          tailf:info "Configure ethernet rewrite criteria";
          container ingress {
            tailf:info "Ingress Rewrite";
            // interface * / service instance * ethernet / rewrite ingress tag
            container tag {
              tailf:info "Configure Rewrite Tag";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice tag-choice {
                // .. rewrite ingress tag pop
                leaf pop {
                  tailf:info "Pop the tag";
                  type enumeration {
                    enum "1" {
                      tailf:info "Pop the outermost tag";
                    }
                    enum "2" {
                      tailf:info "Pop two outermost tags";
                    }
                  }
                }
                // .. rewrite ingress tag push
                case push {
                  leaf push {
                    tailf:info "Rewrite Operation of push";
                    type enumeration {
                      enum dot1ad {
                        tailf:info "Push dot1ad tag";
                      }
                      enum dot1q {
                        tailf:info "Push dot1q tag";
                      }
                    }
                  }
                  leaf vlan-id {
                    tailf:cli-drop-node-name;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                }
              }
              leaf mode {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum symmetric {
                    tailf:info "Tag egress packets as specified in "+
                      "encapsulation";
                  }
                }
              }
            }
          }
        }

        // interface * / service instance * ethernet / group
        leaf group {
          tailf:info "Join a service group";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65532>;;Service group ID number";
            range "1..65532";
          }
        }

        // interface * / service instance * ethernet / errdisable
        container errdisable {
          tailf:info "Configure error disable";
          container recovery {
            tailf:info "enable auto recovery";
            container cause {
              tailf:info "error disable cause";
              leaf mac-security {
                tailf:info "mac-security violation";
                type uint32 {
                  tailf:info "<30-86400>;;timer interval(sec)";
                  range "30..86400";
                }
              }
            }
          }
        }

        // interface * / service instance * ethernet / snmp
        container snmp {
          tailf:info "Modify SNMP service instance parameters";
          container trap {
            tailf:info "Allow a specific SNMP trap";
            leaf link-status {
              tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
              type empty;
            }
          }
          container ifindex {
            tailf:info "Persist ifindex for the service instance";
            leaf persist {
              tailf:info "Enable/Disable ifIndex persistence";
              type empty;
            }
          }
        }

        // interface * / service instance * ethernet / shutdown
        leaf shutdown {
          tailf:info "Take the Service Instance out of Service";
          type empty;
        }

        // interface * / service instance * ethernet / bridge-domain
        container bridge-domain {
          tailf:info "Bridge-domain";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          // bridge-domain from-encapsulation
          leaf from-encapsulation {
            tailf:info "Derive bridge domains from encapsulation vlan list,";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          leaf bridge-id {
            tailf:cli-drop-node-name;
            //ME3X00 ONLY: tailf:callpoint bridge-domain-setelem { tailf:set-hook node; }
            type uint16 {
              tailf:info "<1-16384>;;Bridge-domain number";
            }
          }
          container split-horizon {
            tailf:info "Configure this port as a member of a split "+
              "horizon group";
            tailf:cli-flatten-container;
            leaf group {
              tailf:info "Split-horizon group";
              type uint8 {
                tailf:info "<0-2>;;Split-horizon group number";
                range "0..2";
              }
            }
          }
        }

        // interface * / service instance * ethernet / mac
        container mac {
          tailf:info "Commands for MAC Address-based features";
          // interface * / service instance * ethernet / mac security
          container security {
            tailf:info "MAC Security commands";
            tailf:cli-display-separated;
            tailf:cli-delete-when-empty;
            presence true;
            // interface * / service instance * ethernet / mac security address *
            list address {
              tailf:info "MAC Address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "operation mac-address";
              leaf operation {
                type enumeration {
                  enum deny {
                    tailf:info "Specify an address that must not be learnt";
                  }
                  enum permit {
                    tailf:info "Specify an address to statically configure "+
                      "in the MAC table";
                  }
                }
              }
              leaf mac-address {
                type string {
                  tailf:info "H.H.H;;Specify the 48-bit MAC Address to "+
                    "deny/permit";
                }
              }
            }
            // interface * / service instance * ethernet / mac security maximum
            container maximum {
              tailf:info "Configure an upper bound";
              leaf addresses {
                tailf:info "Maximum addresses that can be learnt on "+
                  "this service instance";
                type uint16 {
                  tailf:info "<1-1000>;;Address count";
                  range "1..1000";
                }
              }
            }
            // interface * / service instance * ethernet / mac security violation
            leaf violation {
              tailf:info "Configure the response when a MAC security "+
                "policy is violated";
              tailf:cli-full-command;
              type enumeration {
                enum protect {
                  tailf:info "Protect mode - don't report violations, "+
                    "drop violating frames";
                }
                enum restrict {
                  tailf:info "Restrict mode - report violations, "+
                    "drop violating frames";
                }
              }
            }
          }
          // interface * / service instance * ethernet / mac static
          container static {
            tailf:info "static MAC address";
            // interface * / service instance * ethernet / mac static address *
            list address {
              tailf:info "MAC Address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key mac-addr;
              leaf mac-addr {
                type string {
                  tailf:info "H.H.H;;Specify the 48-bit Static MAC Address";
                }
              }
            }
          }
          // interface * / service instance * ethernet / mac access-group *
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key direction;
            leaf direction {
              type enumeration {
                enum in {
                  tailf:info "Apply to Ingress";
                }
                enum out {
                  tailf:info "Apply to Egress";
                }
              }
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;ACL name";
              }
            }
          }
        }

        // interface * / service instance * ethernet / l2protocol
        container l2protocol {
          tailf:info "Configure l2 control protocol processing";
          container peer {
            tailf:info "peer L2 control protocol packets as data";
            presence true;
            leaf-list protocol {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type enumeration {
                enum cdp {
                  tailf:info "Cisco Discovery Protocol";
                }
                enum dtp {
                  tailf:info "Dynamic Trunking Protocol";
                }
                enum lacp {
                  tailf:info "LACP Protocol";
                }
                enum lldp {
                  tailf:info "Link Layer Discovery Protocol";
                }
                enum pagp {
                  tailf:info "Port Aggregation Protocol";
                }
                enum stp {
                  tailf:info "Spanning Tree Protocol";
                }
                enum udld {
                  tailf:info "UDLD Protocol";
                }
                enum vtp {
                  tailf:info "Vlan Trunking Protocol";
                }
              }
            }
          }
          container forward {
            tailf:info "forward L2 control protocol packets as data";
            presence true;
            leaf-list protocol {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type enumeration {
                enum cdp {
                  tailf:info "Cisco Discovery Protocol";
                }
                enum dtp {
                  tailf:info "Dynamic Trunking Protocol";
                }
                enum lacp {
                  tailf:info "LACP Protocol";
                }
                enum lldp {
                  tailf:info "Link Layer Discovery Protocol";
                }
                enum pagp {
                  tailf:info "Port Aggregation Protocol";
                }
                enum stp {
                  tailf:info "Spanning Tree Protocol";
                }
                enum udld {
                  tailf:info "UDLD Protocol";
                }
                enum vtp {
                  tailf:info "Vlan Trunking Protocol";
                }
              }
            }
          }
          container tunnel {
            tailf:info "tunnel L2 control protocol packets as data";
            presence true;
          }
        }

        // interface * / service instance * ethernet / service-policy
        container service-policy {
          tailf:info "Attach a policy-map to an EFP";
          tailf:cli-diff-dependency "/ios:policy-map";
          list "input" {
            tailf:info "service policy input";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;input Policy-map name";
              }
              tailf:non-strict-leafref {
                path "/ios:policy-map/name";
              }
            }
          }
          list "output" {
            tailf:info "service policy output";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;output Policy-map name";
              }
              tailf:non-strict-leafref {
                path "/ios:policy-map/name";
              }
            }
          }
        }

        // interface * / service instance * ethernet / xconnect
        uses interface-xconnect-grouping;

        // interface * / service instance * ethernet / cfm
        container cfm {
          tailf:info "Ethernet CFM EFP subcommands";

          // interface * / service instance * ethernet / cfm mep
          container mep {
            tailf:info "Maintenance End Point";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-if-srv-ecfm-mep";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf domain {
              tailf:info "Configure a domain for this mep";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }

            // interface * / service instance * ethernet / cfm mep / continuity-check
            container continuity-check {
              tailf:info "Enable Continuity Check for this local MEP";
              tailf:cli-break-sequence-commands;
              container static {
                tailf:info "Verify MEP in received CCM is valid";
                leaf rmep {
                  tailf:info "MEP defined using rmep mpid";
                  type empty;
                }
              }
            }

            // interface * / service instance * ethernet / cfm mep / rmep mpid
            container rmep {
              tailf:info "Static Remote MEP associated with this DOWN MEP";
              leaf mpid {
                tailf:info "Maintenance End Point Identifier";
                type uint16 {
                  tailf:info "<1-8191>;;Identifier value";
                  range "1..8191";
                }
              }
            }

            // interface * / service instance * ethernet / cfm mep / cos
            leaf cos {
              tailf:info "Specify Class of Service sent in CFM mssages for "+
                "EFP MEP";
              type uint8 {
                tailf:info "<0-7>;;CoS value";
                range "0..7";
              }
            }
          }
        }

        // interface * / service instance * ethernet / ethernet
        container ethernet-if-srv {
          tailf:cli-drop-node-name;
          container ethernet {
            tailf:info "ethernet";

            // interface * / service instance * ethernet / ethernet lmi
            container lmi {
              tailf:info "Configure ether lmi parameters";
              container ce-vlan {
                tailf:info "Configure ether lmi customer vlans";
                leaf-list map {
                  tailf:info "Configure ether lmi ce-vlan/evc map";
                  tailf:cli-replace-all;
                  tailf:cli-range-list-syntax;
                  type union {
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                    type enumeration {
                      enum "default" {
                        tailf:info "Default EFP";
                      }
                      enum untagged {
                        tailf:info "Untagged frames";
                      }
                    }
                  }
                }
              }
            }

            // interface * / service instance * ethernet / ethernet loopback
            container loopback {
              tailf:info "Ethernet Dataplane Loopback";
              container permit {
                tailf:info "Allow data plane loopback to be activated";
                leaf external {
                  tailf:info "Allow to loopback the traffic from the wire";
                  type empty;
                }
                leaf internal {
                  tailf:info "Allow to loopback the traffic from the relay";
                  type empty;
                }
              }
            }
          }
        }
      }
    }

  } // interface-ethernet-grouping


  // interface-zone-member-grouping
  grouping interface-zone-member-grouping {
    // interface * / zone-member
    container zone-member {
      tailf:info "Apply zone name";
      leaf security {
        tailf:info "Security zone";
        type string;
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
      }
    }
  }   // interface-zone-member-grouping


  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {

    // interface * / ppp
    container ppp {
      tailf:info "Point-to-Point Protocol";
      // interface * / ppp accounting
      leaf accounting {
        tailf:info "Set PPP network accounting method";
        type union {
          type string {
            tailf:info "WORD;;Named accounting list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default accounting list.";
            }
          }
        }
      }
      // interface * / ppp authentication
      container authentication {
        tailf:info "Set PPP link authentication method";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf method {
          tailf:cli-drop-node-name;
          type enumeration {
            enum chap {
              tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
            }
            enum eap {
              tailf:info "Extensible Authentication Protocol (EAP)";
            }
            enum ms-chap {
              tailf:info "Microsoft Challenge Handshake Authentication "
                +"Protocol (MS-CHAP)";
            }
            enum ms-chap-v2 {
              tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
            }
            enum pap {
              tailf:info "Password Authentication Protocol (PAP)";
            }
          }
        }
        leaf list-name {
          tailf:cli-break-sequence-commands;
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Use an authentication list with this name";
          }
          tailf:cli-disallow-value "(callback)|(callin)|(callout)|(default)|"
            +"(eap)|(ms-chap)|(ms-chap-v2)|(one-time)|(optional)|(pap)";
        }
        leaf chap {
          when "not(../method = 'chap')" {
            tailf:dependency "../method";
          }
          tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
          type empty;
        }
        leaf callback {
          tailf:info "Authenticate remote on callback only";
          type empty;
        }
        leaf callin {
          tailf:info "Authenticate remote on incoming call only";
          type empty;
        }
        leaf callout {
          tailf:info "Authenticate remote on outgoing call only";
          type empty;
        }
        leaf "default" {
          tailf:info "Use the default authentication list";
          type empty;
        }
        leaf eap {
          when "not(../method = 'eap')" {
            tailf:dependency "../method";
          }
          tailf:info "Extensible Authentication Protocol (EAP)";
          type empty;
        }
        leaf ms-chap {
          when "not(../method = 'ms-chap')" {
            tailf:dependency "../method";
          }
          tailf:info "Microsoft Challenge Handshake Authentication Protocol ("
            +"MS-CHAP)";
          type empty;
        }
        leaf ms-chap-v2 {
          when "not(../method = 'ms-chap-v2')" {
            tailf:dependency "../method";
          }
          tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
          type empty;
        }
        leaf one-time {
          tailf:info "Allow use of username*OTP for one-time passwords";
          type empty;
        }
        leaf optional {
          tailf:info "Allow peer to refuse to authenticate";
          type empty;
        }
        leaf pap {
          when "not(../method = 'pap')" {
            tailf:dependency "../method";
          }
          tailf:info "Password Authentication Protocol (PAP)";
          type empty;
        }
      }
      // interface * / ppp authorization
      leaf authorization {
        tailf:info "Set PPP network authorization method";
        type union {
          type string {
            tailf:info "WORD;;Named authorization list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default authorization list.";
            }
          }
        }
      }
      // interface * / ppp ipcp
      container ipcp {
        tailf:info "Set IPCP negotiation options";
        container dns {
          tailf:info "Specify DNS negotiation options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf primary {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Primary DNS IP address";
            }
          }
        }
      }
      // interface * / ppp multilink
      container multilink {
        tailf:info "Make interface multilink capable";
        tailf:cli-display-separated;
        presence true;
        // interface * / ppp multilink interleave
        leaf interleave {
          tailf:info "Allow interleaving of small packets with fragments";
          type empty;
        }
        // interface * / ppp multilink links
        container links {
          tailf:info "Specify the limits on the number of links in a bundle";
          container minimum {
            tailf:info "Minimum number of links desired in the bundle";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf minimum-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Specify minimum desired number of "+
                  "links in a bundle";
              }
            }
            leaf mandatory {
              tailf:info "Disable network layer until minimum number of "+
                "links is reach";
              type empty;
            }
          }
        }
        // interface * / ppp multilink group
        leaf group {
          tailf:info "Put interface in a multilink bundle";
          type uint32 {
            tailf:info "<1-2147483647>;;Multilink group number";
            range "1..2147483647";
          }
        }
        // interface * / ppp multilink fragment
        container fragment {
          tailf:info "Specify fragmentation parameters";
          leaf disable {
            tailf:info "Suppress multilink fragmentation when possible";
            tailf:cli-full-command;
            type empty;
          }
          container delay {
            tailf:info "Specify the maximum delay for each fragment";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-1000>;;Delay in milliseconds";
                range "0..1000";
              }
            }
            leaf additional-delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-999>;;Additional delay in microseconds";
                range "1..999";
              }
            }
          }
        }
        // interface * / ppp multilink queue depth
        container queue {
          tailf:info "Specify link queuing parameters";
          container depth {
            tailf:info "Specify maximum depth for link transmit queues";
            leaf fifo {
              tailf:info "Set max depth for link queues when bundle "+
                "has FIFO queuing";
              type uint8 {
                tailf:info "<2-255>;;Max queue depth for link";
                range "2..255";
              }
            }
            leaf qos {
              tailf:info "Set max depth for link queues when bundle has "+
                "non-FIFO queuing";
              type uint8 {
                tailf:info "<2-255>;;Max queue depth for link";
                range "2..255";
              }
            }
          }
        }
      }
    }

    // interface * / dialer
    container dialer {
      tailf:info "Dial-on-demand routing (DDR) commands";

      // interface * / dialer in-band
      container in-band {
        tailf:info "Set v.25bis dialing for interface";
        tailf:cli-delete-when-empty;
        presence true;
        leaf parity {
          tailf:cli-drop-node-name;
          type enumeration {
            enum no-parity {
              tailf:info "No parity";
            }
            enum odd-parity {
              tailf:info "Odd parity";
            }
          }
        }
      }

      // interface * / dialer idle-timeout
      container idle-timeout {
        tailf:info "Specify idle timeout before disconnecting line";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483>;;Idle timeout before disconnecting a call";
          }
        }
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum either {
              tailf:info "Reset idle timer based on both inbound and outbound "+
                "traffic";
            }
            enum inbound {
              tailf:info "Reset idle timer based on inbound traffic only";
            }
          }
        }
      }

      // interface * / dialer enable-timeout
      leaf enable-timeout {
        tailf:info "Set length of time an interface stays down before it is "+
          "available for dialing";
        type uint32 {
          tailf:info "<1-2147483>;;Enable timeout in seconds";
          range "1..2147483";
        }
      }

      // interface * / dialer string
      leaf "string" {
        tailf:info "Specify telephone number to be passed to DCE device";
        type string {
          tailf:info "WORD;;Dialer string (quote strings containing #)";
        }
      }

      // interface * / dialer watch-group
      leaf watch-group {
        tailf:info "Assign interface to dialer-watch-list";
        type uint16 {
          tailf:info "<1-255>;;Dialer watch group number";
          range "1..255";
        }
        tailf:non-strict-leafref {
          path "/ios:dialer/watch-list/id";
        }
      }
    }

    // interface * / physical-layer
    leaf physical-layer {
      tailf:info "Configure sync or async physical layer on serial interface";
      type enumeration {
        enum async {
          tailf:info "Configure asynchronous physical layer on serial "+
            "interface";
        }
        enum sync {
          tailf:info "Configure synchronous physical layer on serial "+
            "interface";
        }
      }
    }

    // interface * / async
    container async {
      tailf:info "Async interface parameters";
      container mode {
        tailf:info "Specify line mode (interactive or dedicated "+
          "interface use)";
        leaf dedicated {
          tailf:info "Line is dedicated as an async interface";
          type empty;
        }
        leaf interactive {
          tailf:info "Line may be switched between interactive use and "+
            "async interface";
          type empty;
        }
      }
    }

    // interface * / pulse-time
    container pulse-time {
      tailf:info "Force DTR low during resets";
      choice pulse-time-choice {
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-60>;;DTR low time in seconds";
            range "0..60";
          }
        }
        leaf msec {
          tailf:info "millisecond (resolution)";
          type uint16 {
            tailf:info "<1-59999>;;DTR low time in milliseconds";
            range "1..59999";
          }
        }
      }
    }

  } // interface-pointtopoint-grouping


  // crypto pki token grouping
  grouping crypto-pki-token-grouping {
    // max-retries  maximum number of consecutive login failures permitted
    container removal {
      tailf:info "actions to take after token removal";
      leaf timeout {
        tailf:info "seconds after token removal at which keys "
          +"from the token are cleared";
        type uint16 {
          tailf:info "<0-480>;;Token key timeout in seconds";
          range "0..480";
        }
      }
    }
    // secondary    token-specific configuration files
    // user-pin     PIN to access token
  }


  // router bgp * /
  grouping router-bgp-max-path-grouping {

    // router bgp * / maximum-paths
    container paths {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-paths {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-16>;;Number of paths";
          range "1..16";
        }
        default "1";
      }
      leaf "import" {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }
  }

  // router-bgp-redistribute-grouping
  grouping router-bgp-redistribute-grouping {
    leaf metric {
      tailf:cli-break-sequence-commands;
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // route-map-metric-grouping
  grouping route-map-metric-grouping {
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
  }

  // redistribute-isis-grouping
  grouping redistribute-isis-grouping {
    choice osi-ip-choice {
      leaf ip {
        tailf:info "Redistribution of IP dynamic routes";
        type empty;
      }
      leaf clns {
        tailf:info "Redistribution of OSI dynamic routes";
        type empty;
      }
    }
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
      }
    }
    uses router-bgp-redistribute-grouping;
  }


  // router bgp *
  grouping router-bgp-grouping {

    // router bgp * / bgp
    container bgp-top {
      tailf:cli-drop-node-name;
      container bgp {
        // router bgp * / bgp bestpath as-path multipath-relax
        container bestpath {
          tailf:info "Change the default bestpath selection";
          container as-path {
            leaf multipath-relax {
              type empty;
            }
          }
        }
      }
    }

    // router bgp * / timers bgp
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:info "BGP timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Holdtime";
            range "0..65535";
          }
        }
        leaf min-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Minimum hold time from neighbor";
            range "0..65535";
          }
        }
      }
    }
  }


  // router bgp * / neighbor *
  // router bgp * / peer-policy * /
  grouping router-bgp-peer-policy-grouping {

    // router bgp * / neighbor * advertisement-interval
    leaf advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;time in seconds";
        range "0..600";
      }
    }

    // router bgp * / neighbor * send-community
    container send-community {
      tailf:info "Send Community attribute to this neighbor";
      tailf:cli-delete-when-empty;
      presence true;
      leaf send-community-where {
        tailf:cli-drop-node-name;
        type enumeration {
          enum both {
            tailf:info "Send Standard and Extended Community "
              +"attributes";
          }
          enum extended {
            tailf:info "Send Extended Community attribute";
          }
          enum standard {
            tailf:code-name "send_standard";
            tailf:info "Send Standard Community attribute";
          }
        }
      }
    }

    // router bgp * / neighbor * maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes accepted from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf max-prefix-no {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-2147483647>;;maximum no. of prefix limit";
          range "1..2147483647";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to "
            +"generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:cli-full-command;
        tailf:info "Restart bgp connection after limit is exceeded";
        type uint16 {
          tailf:info "<1-65535>;;Restart interval in minutes";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:cli-full-command;
        tailf:info "Only give warning message when limit "
          +"is exceeded";
        type empty;
      }
    }

    // router bgp * / neighbor * allowas-in
    container allowas-in {
      tailf:info "Accept as-path with my AS present in it";
      tailf:cli-delete-when-empty;
      presence "accept as-paths";
      leaf as-number {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurances of AS number";
          range "1..10";
        }
      }
    }

    // router bgp * / neighbor * as-override
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        type empty;
      }
    }

  }

  // router bgp * / neighbor *
  // router bgp * / peer-session * /
  grouping router-bgp-peer-session-grouping {

    // router bgp * / neighbor * remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      tailf:cli-delete-container-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "AS of remote neighbor";
      }
    }

    // router bgp * / neighbor * password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf enctype {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Encryption type (0 to disable "
            +"encryption, 7 for proprietary)";
          range "0..7";
        }
        //default "0";
      }
      leaf text {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|1|2|3|4|5|6|7";
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }

    // router bgp * / neighbor * ttl-security hops
    container ttl-security {
      tailf:info "BGP ttl security check";
      leaf hops {
        tailf:info "IP hops";
        type uint8 {
          tailf:info "<1-254>;;maximum number of hops";
          range "1..254";
        }
      }
    }

    // router bgp * / neighbor * timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;Holdtime";
        }
      }
      leaf minimum-neighbor-hold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Minimum hold time from neighbor";
          range "0..65535";
        }
      }
    }

    // router bgp * / neighbor * fall-over
    container fall-over {
      tailf:info "session fall on peer route lost";
      presence true;
      // router bgp * / neighbor * fall-over bfd
      leaf bfd {
        tailf:info "Use BFD to detect failure";
        tailf:cli-full-command;
        type empty;
      }
      // router bgp * / neighbor * fall-over route-map
      leaf route-map {
        tailf:info "Route map for peer route";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }
  }

  // router bgp * / neighbor *
  grouping router-bgp-neighbor-grouping {

    // router bgp * / neighbor * peer-group
    container peer-group {
      tailf:info "Member of the peer-group";
      tailf:cli-delete-when-empty;
      presence true;
      leaf peer-group-name {
        tailf:info "WORD;;peer-group name";
        tailf:cli-drop-node-name;
        tailf:cli-delete-container-on-delete;
        tailf:cli-full-command;
        type string;
      }
    }

    // router bgp * / neighbor * local-as
    container local-as {
      tailf:info "Specify a local-as number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-delete-when-empty;
      presence "Specify a local-as number";
      leaf as-no {
        tailf:cli-drop-node-name;
        type uint16 {
          range "1..65535";
          tailf:info "<1-65535>;;AS number used as local AS";
        }
      }
      leaf no-prepend {
        tailf:info "Do not prepend local-as to updates from ebgp peers";
        type empty;
      }
      leaf replace-as {
        tailf:info "Replace real AS with local AS in the EBGP updates";
        type empty;
      }
      leaf dual-as {
        tailf:info "Accept either real AS or local AS from the ebgp peer";
        type empty;
      }
    }

    // router bgp * / neighbor * remote-as
    // router bgp * / neighbor * password
    // router bgp * / neighbor * ttl-security hops
    // router bgp * / neighbor * timers
    // router bgp * / neighbor * fall-over
    uses router-bgp-peer-session-grouping;

    // router bgp * / neighbor * activate
    leaf activate {
      tailf:info "Enable the Address Family for this Neighbor";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * advertisement-interval
    // router bgp * / neighbor * maximum-prefix
    // router bgp * / neighbor * send-community
    // router bgp * / neighbor * allowas-in
    // router bgp * / neighbor * as-override
    uses router-bgp-peer-policy-grouping;

    // router bgp * / neighbor * soo
    leaf soo {
      tailf:info "Site-of-Origin extended community";
      tailf:cli-full-command;
      type string {
        tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
      }
    }

    // router bgp * / neighbor * capability
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf-list prefix-list {
          tailf:cli-flat-list-syntax;
          tailf:info "Advertise prefixlist ORF capability to "
            +"this neighbor";
          max-elements 1;
          type enumeration {
            enum both {
              tailf:info "Capability to SEND and RECEIVE the "
                +"ORF to/from this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from "
                +"this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this "
                +"neighbor";
            }
          }
        }
      }
    }

    // router bgp * / neighbor * default-originate
    container default-originate {
      tailf:info "Originate default route to this neighbour";
      tailf:cli-delete-when-empty;
      presence "enable originate default route to this neighbour";
      leaf route-map {
        tailf:info "Route-map to specify criteria to originate default";
        type string {
          tailf:info "WORD;;route-map name";
        }
      }
    }

    // router bgp * / neighbor * description
    leaf "description" {
      tailf:info "Neighbor specific description";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this "
          +"neighbor";
      }
    }

    // router bgp * / neighbor * disable-connected-check
    leaf disable-connected-check {
      tailf:info "One-hop away EBGP peer using loopback address";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * distribute-list *
    uses router-distribute-list-grouping;

    // router bgp * / neighbor * dmzlink-bw
    leaf dmzlink-bw {
      tailf:info "Propagate the DMZ link bandwidth";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * ebgp-multihop
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected "
        +"networks";
      tailf:cli-delete-when-empty;
      presence "Allow EBGP neighbors not on directly connected "
        +"networks";
      leaf max-hop {
        tailf:cli-drop-node-name;
        type uint8 {
          range "1..255";
          tailf:info "<1-255>;;maximum hop count";
        }
      }
    }

    // router bgp * / neighbor * filter-list *
    list filter-list {
      tailf:info "Establish BGP filters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key inout;
      leaf inout {
        type enumeration {
          enum in {
            tailf:code-name "filter_in";
            tailf:info "Filter incoming routes";
          }
          enum out {
            tailf:code-name "filter_out";
            tailf:info "Filter outgoing routes";
          }
        }
      }
      leaf as-path-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type uint16 {
          range "1..500";
          tailf:info "<1-500>;;AS path access list";
        }
        mandatory true;
      }
    }

    // router bgp * / neighbor * inherit
    container inherit {
      tailf:info "Inherit a template";
      leaf peer-policy {
        tailf:info "Inherit a peer-policy template";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Template name";
        }
      }
      leaf peer-session {
        tailf:info "Inherit a peer-session template";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // router bgp * / neighbor * next-hop-self
    leaf next-hop-self {
      tailf:cli-full-command;
      tailf:info "Disable the next hop calculation for this neighbor";
      type empty;
    }

    // router bgp * / neighbor * next-hop-self ?
    container next-hop-self-arg {
      tailf:cli-drop-node-name;
      leaf next-hop-self {
        type string;
      }
    }

    // router bgp * / neighbor * next-hop-unchanged
    leaf next-hop-unchanged {
      tailf:cli-full-command;
      tailf:info "Propagate the iBGP paths's next hop unchanged "
        +"for this neighbor";
      type empty;
    }

    // router bgp * / neighbor * prefix-list *
    list prefix-list {
      tailf:info "Filter updates to/from this neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming updates";
          }
          enum out {
            tailf:info "Filter outgoing updates";
          }
        }
      }
      leaf prefix-list-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of a prefix list";
        }
        mandatory true;
      }
    }

    // router bgp * / neighbor * remove-private-as
    leaf remove-private-as {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * route-map *
    list route-map {
      tailf:info "Apply route map to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply map to incoming routes";
          }
          enum out {
            tailf:info "Apply map to outbound routes";
          }
        }
      }
      leaf route-map-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of route map";
        }
        mandatory true;
      }
    }

    // router bgp * / neighbor * route-reflector-client
    leaf route-reflector-client {
      tailf:cli-full-command;
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }

    // router bgp * / neighbor * send-label
    container send-label {
      tailf:info "Send NLRI + MPLS Label to this peer";
      tailf:cli-delete-when-empty;
      presence true;
      leaf explicit-null {
        tailf:info "Advertise Explicit Null label in place of Implicit Null";
        type empty;
      }
    }

    // router bgp * / neighbor * shutdown
    leaf shutdown {
      tailf:cli-full-command;
      tailf:info "Administratively shut down this neighbor";
      type empty;
    }

    // router bgp * / neighbor * soft-reconfiguration
    leaf soft-reconfiguration {
      tailf:cli-full-command;
      tailf:info "Per neighbor soft reconfiguration";
      type enumeration {
        enum inbound {
          tailf:info "Allow inbound soft reconfiguration for "
            +"this neighbor";
        }
      }
    }

    // router bgp * / neighbor * translate-update
    container translate-update {
      tailf:info "Translate Update to MBGP format";
      container ipv4 {
        tailf:info "Address Family";
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence "Address Family modifier";
          leaf unicast {
            tailf:info "Address Family modifier";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * transport
    container transport {
      tailf:info "Transport options";
      leaf connection-mode {
        tailf:info "Specify passive or active connection";
        type enumeration {
          enum active {
            tailf:info "Actively establish the TCP session";
          }
          enum passive {
            tailf:info "Passively establish the TCP session";
          }
        }
      }
    }

    // router bgp * / neighbor * unsuppress-map
    leaf unsuppress-map {
      tailf:info "Route-map to selectively unsuppress suppressed "
        +"routes";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of route map";
      }
    }

    // router bgp * / neighbor * update-source
    container update-source {
      tailf:info "Source of routing updates";
      uses interface-name-grouping;
    }

    // router bgp * / neighbor * version
    leaf version {
      tailf:cli-full-command;
      tailf:info "Set the BGP version to match a neighbor";
      type uint16 {
        range "4";
        tailf:info "<4-4>;;Neighbor's BGP version";
      }
    }

    // router bgp * / neighbor * version
    leaf weight {
      tailf:info "Set default weight for routes from this neighbor";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-65535>;;default weight";
        range "0..65535";
      }
    }

    // router bgp * / neighbor * ha-mode
    container ha-mode {
      tailf:info "high availability mode";
      container graceful-restart {
        tailf:info "graceful-restart for this peer";
        presence true;
        leaf disable {
          tailf:info "disable graceful-restart";
          type empty;
        }
      }
      container sso {
        tailf:info "stateful-switchover support for this peer";
        presence "true";
        leaf disable {
          tailf:info "disable stateful-switchover";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * suppress-signaling-protocol
    container suppress-signaling-protocol {
      tailf:info "suppress VPLS signaling protocol";
      leaf ldp {
        tailf:info "suppress ldp signaling, enable bgp signaling";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * prefix-length-size
    leaf prefix-length-size {
      tailf:info "Packet Level storage size for Prefixes";
      type uint8 {
        tailf:info "<1-2>;;Storage size in bytes";
        range "1..2";
      }
    }
  }

  // router bgp *
  // router bgp * / address-family ipv4
  // router bgp * / address-family ipv6
  // router bgp * / address-family vpnv4
  // router bgp * / address-family vpnv6
  // router bgp * / address-family nsap
  // router bgp * / address-family rtfilter
  // router bgp * / address-family ipv4 vrf *
  // router bgp * / address-family ipv6 vrf *
  grouping router-bgp-af-grouping {

    // router bgp * / aggregate-address
    container aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate address";
        }
      }
      leaf mask {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate mask";
        }
      }
      leaf advertise-map {
        tailf:cli-break-sequence-commands;
        tailf:info "Set condition to advertise attribute";
        type string {
          tailf:info "WORD;;Route map to control attribute "
          +"advertisement";
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf attribute-map {
        type string {
          tailf:info "WORD;;Route map for parameter control";
        }
      }
      leaf as-override {
        tailf:info "Override matching AS-number while sending update";
        type empty;
      }
      leaf route-map {
        type string {
          tailf:info "WORD;;Route map for parameter control";
        }
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      leaf suppress-map {
        tailf:info "Conditionally filter more specific routes from "
        +"updates";
        type string {
          tailf:info "WORD;;Route map for suppression";
        }
      }
    }

    // router bgp * / bgp
    container bgp {
      tailf:info "BGP specific commands";

      // router bgp * / bgp router-id
      leaf router-id {
        tailf:cli-full-command;
        tailf:info "Override configured router identifier (peers will "
        +"reset)";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp * / bgp always-compare-med
      leaf always-compare-med {
        tailf:info "Allow comparing MED from different neighbors";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp bestpath
      container bestpath {
        tailf:info "Change the default bestpath selection";
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }
        container cost-community {
          tailf:info "cost community";
          leaf ignore {
            tailf:info "Ignore cost communities in bestpath selection";
            type empty;
          }
        }
        container med {
          tailf:info "MED attribute";
          choice med-choice {
            container confed {
              tailf:info "Compare MED among confederation paths";
              presence "Compare MED among confederation paths";
              leaf missing-at-worst {
                tailf:info "Treat missing MED as the least "
                +"preferred one";
                type empty;
              }
            }
            leaf missing-at-worst {
              tailf:info "Treat missing MED as the least "
              +"preferred one";
              type empty;
            }
          }
        }
      }

      // router bgp * / bgp client-to-client
      container client-to-client {
        tailf:info "Configure client to client route reflection";
        leaf reflection {
          tailf:info "reflection of routes allowed";
          type empty;
        }
      }

      // router bgp * / bgp cluster-id
      leaf cluster-id {
        tailf:cli-full-command;
        type union {
          type uint32 {
            range "1..4294967295";
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id "
            +"as 32 bit quantity";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP "
            +"address format";
          }
        }
      }

      // router bgp * / bgp confederation
      container confederation {
        tailf:info "AS confederation parameters";
        leaf identifier {
          tailf:cli-full-command;
          tailf:info "as number";
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Set routing domain "
            +"confederation AS";
          }
        }
        container peers {
          tailf:info "Peer ASs in BGP confederation";
          presence "Peer ASs in BGP confederation";
          leaf-list peers-as {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type uint16 {
              range "1..65535";
              tailf:info "AS number";
            }
          }
        }
      }

      // router bgp * / bgp dampening
      container dampening {
        tailf:info "Enable route-flap dampening";
        presence true;
        choice dampening-choice {
          leaf route-map {
            tailf:info "Route-map to specify criteria for dampening";
            type string {
              tailf:info "WORD;;route-map name";
            }
          }
          container dampen {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf half-life-time {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-45>;;Half-life time for the penalty";
                range "1..45";
              }
            }
            leaf reuse-time {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start reusing a route";
                range "1..20000";
              }
            }
            leaf suppress-time {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start suppressing a route";
                range "1..20000";
              }
            }
            leaf max-suppress-time {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Maximum duration to suppress a "+
                  "stable route";
                range "1..255";
              }
            }
          }
        }
      }

      // router bgp * / bgp default
      container "default" {
        tailf:info "Configure BGP defaults";

        // router bgp * / no bgp default ipv4-unicast
        leaf ipv4-unicast {
          tailf:info "Activate ipv4-unicast for a peer by default";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / no bgp default ipv4-activate
        leaf ipv4-activate {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / bgp default local-preference
        leaf local-preference {
          tailf:info "local preference (higher=more preferred)";
          type uint32 {
            tailf:info "<0-4294967295>;;Configure default "
              +"local preference value";
            range "1..4294967295";
          }
        }

        // no bgp default route-target filter
        container route-target {
          tailf:info "Control behavior based on Route-Target attributes";
          leaf filter {
            tailf:info "Control automatic VPN Route-Target filtering";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // router bgp * / bgp deterministic-med
      leaf deterministic-med {
        tailf:cli-full-command;
        tailf:info "Pick the best-MED path among paths advertised from "
          +"the neighboring AS";
        type empty;
      }

      // router bgp * / bgp dmzlink-bw
      leaf dmzlink-bw {
        tailf:cli-full-command;
        tailf:info "Use DMZ Link Bandwidth as weight for BGP "
          +"multipaths";
        type empty;
      }

      // router bgp * / bgp enforce-first-as
      leaf enforce-first-as {
        tailf:info "Enforce the first AS for EBGP routes(default)";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp fast-external-fallover
      leaf fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly "
          +"connected external peer goes down";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp graceful-restart
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        tailf:cli-display-separated;
        tailf:cli-delete-when-empty;
        presence true;
        leaf restart-time {
          tailf:cli-full-command;
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting "
            +"peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
      }

      // router bgp * / bgp inject-map *
      list inject-map {
        tailf:info "Routemap which specifies prefixes to inject";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf exist-map {
          tailf:info "Routemap which specifies exist condition";
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf copy-attributes {
          tailf:info "Copy attributes from aggregate";
          type empty;
        }
      }

      // router bgp * / no bgp transport path-mtu-discovery
      container transport {
        tailf:info "global enable/disable transport session parameters";
        leaf path-mtu-discovery {
          tailf:info "transport path MTU discovery";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // router bgp * / bgp log-neighbor-changes
      leaf log-neighbor-changes {
        tailf:info "Log neighbor up/down and reset reason";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp listen
      container listen {
        tailf:info "Neighbor subnet range listener";
        tailf:cli-delete-when-empty;
        presence true;
        // router bgp * / bgp listen range
        container "range" {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf network-length {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Subnet range <network>/<length>, "+
                "e.g., 10.0.0.0/24";
            }
          }
          leaf peer-group {
            tailf:info "Member of the peer-group";
            type string {
              tailf:info "WORD;;peer-group name";
            }
          }
        }
        // router bgp * / bgp listen limit
        leaf limit {
          tailf:info "Set the max limit for the dynamic subnet range neighbors";
          type uint32 {
            tailf:info "<1-5000>;;max number";
            range "1..5000";
          }
        }
      }

      // router bgp * / bgp maxas-limit
      leaf maxas-limit {
        tailf:info "Allow AS-PATH attribute from any neighbor imposing "
        +"a limit on number of ASes";
        tailf:cli-full-command;
        type uint16 {
          range "1..2000";
          tailf:info "<1-2000>;;Number of ASes in the AS-PATH "
          +"attribute";
        }
      }

      // router bgp * / bgp additional-paths
      container additional-paths {
        tailf:info "Additional paths in the BGP table";
        choice send-receive-choice {
          // router bgp * / bgp additional-paths receive
          leaf receive {
            tailf:info "Receive additional paths from neighbors";
            tailf:cli-full-command;
            type empty;
          }
          // router bgp * / bgp additional-paths send
          container send {
            tailf:info "Send additional paths to neighbors";
            tailf:cli-delete-when-empty;
            presence true;
            leaf receive {
              tailf:info "Receive additional paths from neighbors";
              type empty;
            }
          }
        }
        // router bgp * / bgp additional-paths install
        leaf install {
          tailf:info "Additional paths to install into RIB";
          tailf:cli-full-command;
          type empty;
        }
      }

      // router bgp * / bgp nexthop
      container nexthop {
        tailf:info "Nexthop tracking commands";
        container trigger {
          tailf:info "Nexthop triggering";
          // router bgp * / bgp nexthop trigger delay
          leaf delay {
            tailf:cli-full-command;
            tailf:info "Set the delay to tigger nexthop tracking";
            type uint8 {
              tailf:info "<0-100>;;Delay value (seconds)";
              range "0..100";
            }
          }
          // router bgp * / no bgp nexthop trigger enable
          leaf enable {
            tailf:info "Enable nexthop tracking";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // router bgp * / bgp redistribute-internal
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp regexp
      container regexp {
        tailf:info "Select regular expression engine";
        leaf deterministic {
          tailf:info "Enable bounded-execution-time regular "
          +"expression engine";
          type empty;
        }
      }

      // router bgp * / bgp scan-time
      leaf scan-time {
        tailf:cli-full-command;
        tailf:info "Configure background scanner interval";
        type uint8 {
          range "5..60";
          tailf:info "<5-60>;;Scanner interval (seconds)";
        }
      }

      // router bgp * / bgp soft-reconfig-backup
      leaf soft-reconfig-backup {
        tailf:info "Use soft-reconfiguration inbound only when route-"
        +"refresh is not negotiated";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp suppress-inactive
      leaf suppress-inactive {
        tailf:info "Suppress routes that are not in the routing table";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp update-delay
      leaf update-delay {
        tailf:cli-full-command;
        tailf:info "Set the max initial delay for sending update";
        type uint16 {
          range "1..3600";
          tailf:info "<1-3600>;;Delay value (seconds)";
        }
      }
    }

    // router bgp * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Default metric";
        range "1..4294967295";
      }
    }

    // router bgp * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router bgp * / distance bgp
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf extern-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }

      // router bgp * / distance *
      list adm-distance {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "distance srcip wildbits";
        leaf distance {
          type uint16 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf srcip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildbits {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router bgp * / distribute-list *
    uses router-distribute-list-grouping;

    // router bgp * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / maximum-paths
      uses router-bgp-max-path-grouping;

      // router bgp * / maximum-paths eibgp
      container eibgp {
        tailf:info "Both eBGP and iBGP paths as multipath";
        uses router-bgp-max-path-grouping;
      }

      // router bgp * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        choice ibgp-choice {
          default b;
          case a {
            container unequal-cost {
              tailf:info "Perform Un-Equal cost multipath selection";
              uses router-bgp-max-path-grouping;
            }
          }
          case b {
            uses router-bgp-max-path-grouping;
          }
        }
      }

      // router bgp * / maximum-paths import
      leaf "import" {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }

    // router bgp * / import path
    container "import" {
      tailf:info "Configure path import";
      container "path" {
        tailf:info "Path selection and path limit";

        // router bgp * / import path selection
        container selection {
          tailf:info "Path selection policy";
          choice selection-choice {
            leaf all {
              tailf:info "Import all available paths";
              type empty;
            }
            container bestpath {
              tailf:info "Import the best available path.";
              tailf:cli-delete-when-empty;
              presence true;
              leaf strict {
                tailf:info "Do not fallback to best available path";
                type empty;
              }
            }
            container multipaths {
              tailf:info "Import all multipaths.";
              tailf:cli-delete-when-empty;
              presence true;
              leaf strict {
                tailf:info "Do not fallback to best available path";
                type empty;
              }
            }
          }
        }

        // router bgp * / import path limit
        leaf limit {
          tailf:info "Per net imported path limit";
          type uint8 {
            tailf:info "<2-255>;;Maximum number of paths that can be "+
              "imported into a net";
            range "2..255";
          }
        }
      }
    }

    // router bgp * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router bgp * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf as-no {
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Autonomous system number";
          }
        }
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Connected";
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / redistribute dvmrp
      container dvmrp {
        tailf:info "Redistribution of DVMRP into BGP IPv4 Multicast";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        uses route-map-metric-grouping;
      }

      // router bgp * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-number;
        leaf as-number {
          type uint32 {
            tailf:info "<1-65535>;;Autonomous system number";
            range "1..65535";
          }
        }
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        presence true;
        uses redistribute-isis-grouping;

        // router bgp * / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;ISO routing area tag";
              // match all but 'ip', 'level-.*', 'metric', and
              // 'route-map'
              pattern '^([^mlir].*)|(i[^p].*)|(ip..*)|(l[^e].*)'
              +'|(le[^v].*)|(lev[^e].*)|(leve[^l].*)|'
              +'(level[^\-].*)|(m[^e].*)|(me[^t].*)|'
              +'(met[^r].*)|(metr[^i].*)|(metri[^c].*)|'
              +'(metric..*)*(r[^o].*)|(ro[^u].*)|(rou[^t].*)|'
              +'(rout[^e].*)|(route[^\-].*)|(route-[^m].*)|'
              +'(route-m[^a].*)|(route-ma[^p].*)|'
              +'(route-map..*)$';
            }
          }
          uses redistribute-isis-grouping;
        }
      }

      // router bgp * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        uses route-map-metric-grouping;
        list iso-igrp-area {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
              // match any but route-map
              pattern '^([^r].*)|(r^[o].*)|(ro[^u].*)|'
              +'(rou[^t].*)|(rout[^e].*)|(route[^\-].*)|'
              +'(route-[^m].*)|(route-m[^a].*)|'
              +'(route-ma[^p])|(route-map..*)';
            }
          }
          uses route-map-metric-grouping;
        }
      }

      // router bgp * / redistribute mobile
      container mobile {
        presence "Mobile routes";
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / redistribute odr
      container odr {
        presence "On Demand stub Routes";
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        list vrf {
          tailf:info "VPN Routing/Forwarding Instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
            }
          }
          container match {
            tailf:info "Redistribution of OSPF routes";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses redistribute-ospf-match-grouping;
            uses router-bgp-redistribute-grouping;
          }
        }
        container non-vrf {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container match {
            tailf:info "Redistribution of OSPF routes";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses redistribute-ospf-match-grouping;
            uses router-bgp-redistribute-grouping;
          }
        }
      }

      // router bgp * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-bgp-redistribute-grouping;
      }
    }

    // router bgp * / neighbor *
    container neighbor-tag {
      tailf:cli-drop-node-name;
      list neighbor {
        tailf:info "Specify a neighbor router";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        ordered-by "user";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Neighbor tag";
          }
        }
        uses router-bgp-neighbor-grouping;
      }
    }

    // router bgp * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      uses router-bgp-neighbor-grouping;
    }

    // router bgp * / network
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key number;
      leaf number {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        tailf:cli-full-command;
        type empty;
      }
      leaf mask {
        tailf:info "Network mask";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network mask";
        }
      }
      leaf route-map {
        tailf:info "Route-map to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }

    // router bgp * / synchronization
    leaf synchronization {
      tailf:info "Perform IGP synchronization";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / auto-summary
    // router bgp * / no auto-summary
    leaf auto-summary {
      // Cisco doc node: Disabled by default
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // router bgp * / table-map
    leaf table-map {
      tailf:info "Map external entry attributes into routing table";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;route-map name";
      }
    }

  }

  // router ospfv3 * / address-family ipv4 XX
  grouping router-ospf-af-grouping {
  }

  // router ospfv3 * / address-family ipv4 unicast
  // router ospfv3 * / address-family ipv6 unicast
  grouping router-ospfv3-af-grouping {

    container discard-route {
      tailf:info "Enable or disable discard-route installation";
      leaf external {
        tailf:info "Discard route for summarised redistributed routes";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      leaf internal {
        tailf:info "Discard route for summarised inter-area routes";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  // router ospf * /
  // router ospf * vrf * /
  grouping router-ospf-common-af-grouping {

    // router ospf * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        leaf metric {
          tailf:info "OSPF default metric";
          type uint32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          type ospf-metric-type;
          default 2;
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router ospf * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-16777214>;;OSPF default metric";
        range "1..16777214";
      }
    }

    // router ospf * / distance
    container distance {
      tailf:info "Define an administrative distance";
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }
      // router ospf * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf weight {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }

      // router ospf * / distance ospf
      container ospf {
        tailf:info "OSPF routes Administrative distance";
        tailf:cli-compact-syntax;
        leaf intra-area {
          tailf:info "Intra-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for intra-area routes";
            range "1..255";
          }
        }
        leaf inter-area {
          tailf:info "Inter-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for inter-area routes";
            range "1..255";
          }
        }
        leaf external {
          tailf:info "External routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for external routes";
            range "1..255";
          }
        }
      }
    }

    // router ospf * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        range "1..32";
        tailf:info "<1-32>;;Number of paths";
      }
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        leaf as-number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-65535>;;Autonomous system number";
            range "1..65535";
          }
        }
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Connected";
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-number;
        leaf as-number {
          type uint32 {
            tailf:info "<1-65535>;;Autonomous system number";
            range "1..65535";
          }
        }
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        presence true;
        list isis-area {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|"
              +"metric-type|route-map|subnets|tag";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-ospf-redistribute-grouping;
        }
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        leaf area-tag {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "route-map";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Pointer to route-map entries";
          }
        }
        uses ospf-iso-igrp-redistribute-grouping;
      }

      // router ospf * / redistribute maximum-prefix
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of IP "
              +"prefixes redistributed";
            range "1..4294967295";
          }
        }
        container threshold-warning-only-container {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-100>;;Threshold value (%) at which "
                +"to generate a warning message";
              range "1..100";
            }
          }
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // router ospf * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint32 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-redistribute-grouping;
        container match {
          tailf:info "Redistribution of OSPF routes";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses redistribute-ospf-match-grouping;
          uses ospf-redistribute-match-grouping;
        }
      }

      // router ospf * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;

        // router ospf * / redistribute rip *
        list redistribute-list-rip {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this process";
            }
          }
          uses router-ospf-redistribute-grouping;
        }
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Static routes";
        uses router-ospf-redistribute-grouping;
      }
    }
  }

  // router ospf * /
  // router ospfv3 * /
  // router ospf * vrf * /
  // router ospfv3 * / address-family ipv4 unicast
  // router ospfv3 * / address-family ipv6 unicast
  grouping router-ospf-common-grouping {

    // router ospf * / area
    list area {
      tailf:cli-break-sequence-commands;
      tailf:info "OSPF area parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }

      // router ospf * / area * authentication
      container authentication {
        tailf:info "Enable authentication";
        presence true;
        leaf message-digest {
          tailf:info "Use message-digest authentication";
          type empty;
        }
      }

      // router ospf * / area * nssa
      container nssa {
        tailf:info "Specify a NSSA area";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;

        // router ospf * / area * nssa no-redistribution
        leaf no-redistribution {
          tailf:info "No redistribution into this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa default-information-originate
        leaf default-information-originate {
          tailf:info "Originate Type 7 default into NSSA area";
          type empty;
        }

        // router ospf * / area * nssa metric
        leaf metric {
          tailf:info "OSPF default metric";
          when "../default-information-originate";
          type int32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }

        // router ospf * / area * nssa metric-type
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          when "../default-information-originate";
          type ospf-metric-type;
          default 2;
        }

        // router ospf * / area * nssa nssa-only
        leaf nssa-only {
          tailf:info "Limit default advertisement to this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa no-ext-capability
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into NSSA";
          type empty;
        }

        // router ospf * / area * nssa no-summary
        leaf no-summary {
          tailf:info "Do not send summary LSA into NSSA";
          type empty;
        }

        // router ospf * / area * nssa translate
        container translate {
          tailf:info "Translate LSA";
          container type7 {
            tailf:info "From Type 7 to Type 5";
            tailf:cli-compact-syntax;
            leaf always {
              tailf:info "Always translate LSAs on this ABR";
              type empty;
            }
            leaf suppress-fa {
              tailf:info "Suppress forwarding address in translated LSAs";
              type empty;
            }
          }
        }
      }

      // router ospf * / area * default-cost
      leaf default-cost {
        tailf:info "Set the summary default-cost of a NSSA/stub area";
        tailf:cli-full-command;
        tailf:cli-no-value-on-delete;
        type uint32 {
          tailf:info "<0-16777215;;Stub's advertised external route metric";
          range "0..16777215";
        }
      }

      // router ospf * / area * filter-list
      list filter-list {
        tailf:info "Filter networks between OSPF areas";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf "prefix" {
          tailf:cli-prefix-key;
          mandatory true;
          tailf:info "Filter prefixes between OSPF areas";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Filter networks sent to this area";
            }
            enum out {
              tailf:info "Filter networks sent from this area";
            }
          }
        }
      }

      // router ospf * / area * range
      list "range" {
        tailf:info "Summarize routes matching address/mask "
          +"(border routers only)";
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to match";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP mask for address";
          }
        }
        choice advertise-choice {
          leaf advertise {
            tailf:info "Advertise this range (default)";
            type empty;
          }
          leaf not-advertise {
            tailf:info "DoNotAdvertise this range";
            type empty;
          }
        }
        leaf cost {
          tailf:info "User specified metric for this range";
          type uint32 {
            tailf:info "<0-16777215>;;Advertised metric for this range";
            range "0..16777215";
          }
        }
      }

      // router ospf * / address-family ipv6 unicast / area * range
      container range-ipv6 {
        tailf:cli-drop-node-name;
        list "range" {
          tailf:info "Summarize routes matching address/mask"
            +"(border routers only)";
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "prefix";
          leaf "prefix" {
            type inet:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix to match";
            }
          }
          choice advertise-choice {
            leaf advertise {
              tailf:info "Advertise this range (default)";
              type empty;
            }
            leaf not-advertise {
              tailf:info "DoNotAdvertise this range";
              type empty;
            }
          }
          leaf cost {
            tailf:info "User specified metric for this range";
            type uint32 {
              tailf:info "<0-16777215>;;Advertised metric for this range";
              range "0..16777215";
            }
          }
        }
      }

      // router ospf * / area * sham-link *
      list sham-link {
        tailf:info "Define a sham link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "source dest";
        leaf source {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link source";
          }
        }
        leaf dest {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link "
              +"destination";
          }
        }
        leaf cost {
          tailf:info "Associate a cost with the sham-link";
          type uint16 {
            tailf:info "<1-65535>;;Cost of the sham-link";
            range "0..65535";
          }
        }
      }

      // router ospf * / area * stub
      container stub {
        tailf:info "Specify a stub area";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into stub area";
          type empty;
        }
      }

      // router ospf * / area * virtual-link *
      list virtual-link {
        tailf:info "Define a virtual link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ID (IP addr) associated with "
              +"virtual link neighbor";
          }
        }

        // router ospf * / area * virtual-link retransmit-interval
        leaf retransmit-interval {
          tailf:info "LSA retransmit interval";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link transmit-delay
        leaf transmit-delay {
          tailf:info "LSA transmission delay";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
          default 1;
        }

        // router ospf * / area * virtual-link hello-interval
        leaf hello-interval {
          tailf:info "Hello packet interval";
          type int32 {
            range "1..8192";
            tailf:info "<1-8192;;Seconds>";
          }
        }

        // router ospf * / area * virtual-link dead-interval
        leaf dead-interval {
          tailf:info "Dead router detection time";
          type uint16 {
            range "1..8192";
            tailf:info "<1-8192;;Seconds>";
          }
        }

        // router ospf * / area * virtual-link authentication
        leaf authentication {
          tailf:info "Set authentication type";
          type empty;
        }

        // router ospf * / area * virtual-link authentication-key
        container authentication-key {
          tailf:info "Set authentication key";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf auth-type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;Encryption type (0 for not yet encrypted, "
                +"7 for proprietary)";
              range "0..7";
            }
            default 0;
          }
          leaf auth-key {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Authentication key (8 chars)";
              length "1..8";
            }
          }
        }

        // router ospf * / area * virtual-link message-digest-key *
        list message-digest-key {
          tailf:info "Set message digest key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          // router ospf * / area * virtual-link message-digest-key * md5
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf auth-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-7>;;Encryption type (0 for not "
                  +"yet encrypted, 7 for proprietary)";
                range "0..7";
              }
              default 0;
            }
            leaf auth-key {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Authentication key (16 chars)";
                length "1..16";
              }
            }
          }
        }

      }
    }

    // router ospf * / auto-cost
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      presence "Calculate OSPF interface cost according to bandwidth";
      leaf reference-bandwidth {
        tailf:info "Use reference bandwidth method to assign OSPF cost";
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms "
          +"of Mbits per second";
          range "1..4294967";
        }
      }
    }

    // router ospf * / bfd
    container bfd {
      tailf:info "BFD configuration commands";
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }
    }

    // router ospf * / interface-id
    container interface-id {
      tailf:info "Source of the interface ID";
      leaf snmp-if-index {
        tailf:info "SNMP MIB ifIndex";
        type empty;
      }
    }

    // router ospf * / log-adjacency-changes detail
    // router ospf * / no log-adjacency-changes
    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      tailf:cli-show-no;
      presence true;
      leaf detail {
        tailf:info "Log all state changes";
        type empty;
      }
    }

    // router ospf * / max-lsa
    container max-lsa {
      tailf:info "maximum number of LSAs OSPF process will receive";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf maximum-number {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967294>;;Maximum number of non self-generated "
            +"LSAs this process can receive";
          range "1..4294967294";
        }
      }
      leaf threshold-percentage {
        tailf:cli-break-sequence-commands;
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which "
            +"to generate a warning msg";
          range "1..100";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
      leaf ignore-time {
        tailf:info "time during which all adjacencies are suppressed";
        type uint32 {
          tailf:info "<1-17895>;;number of minutes during which "
            +"all adjacencies are suppressed";
          range "1..17895";
        }
      }
      leaf reset-time {
        tailf:info "time after which ignore-count is reset to zero";
        type uint32 {
          tailf:info "<2-35791>;;number of minutes after which "
            +"ignore-count is reset to zero";
          range "2..35791";
        }
        default 60;
      }
      leaf ignore-count {
        tailf:info "maximum number of times adjacencies "
          +"can be suppressed";
        type uint32 {
          range "1..65534";
          tailf:info "<1-65534>;;count on how many times "
            +"adjacencies can be suppressed";
        }
      }
    }

    // router ospf * / passive-interface
    uses passive-interface-grouping;

    // router ospf * / queue-depth
    container queue-depth {
      tailf:info "OSPF Hello/Router process queue depth";

      // router ospf * / queue-depth hello
      leaf hello {
        tailf:info "OSPF Hello process queue depth";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;maximum numer of packets in the queue";
            range "1..2147483647";
          }
          type enumeration {
            enum "unlimited" {
              tailf:info "Unlimited queue depth";
            }
          }
        }
        default "unlimited";
      }

      // router ospf * / queue-depth update
      leaf update {
        tailf:info "OSPF Router process queue depth";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;maximum numer of packets in the queue";
            range "1..2147483647";
          }
          type enumeration {
            enum "unlimited" {
              tailf:info "Unlimited queue depth";
            }
          }
        }
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router ospf * / timers lsa
      container lsa {
        tailf:info "OSPF LSA timers";
        leaf arrival {
          tailf:info "OSPF LSA arrival timer";
          type uint32 {
            range "0..600000";
            tailf:info "<0-600000>;;The minimum interval in milliseconds "
            +"between accepting the same LSA";
          }
        }
      }

      // router ospf * / timers pacing
      container pacing {
        tailf:info "OSPF pacing timers";
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          tailf:cli-full-command;
          type uint32 {
            range "5..100";
            tailf:info "<5-100>;;The minimum interval in msec "
            +"to pace limit flooding on interface";
          }
        }
        leaf lsa-group {
          tailf:info "OSPF LSA group pacing timer";
          tailf:cli-full-command;
          type uint32 {
            range "10..1800";
            tailf:info "<10-1800>;;Interval in sec between group "
            +"of LSA being refreshed or maxaged";
          }
        }
        leaf retransmission {
          tailf:info "OSPF retransmission pacing timer";
          tailf:cli-full-command;
          type uint32 {
            range "5..200";
            tailf:info "<5-200>;;The minimum interval in msec "
            +"between neighbor retransmissions";
          }
        }
      }

      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";

        // router ospf * / timers throttle lsa
        container lsa {
          tailf:info "OSPF LSA throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf all {
            tailf:info "For all type of OSPF LSAs";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf start-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay to generate first occurrence "
                +"of LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf hold-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Minimum delay between originating "
                +"the same LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf max-interval {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum delay between originating "
                +"the same LSA in milliseconds";
              range "0..600000";
            }
          }
        }

        // router ospf * / timers throttle spf
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf spf-start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between receiving a change "
                +"to SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-hold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between first and second "
                +"SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-max-wait {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum wait time in milliseconds "
                +"for SPF calculations";
              range "0..600000";
            }
          }
        }
      }
    }

    // router ospf * / router-id
    leaf router-id {
      tailf:cli-full-command;
      tailf:info "Override configured router identifier (peers will "
      +"reset)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Manually configured router identifier";
      }
    }

  }

  // router ospf * /
  // router ospf * vrf * /
  grouping router-ospf-grouping {

    // router ospf * / capability
    container capability {
      tailf:info "Enable specific OSPF feature";
      // router ospf * / no capability opaque
      leaf opaque {
        tailf:info "Opaque LSA";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // router ospf * / no capability lls
      leaf lls {
        tailf:info "Link-local Signaling (LLS) support";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // router ospf * / no capability transit
      leaf transit {
        tailf:info "Transit Area";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // router ospf * / no compatible rfc1583
    container compatible {
      tailf:info "OSPF compatibility list";
      leaf rfc1583 {
        tailf:info "compatible with RFC 1583";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // router ospf * / distribute-list *
    uses router-distribute-list-grouping;

    // router ospf * / domain-id
    container domain-id {
      tailf:info "OSPF domain-id";
      choice domain-id-choice {
        case a {
          leaf ip-format {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
            }
          }
          container ip-format-secondary {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
              }
            }
            leaf secondary {
              tailf:info "Secondary Domain-ID";
              type empty;
            }
          }
        }
        leaf Null {
          tailf:info "Null Domain-ID";
          tailf:cli-full-command;
          type empty;
        }
        container "type" {
          tailf:info "OSPF domain ID type in Hex format";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf type-leaf {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "0005" {
                tailf:info "Type 0x0005";
              }
              enum "0105" {
                tailf:info "Type 0x0105";
              }
              enum "0205" {
                tailf:info "Type 0x0205";
              }
              enum "8005" {
                tailf:info "Type 0x8005";
              }
            }
          }
          leaf "value" {
            tailf:info "OSPF domain ID value in Hex format";
            type string {
              tailf:info "Hex-data;;OSPF domain ID ext. community "
                +"value in Hex";
              pattern '[0-9a-fA-F]{12}';
            }
          }
        }
      }
    }

    // router ospf * / domain-tag
    leaf domain-tag {
      tailf:info "OSPF domain-tag";
      tailf:cli-full-command;
      type uint32 {
        range "1..4294967295";
        tailf:info "<1-4294967295>;;OSPF domain tag - 32-bit value";
      }
    }

    // router ospf * / ignore
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving "
          +"LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }

    // router ospf * / ispf
    leaf ispf {
      tailf:info "Enable incremental SPF computation";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / limit
    container limit {
      tailf:info "Limit a specific OSPF feature";
      container retransmissions {
        tailf:info "LS update, DBD, and LS request retransmissions";
        tailf:cli-compact-syntax;
        leaf dc {
          tailf:info "Demand circuit retransmissions";
          type limit-dc-non-dc-type;
        }
        leaf non-dc {
          tailf:info "Non-demand-circuit retransmissions";
          type limit-dc-non-dc-type;
        }
      }
    }

    // router ospf * / local-rib-criteria
    container local-rib-criteria {
      tailf:info "Enable or disable usage of local RIB as route criteria";
      tailf:cli-compact-syntax;
      leaf forwarding-address {
        tailf:info "Local RIB used to validate external/NSSA "
          +"forwarding addresses";
        type empty;
      }
      leaf inter-area-summary {
        tailf:info "Local RIB used as criteria for inter-area summaries";
        type empty;
      }
      leaf nssa-translation {
        tailf:info "Local RIB used as criteria for NSSA translation";
        type empty;
      }
    }

    // router ospf * / max-metric router-lsa
    container max-metric {
      tailf:info "Set maximum metric";
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        presence true;
        leaf include-stub {
          tailf:info "Set maximum metric for stub links in router-LSAs";
          type empty;
        }
        leaf summary-lsa {
          tailf:info "Override summary-lsa metric with max-metric value";
          type empty;
        }
        leaf summary-lsa-max-metric-value {
          when "../summary-lsa";
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info " <1-16777215>;;Overriding metric in summary-LSAs "
              +"(default 16711680)";
            range "1..16777215";
          }
        }
        leaf external-lsa {
          tailf:info "Override external-lsa metric with max-metric value";
          type empty;
        }
        leaf external-lsa-max-metric-value {
          when "../external-lsa";
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in "
              +"external-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
        container on-startup {
          tailf:info "Set maximum metric temporarily after reboot";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice time-wait-for-bgp-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<5-86400>;;Time, in seconds, router-LSAs "
                  +"are originated with max-metric";
                range "5..86400";
              }
            }
            leaf wait-for-bgp {
              tailf:info "Let BGP decide when to originate router-LSA "
                +"with normal metric";
              type empty;
            }
          }
        }
      }
    }

    // router ospf * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "routing protocol commands for MPLS LDP";
        container autoconfig {
          tailf:info "Configure LDP automatic configuration";
          presence "Configure LDP automatic configuration";
          leaf area {
            tailf:info "Configure an OSPF area to run MPLS LDP";
            type ospf-area-type;
          }
        }
        container sync {
          tailf:info "Configure LDP-IGP Synchronization";
          presence "Configure LDP-IGP Synchronization";
        }
      }
      container traffic-eng {
        tailf:info "routing protocol commands for MPLS Traffic Engineering";
        tailf:cli-compact-syntax;
        leaf multicast-intact {
          tailf:info "MPLS TE and PIM interaction";
          tailf:cli-full-command;
          type empty;
        }
        leaf area {
          tailf:info "configure an ospf area to run "
            +"MPLS Traffic Engineering";
          tailf:cli-full-command;
          type ospf-area-type;
        }
        container interface {
          tailf:info "MPLS TE interface configuration "
            +"for this OSPF process";
          tailf:cli-sequence-commands;
          // FIXME: interface container
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf area {
            tailf:info "advertise MPLS TE information for this "
              +"interface into area";
            type uint32 {
              tailf:info "<0-0>;;OSPF area ID as a decimal value";
            }
          }
        }
        container mesh-group-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf mesh-group {
            tailf:info "Traffic Engineering Mesh-Group advertisement";
            tailf:cli-incomplete-command;
            type uint32 {
              range "0..4294967295";
              tailf:info "<0-4294967295>;;Mesh Group Id";
            }
          }
          // FIXME: interface container
          leaf interface {
            tailf:info "Interface";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          list area {
            tailf:info "configure flooding scope as area";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type ospf-area-type;
            }
          }
        }
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          // FIXME: interface container
          leaf interface {
            tailf:info "Interface";
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }
    }

    // router ospf * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }

      // router ospf * / neighbor * / cost
      container cost-database-filter-container {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:info "OSPF cost for point-to-multipoint neighbor";
          type uint32 {
            tailf:info "<1-65535>;;metric";
            range "1..65535";
          }
        }
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and "
            +"flooding for point-to-multipoint neighbor";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container all {
            tailf:info "Filter all LSA";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf out {
              tailf:info "Outgoing LSA";
              type empty;
            }
          }
        }
      }

      // router ospf * / neighbor * / poll-interval
      container poll-interval-priority-container {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf poll-interval {
          tailf:info "OSPF dead-router polling interval";
          type uint32 {
            tailf:info "<0-65535>;;Seconds";
            range "0..65535";
          }

        }
        leaf priority {
          tailf:info "OSPF priority of non-broadcast neighbor";
          type uint32 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }
      }
    }

    // router ospf * / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-incomplete-command;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;OSPF wild card bits";
        }
      }
      leaf area {
        tailf:info "Set the OSPF area ID";
        type ospf-area-type;
      }
    }

    // router ospf * / nsf
    container nsf {
      tailf:info "Non-stop forwarding";
      presence true;
      container cisco {
        tailf:info "Cisco Non-stop forwarding";
        tailf:cli-delete-when-empty;
        presence true;
        container helper {
          tailf:info "helper support";
          presence true;
          leaf disable {
            tailf:info "disable helper support";
            tailf:cli-reset-container;
            type empty;
          }
        }
      }
      container ietf {
        tailf:info "IETF graceful restart";
        container helper {
          tailf:info "helper support";
          presence "helper support";
          leaf disable {
            tailf:info "disable helper support";
            tailf:cli-reset-container;
            tailf:cli-delete-container-on-delete;
            type empty;
          }
          leaf strict-lsa-checking {
            tailf:info "enable helper strict LSA checking";
            type empty;
          }
        }
      }
    }

    // router ospf * / prefix-suppression
    leaf prefix-suppression {
      tailf:info "OSPF prefix suppression";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / process-min-time
    container process-min-time {
      tailf:info "Percentage of quantum to be used before releasing CPU";
      leaf percent {
        tailf:info "percent";
        type uint32 {
          range "1..100";
          tailf:info "<1-100>;;Minimum CPU quantum";
        }
      }
    }

    // router ospf * / traffic-share min across-interface
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }

    // router ospf * / shutdown
    leaf shutdown {
      tailf:info "Shutdown the OSPF protocol under the current instance";
      tailf:cli-boolean-no;
      type boolean;
    }

    // router ospf * / summary-address
    list summary-address {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ip wildcard";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP summary address";
        }
      }
      leaf wildcard {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Summary mask";
        }
      }
      choice tag-no-advertise-choice {
        leaf tag {
          tailf:info "Set tag";
          tailf:cli-full-command;
          type uint32 {
            range "0..4294967295";
            tailf:info "<0-4294967295>;;32-bit tag value";
          }
        }
        leaf not-advertise {
          tailf:info "Do not advertise when translating OSPF type-7 LSA";
          type empty;
          tailf:cli-full-command;
        }
      }
    }

    // router ospf * / discard-route
    container discard-route {
      tailf:info "Enable or disable discard-route installation";
      tailf:cli-compact-syntax;
      presence true;
      leaf external {
        tailf:info "Discard route for redistributed summarised routes";
        type uint32 {
          tailf:info "<1-255>;;Administrative distance for "
            +"redistributed summarised routes";
          range "1..255";
        }
      }
      leaf internal {
        tailf:info "Discard route for summarised internal routes";
        type uint32 {
          tailf:info "<1-255>;;Administrative distance for "
            +"summarised internal routes";
          range "1..255";
        }
      }
    }
  }

  grouping router-ospfv3-grouping {
  }


  // ospf-redistribute-match-grouping
  grouping ospf-redistribute-match-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
        range "0..4294967295";
      }
    }
  }

  // ospf-iso-igrp-redistribute-grouping
  grouping ospf-iso-igrp-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type "
        +"for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
      default "2";
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
        range "0..4294967295";
      }
    }
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
  }

  // router ospf * / redistribute
  // router ospf * / redistribute bgp
  // router ospf * / redistribute eigrp
  // router ospf * / redistribute connected
  grouping router-ospf-redistribute-grouping {
    uses ospf-iso-igrp-redistribute-grouping;
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }


  // router rip
  // router rip / address-family ipv4 unicast
  // router rip / address-family ipv4 vrf *
  grouping router-rip-af-grouping {

    // router rip / no auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router rip / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "1-32;;Number of paths";
        range "1..32";
      }
    }

    // router rip / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }
    }

    // router rip / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
    }

    // router rip / no validate-update-source
    leaf validate-update-source {
      tailf:info "Perform sanity checks against source address of "
        +"routing updates";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router rip / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router rip / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Default metric";
        range "1..4294967295";
      }
    }

    // router rip / distance
    container distance {
      tailf:info "Define an administrative distance";
      tailf:cli-compact-syntax;
      leaf distance-leaf {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "1-255;;Administrative distance";
          range "1..255";
        }
      }
      // router rip / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "number ip mask";
        leaf number {
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "1-255;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router rip / distribute-list *
    uses router-distribute-list-grouping;

    // router rip / offset-list *
    list offset-list {
      tailf:info "Add or subtract offset from RIP metrics";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Perform offset on incoming updates";
          }
          enum out {
            tailf:info "Perform offset on outgoing updates";
          }
        }
      }
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type rip-offset-list-id-type;
      }
      leaf offset {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-16>;;Offset";
          range "0..16";
        }
      }
    }

    // router rip / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router rip / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        presence true;
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        leaf as-number {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
            }
          }
        }
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-number;
        leaf as-number {
          type uint16 {
            tailf:info "<1-65535>;;AS number";
            range "1..65535";
          }
        }
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        // router rip / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
          uses rip-metric-route-map-grouping;
        }
        leaf level {
          tailf:cli-drop-node-name;
          type isis-level-type;
        }
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence true;
        list iso-igrp-list {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            tailf:cli-disallow-value "metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses rip-metric-route-map-grouping;
        }
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence "Mobile routes";
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence "On Demand stub Routes";
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key process-id;
        leaf process-id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses rip-metric-route-map-grouping;

        // router rip / redistribute ospf * match
        container match {
          tailf:info "Redistribution of OSPF routes";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses redistribute-ospf-match-grouping;
          uses rip-metric-route-map-grouping;
        }
      }

      // router rip / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Static routes";
        uses rip-metric-route-map-grouping;
      }

      // router rip / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses rip-metric-route-map-grouping;
      }
    }

    // router rip / timers
    container timers {
      tailf:info "Adjust routing timers";
      tailf:cli-incomplete-no;
      tailf:cli-compact-syntax;
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-full-no;
        leaf updates {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Interval between updates for RIP";
            range "1..4294967295";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Invalid";
            range "1..4294967295";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Holddown";
            range "1..4294967295";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Flush";
            range "1..4294967295";
          }
        }
        leaf sleep {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Sleep time, in milliseconds";
            range "1..4294967295";
          }
        }
      }
    }

    // router rip / version
    leaf version {
      tailf:info "Set routing protocol version";
      tailf:cli-diff-dependency "/ios:ip/routing" {
        tailf:cli-trigger-on-set;
      }
      type uint8 {
        tailf:info "1-2;;rip version 1 or 2";
        range "1..2";
      }
    }

    // router rip / traffic-share min across-interfaces
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }
  }


  // router rip
  // router rip / address-family ipv4 unicast
  grouping router-rip-grouping {

    uses router-rip-af-grouping;

    // router rip / passive-interface
    uses passive-interface-grouping;

    // router rip / output-delay
    leaf output-delay {
      tailf:info "Interpacket delay for RIP updates";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "8-50;;Delay in milliseconds";
        range "8..50";
      }
    }

    // router rip / input-queue
    leaf input-queue {
      tailf:info "Specify input queue depth";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "0-1024;;queue depth";
        range "0..1024";
      }
    }

    // router rip / flash-update-threshold
    leaf flash-update-threshold {
      tailf:info "Specify flash update threshold in second";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-30>;;threshold in seconds";
        range "0..30";
      }
    }
  }

  grouping rip-metric-route-map-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type union {
        type uint8 {
          tailf:info "<0-16>;;Default metric";
          range "0..16";
        }
        type enumeration {
          enum transparent {
            tailf:info "Transparently redistribute metric";
          }
        }
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  grouping eigrp-metric-route-map-grouping {

    container metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf bandwidth-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth metric in Kbits per second";
        }
      }
      leaf delay-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<0-4294967295>;;EIGRP delay metric, "+
            "in 10 microsecond units";
        }
      }
      leaf reliability-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;EIGRP reliability metric where "+
            "255 is 100% reliable";
        }
      }
      leaf effective-bandwidth-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;EIGRP Effective bandwidth metric (Loading) "
            +"where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu-bytes {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;EIGRP MTU of the path";
          range "1..65535";
        }
      }
    }

    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router/isis grouping
  grouping narrow-wide-transition-grouping {
    leaf narrow-wide {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      type isis-level-type;
    }
    leaf transition {
      tailf:info "Accept both styles of TLVs during transition";
      tailf:cli-full-command;
      type isis-level-type;
    }
  }

  // router/isis grouping
  grouping spf-intervals-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120>;;Interval between consecutive SPFs in seconds";
        range "1..120";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120000>;;Initial wait before first SPF in milliseconds";
        range "1..120000";
      }
    }
    leaf minimum-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120000>;;Minimum wait between first and "
          +"second SPF in milliseconds";
        range "1..120000";
      }
    }
  }

  // router/isis grouping
  grouping router-isis-authenticate-snp-grouping {
    leaf authenticate {
      tailf:info "Authentication";
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf snp {
      tailf:info "SNP PDUs";
      type enumeration {
        enum send-only {
          tailf:info "Send but do not check PDUs on receiving";
        }
        enum validate {
          tailf:info "Send and check PDUs on receiving";
        }
      }
    }
  }

  // router/isis grouping
  grouping lsp-gen-interval-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120";
        tailf:info "<1-120>;;Interval in seconds";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120000";
        tailf:info "<1-120000>;;Initial wait in milliseconds";
      }
    }
    leaf wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120000";
        tailf:info "<1-120000>;;Wait between first and second "
        +"lsp generation in milliseconds";
      }
    }
  }

  // router/isis grouping
  grouping set-overload-bit-suppress-grouping {
    leaf external {
      tailf:info "If overload-bit set, don't advertise "
      +"IP prefixes learned from other protocols";
      tailf:cli-break-sequence-commands;
      type empty;
    }
    leaf interlevel {
      tailf:info "If overload-bit set, don't advertise "
      +"IP prefixes learned from another ISIS level";
      type empty;
    }
  }

  // router/isis grouping
  grouping summary-address-metric-tag-grouping {
    leaf metric {
      tailf:info "Set metric for summay route";
      tailf:cli-full-command;
      type uint32 {
        range "1..4294967295";
        tailf:info "<1-4294967295>;;metric";
      }
    }
    leaf tag {
      tailf:info "Set tag";
      type uint32 {
        range "1..4294967295";
        tailf:info "<1-4294967295>;;32-bit tag value";
      }
    }
  }

  // router/isis grouping
  grouping authentication-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type authentication-level-type;
    }
  }

  // router/isis grouping
  grouping redist-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type isis-level-type;
    }
  }

  // router/isis grouping
  grouping isis-redist-container-content-grouping {
    uses redist-level-grouping;
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "Set IS-IS External metric type";
        }
        enum internal {
          tailf:info "Set IS-IS Internal metric type";
        }
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router/isis grouping
  grouping router-isis-redistribute-grouping {
    uses isis-redist-container-content-grouping;
  }

  // router/isis grouping
  grouping isis-redist-af-grouping {
    container isis-redist-af-container {
      tailf:cli-drop-node-name;
      leaf include-connected {
        tailf:info "Include connected";
        type empty;
      }
      uses isis-redist-container-content-grouping;
    }
  }

  // router/isis grouping
  grouping isis-redist-ospf-match-grouping {
    uses redist-level-grouping;
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router/isis grouping
  grouping isis-redist-clns-ip-grouping {
    uses router-isis-redistribute-grouping;
    container clns {
      tailf:info "Redistribution of BGP NSAP routes";
      presence "Redistribution of BGP NSAP routes";
      leaf route-map {
        tailf:info "Route map reference";
        type string {
          tailf:info "WORD;;Pointer to route-map entries";
        }
      }
    }
    leaf ip {
      tailf:info "Redistribution of BGP IP routes";
      type empty;
    }
  }

  // router isis
  // router isis *
  // interface * / isis
  grouping router-isis-interface-grouping {

    // router isis * / authentication
    container authentication {
      tailf:info "ISIS authentication for LSPs";

      // router isis * / authentication mode
      container mode {
        tailf:info "Authentication mode";
        container md5 {
          tailf:info "Keyed message digest";
          presence true;
          uses authentication-level-grouping;
        }
        container text {
          tailf:info "Clear text password";
          presence true;
          uses authentication-level-grouping;
        }
      }

      // router isis * / authentication key-chain
      container key-chain {
        tailf:info "Authentication key-chain";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of key-chain";
          }
        }
        uses authentication-level-grouping;
      }

      // router isis * / authentication send-only
      container send-only {
        tailf:info "Authentication send only, receive ignore";
        presence true;
        uses authentication-level-grouping;
      }
    }
  }

  // router isis
  // router isis *
  // router isis * / address-family ipv6 unicast
  grouping router-isis-af-grouping {

    // router isis * / adjacency-check
    leaf adjacency-check {
      tailf:info "Check ISIS neighbor protocol support";
      tailf:cli-full-command;
      type empty;
    }

    // router isis * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      tailf:cli-incomplete-no;
      container originate {
        tailf:info "Distribute a default route";
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router isis * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    // router isis * / metric
    container metric {
      tailf:info "Set ISIS metric for all interfaces";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf "default" {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-63>;;Default metric";
          range "1..63";
        }
      }
      leaf level-1-2 {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "Apply metric to level-1 links";
          }
          enum level-2 {
            tailf:info "Apply metric to level-2 links";
          }
        }
      }
    }

    // router isis * / prc-interval
    container prc-interval {
      tailf:info "Minimum interval between partial route calculations";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interval {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120>;;PRC interval in seconds";
          range "1..120";
        }
      }
      leaf initial-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120000>;;Initial wait for PRC in milliseconds";
          range "1..120000";
        }
      }
      leaf minimum-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120000>;;Minimum wait between first and "
            +"second PRC in milliseconds";
          range "1..120000";
        }
      }
    }

    // router isis * / set-overload-bit
    container set-overload-bit {
      tailf:info "Signal other routers not to use us in SPF";
      choice set-overload-bit-choice {
        container on-startup {
          tailf:info "Set overload-bit only temporarily after reboot";
          choice on-startup-choice {
            container time {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise "
                    +"ourself as overloaded after reboot";
                  range "5..86400";
                }
              }
              leaf suppress {
                tailf:info "If overload-bit set, suppress the following "
                  +"types of IP prefixes";
                tailf:cli-incomplete-command;
                type empty;
              }
              uses set-overload-bit-suppress-grouping;
            }
            container wait-for-bgp {
              tailf:info "Let BGP decide when to unset the overload bit";
              presence "Let BGP decide when to unset the overload bitW";
              container suppress {
                tailf:info "If overload-bit set, suppress the following "
                  +"types of IP prefixes";
                tailf:cli-compact-syntax;
                uses set-overload-bit-suppress-grouping;
              }
            }
          }
        }
        container suppress {
          tailf:info "If overload-bit set, suppress the following "
            +"types of IP prefixes";
          tailf:cli-compact-syntax;
          uses set-overload-bit-suppress-grouping;
        }
      }
    }

    // router isis * / spf-interval
    container spf-interval {
      tailf:info "Minimum interval between SPF calculations";
      tailf:cli-compact-syntax;
      choice spf-interval-choice {
        list level-1-2 {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key level;
          leaf level {
            type enumeration {
              enum level-1 {
                tailf:info "Set interval for level 1 only";
              }
              enum level-2 {
                tailf:info "Set interval for level 2 only";
              }
            }
          }
          uses spf-intervals-grouping;
        }
        container intervals {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses spf-intervals-grouping;
        }
      }
    }

    // router isis * / traffic-share
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interface {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }
  }

  // router isis
  // router isis *
  grouping router-isis-grouping {

    container isis-main-container {
      tailf:cli-drop-node-name;

      uses router-isis-af-grouping;
      uses router-isis-interface-grouping;

      // router isis * / address-family ipv6 unicast
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration "
              +"mode";
            }
            uses router-isis-af-grouping;

            // router isis * / address-family ipv6 unicast / distance
            leaf distance {
              tailf:info "Administrative distance";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<1-255>;;OSPF Administrative distance";
                range "1..255";
              }
            }

            // router isis * / address-family ipv6 multi-topology
            container multi-topology {
              tailf:info "Enable multi-topology mode";
              presence "Enable multi-topology mode";
              leaf transition {
                tailf:info "Accept and generate both IS-IS "
                +"IPv6 and Multi-topology IPv6 TLVs";
                type empty;
              }
            }

            // router isis * / address-family ipv6 / redistribute
            container redistribute {
              tailf:info "Redistribute IPv6 prefixes from another "
                +"routing protocol";

              // router isis * / address-family ipv6 /redistribute bgp
              container bgp {
                tailf:info "Border Gateway Protocol (BGP)";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf as-number {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    range "1..65535";
                    tailf:info "<1-65535>;;Autonomous system number";
                  }
                }
                uses isis-redist-af-grouping;
              }

              container connected {
                tailf:info "Connected";
                presence "Connected";
                uses router-isis-redistribute-grouping;
              }

              list eigrp {
                tailf:info "Enhanced Interior Gateway Routing "
                +"Protocol (EIGRP)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key as-number;
                leaf as-number {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    range "1..65535";
                    tailf:info "<1-65535>;;Autonomous system number";
                  }
                }
                uses isis-redist-af-grouping;
              }

              container isis {
                tailf:info "ISO IS-IS";
                tailf:cli-compact-syntax;
                leaf area-tag {
                  tailf:cli-drop-node-name;
                  tailf:cli-disallow-value "level-1|level-2";
                  type string {
                    tailf:info "WORD;;IPv6 process name";
                  }
                }
                container levels {
                  tailf:cli-drop-node-name;
                  tailf:cli-sequence-commands;
                  leaf isis-redist-levels1 {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum level-1 {
                        tailf:info "Inter-area routes from level-1";
                      }
                      enum level-2 {
                        tailf:info "Inter-area routes from level-2";
                      }
                    }
                  }
                  leaf into {
                    tailf:info "from level-n into level-m";
                    tailf:cli-incomplete-command;
                    type empty;
                  }
                  leaf isis-redist-levels2 {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum level-1 {
                        tailf:info "Inter-area routes from level-1";
                      }
                      enum level-2 {
                        tailf:info "Inter-area routes from level-2";
                      }
                    }
                  }
                  leaf distribute-list {
                    tailf:info "select routes";
                    type string {
                      tailf:info "WORD;;IPv6 prefix-list name";
                    }
                  }
                }
              }

              container nemo {
                tailf:info "Network Mobility (NEMO)";
                tailf:cli-compact-syntax;
                uses isis-redist-af-grouping;
              }

              // router isis * / address-family ipv6 / redistribute ospf *
              list ospf {
                tailf:info "Open Shortest Path First (OSPF)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key process-id;
                leaf process-id {
                  tailf:cli-suppress-range;
                  type uint32 {
                    tailf:info "<1-65535>;;Process ID";
                    range "1..65535";
                  }
                }
                uses isis-redist-af-grouping;
                container match {
                  tailf:info "Redistribution of OSPF routes";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  uses redistribute-ospf-match-grouping;
                  uses isis-redist-ospf-match-grouping;
                }
              }

              list rip {
                tailf:info "IPv6 Routing Information Protocol (RIPv6)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key process;
                leaf process {
                  type string {
                    tailf:info "WORD;;User selected string identifying "
                    +"this process";
                  }
                }
                uses isis-redist-af-grouping;
              }

              container static {
                tailf:info "Static routes";
                presence "Static routes";
                uses router-isis-redistribute-grouping;
              }

            }

            // router isis * / address-family ipv6 summary-prefix
            list summary-prefix {
              tailf:info "Configure IPv6 summary prefix";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "prefix";
              leaf "prefix" {
                type inet:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
              }
              leaf levels {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum level-1 {
                    tailf:info "Summarize into level-1 area";
                  }
                  enum level-1-2 {
                    tailf:info "Summarize into both area and sub-domain";
                  }
                  enum level-2 {
                    tailf:info "Summarize into level-2 sub-domain";
                  }
                }
              }
            }
          }
        }
      }

      // router isis * / advertise
      container advertise {
        tailf:info "Control which IP routes flow in L1 and L2 LSPs";
        leaf passive-only {
          tailf:info "only interface address of passive interfaces";
          type empty;
        }
      }

      // router isis * / area-password
      container area-password {
        tailf:info "Configure the authentication password for an area";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Area password";
          }
        }
        uses router-isis-authenticate-snp-grouping;
      }

      // router isis * / nsf cisco
      container nsf {
        tailf:info "Non-stop forwarding";
        leaf cisco {
          tailf:info "Checkpoint method";
          type empty;
        }
      }

      // router isis * / bfd all-interfaces
      container bfd {
        tailf:info "BFD configuration commands";
        leaf all-interfaces {
          tailf:info "Enable BFD on all interfaces";
          type empty;
        }
      }

      // router isis * / distance
      container distance {
        tailf:info "Define an administrative distance";
        tailf:cli-compact-syntax;
        container clns-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf distance {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;OSPF Administrative distance";
              range "1..255";
            }
          }
          leaf clns {
            tailf:info "Distance applied for CLNS derived routes";
            tailf:cli-full-command;
            type empty;
          }
        }
        container ip-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf distance {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1..255";
              tailf:info "<1-255>;;OSPF Administrative distance";
            }
          }
          leaf ip {
            tailf:info "Distance applied for IP derived routes";
            tailf:cli-full-command;
            type empty;
          }
        }
        container acl-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf distance {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;OSPF Administrative distance";
              range "1..255";
            }
          }
          list acl {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "ip wildcard";
            leaf ip {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP source address";
              }
            }
            leaf wildcard {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Wildcard bits";
              }
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              type std-ip-acl-type;
            }
          }
        }
      }

      // router isis * / domain-password
      container domain-password {
        tailf:info "Set the authentication password for a routing domain";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Routing domain password";
          }
        }
        uses router-isis-authenticate-snp-grouping;
      }

      // router isis * / fast-flood
      container fast-flood {
        tailf:info "Flood LSPs (that triggered SPF) before running SPF";
        presence "Flood LSPs (that triggered SPF) before running SPF";
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1..15";
            tailf:info "<1-15>;;number of LSPs to be flooded "
            +"before starting SPF";
          }
        }
      }

      // router isis * / hello
      container hello {
        tailf:info "Pad ISIS hello PDUs to full MTU";
        container padding {
          tailf:info "Pad hello PDU";
          presence "Pad hello PDU";
          leaf pad-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum multi-point {
                tailf:info "Pad LAN hello PDUs";
              }
              enum point-to-point {
                tailf:info "Pad point-to-point hello PDUs";
              }
            }
          }
        }
      }

      // router isis * / hostname
      container hostname {
        tailf:info "Dynamic hostname for IS-IS";
        leaf dynamic {
          tailf:info "Dynamic hostname";
          type empty;
        }
      }

      // router isis * / ignore-lsp-errors
      leaf ignore-lsp-errors {
        tailf:info "Ignore LSPs with bad checksums";
        tailf:cli-full-command;
        type empty;
      }

      // router isis * / ip
      container ip {
        tailf:info "IP specific commands";
        container route {
          tailf:info "ISIS IP routes";
          container priority {
            tailf:info "Assign priority to IP prefixes";
            container high {
              tailf:info "Assign high priority to important IP "
              +"prefixes in ISIS IP local RIB";
              leaf tag {
                tailf:info "Assign high priority to IP prefixes "
                +"with a specific route tag";
                type uint32 {
                  range "1..4294967295";
                  tailf:info "<1-4294967295>;;tag value";
                }
              }
            }
          }
        }
      }

      // router isis * / is-type
      leaf is-type {
        tailf:info "IS Level for this routing process (OSI only)";
        tailf:cli-full-command;
        type enumeration {
          enum level-1 {
            tailf:info "Act as a station router only";
          }
          enum level-1-2 {
            tailf:info "Act as both a station router and an area router";
          }
          enum level-2-only {
            tailf:info "Act as an area router only";
          }
        }
      }

      // router isis * / ispf
      container ispf {
        tailf:info "Configure execution of incremental SPF";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Do incremental SPF for level-1";
            }
            enum level-1-2 {
              tailf:info "Do incremental SPF for both levels";
            }
            enum level-2 {
              tailf:info "Do incremental SPF for level-2";
            }
          }
        }
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1..600";
            tailf:info "<1-600>;;Number of seconds before "
            +"activating incremental-spf";
          }
        }
      }

      // router isis * / log-adjacency-changes
      container log-adjacency-changes {
        tailf:info "Log changes in adjacency state";
        presence true;
        leaf all {
          tailf:info "Include changes generated by non-IIH event";
          type empty;
        }
      }

      // router isis * / lsp-full
      container lsp-full {
        tailf:info "If we run out of LSP fragments";
        container suppress {
          tailf:info "suppress the following types of IP prefixes";
          choice lsp-full-choince {
            container external-interlevel-container {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "don't advertise IP prefixes learned "
                +"from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "don't advertise IP prefixes learned "
                +"from another ISIS level";
                type empty;
              }
            }
            leaf none {
              tailf:info "don't suppress any prefixes";
              type empty;
            }
          }
        }
      }

      // router isis * / lsp-gen-interval
      container lsp-gen-interval {
        tailf:info "Minimum interval between regenerating same LSP";
        choice lsp-gen-interval-choice {
          container intervals {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses lsp-gen-interval-grouping;
          }
          container intervals-levels {
            tailf:cli-drop-node-name;
            container intervals-level-1 {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf level-1 {
                tailf:info "Set interval for level 1 only";
                type empty;
              }
              uses lsp-gen-interval-grouping;
            }
            container intervals-level-2 {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf level-2 {
                tailf:info "Set interval for level 2 only";
                type empty;
              }
              uses lsp-gen-interval-grouping;
            }
          }
        }
      }

      // router isis * / lsp-mtu
      leaf lsp-mtu {
        tailf:info "Set maximum LSP size";
        tailf:cli-full-command;
        type uint32 {
          range "128..4352";
          tailf:info "<128-4352>;;Max LSP size in bytes";
        }
      }

      // router isis * / lsp-refresh-interval
      leaf lsp-refresh-interval {
        tailf:info "Set LSP refresh interval";
        tailf:cli-full-command;
        type uint32 {
          range "1..65535";
          tailf:info "<1-65535>;;LSP refresh time in seconds";
        }
      }

      // router isis * / max-area-addresses
      leaf max-area-addresses {
        tailf:info "Allow configuration of more manual area addresses";
        tailf:cli-full-command;
        type uint32 {
          range "3..254";
          tailf:info "<3-254>;;Max number of manual area addresses";
        }
      }

      // router isis * / max-lsp-lifetime
      leaf max-lsp-lifetime {
        tailf:info "Set maximum LSP lifetime";
        tailf:cli-full-command;
        type uint32 {
          range "1..65535";
          tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
        }
      }

      // router isis * / metric-style
      container metric-style {
        tailf:info "Use old-style (ISO 10589) or new-style packet formats";
        choice metric-style-choice {
          container narrow {
            tailf:info "Use old style of TLVs with narrow metric";
            presence true;
            uses narrow-wide-transition-grouping;
          }
          container transition {
            tailf:info "Send and accept both styles of TLVs "
              +"during transition";
            presence true;
            leaf level {
              tailf:cli-drop-node-name;
              type isis-level-type;
            }
          }
          container wide {
            tailf:info "Use new style of TLVs to carry wider metric";
            presence true;
            uses narrow-wide-transition-grouping;
          }
        }
      }

      // router isis * / mpls
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";

        // router isis * / mpls ldp sync
        container ldp {
          tailf:info "routing protocol commands for MPLS LDP";
          leaf sync {
            tailf:info "Configure LDP-IGP Synchronization";
            type empty;
          }
        }

        // router isis * / mpls traffic-eng
        container traffic-eng {
          tailf:info "routing protocol commands for MPLS Traffic Engineering";
          leaf level-1 {
            tailf:info "Run MPLS TE on IS-IS level 1 only";
            tailf:cli-full-command;
            type empty;
          }
          leaf level-2 {
            tailf:info "Run MPLS TE on IS-IS level 2 only";
            tailf:cli-full-command;
            type empty;
          }
          leaf multicast-intact {
            tailf:info "MPLS TE and PIM interaction";
            tailf:cli-full-command;
            type empty;
          }

          container router-id {
            tailf:info "Traffic Engineering stable IP address for system";
            uses interface-name-grouping;
          }

          container scanner {
            tailf:info "Timer parameters for TE database";
            presence "Timer parameters for TE database";
            tailf:cli-compact-syntax;
            leaf interval {
              tailf:info "time (secs) between LSPDB walks for TE";
              type uint32 {
                range "1..60";
                tailf:info "<1-60>;;interval between LSPDB walks "
                +"for TE TLVs extraction";
              }
            }
            leaf max-flash {
              tailf:info "Number of ISIS LSPs to be processed with no delay";
              type uint32 {
                range "0..200";
                tailf:info "<0-200>;;Max. number of LSPs ISIS may send to "
                +"TE db without delay";
              }
            }
          }
        }
      }

      // router isis * / net *
      list net {
        tailf:info "A Network Entity Title for this process (OSI only)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
          }
        }
      }

      // router isis * / partition
      container partition {
        tailf:info "CLNS area partition";
        leaf avoidance {
          tailf:info "Withdraw area prefix if partition detected";
          type empty;
        }
      }

      // router isis * / passive-interface
      uses passive-interface-grouping;

      // router isis * / protocol
      container protocol {
        tailf:info "Set protocol's administrative state";
        leaf shutdown {
          tailf:info "Set protocol's administrative state to disable";
          type empty;
        }
      }

      // router isis * / redistribute
      container redistribute {
        tailf:info "Redistribute information from another routing protocol";

        // router isis * / redistribute bgp
        container bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-compact-syntax;
          leaf as-number {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1..65535";
              tailf:info "<1-65535>;;Autonomous system number";
            }
          }
          uses isis-redist-clns-ip-grouping;
        }

        // router isis * / redistribute connected
        container connected {
          tailf:info "Connected";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence "Connected";
          uses router-isis-redistribute-grouping;
        }

        // router isis * / redistribute eigrp *
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key as-number;
          leaf as-number {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1..65535";
              tailf:info "<1-65535>;;Autonomous system number";
            }
          }
          uses router-isis-redistribute-grouping;
        }

        // router isis * / redistribute isis
        container isis {
          tailf:info "ISO IS-IS";
          tailf:cli-compact-syntax;
          leaf area-tag {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "ip";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          container ip {
            tailf:info "Redistribution of IP routes between levels";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf level {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum level-1 {
                  tailf:info "Inter-area routes from level-1";
                }
                enum level-2 {
                  tailf:info "Inter-area routes from level-2";
                }
              }
            }
            leaf into {
              tailf:info "from level-n into level-m";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf level2 {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum level-1 {
                  tailf:info "Inter-area routes from level-1";
                }
                enum level-2 {
                  tailf:info "Inter-area routes from level-2";
                }
              }
            }
            choice isis-redist-isis-ip-choice {
              leaf distribute-list {
                tailf:info "select routes";
                type uint32 {
                  tailf:info "<100-199>;;IP extended acces-list number";
                  range "100..199";
                }
              }
              leaf route-map {
                tailf:info "Route map for route matching";
                type string {
                  tailf:info "WORD;;Name of the route-map";
                }
              }
            }
          }
        }

        // router isis * / redistribute iso-igrp
        container iso-igrp {
          tailf:info "IGRP for OSI networks";
          presence "IGRP for OSI networks";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice iso-igrp-choice {
            container area-tag-route-map-container {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf area-tag {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "route-map";
                type string {
                  tailf:info "WORD;;ISO routing area tag";
                }
              }
              leaf route-map {
                tailf:info "Route map reference";
                type string {
                  tailf:info "WORD;;Pointer to route-map entries";
                }
              }
            }
            leaf route-map {
              tailf:info "Route map reference";
              type string {
                tailf:info "WORD;;Pointer to route-map entries";
              }
            }
          }
          uses redist-level-grouping;
          leaf metric {
            tailf:info "ISIS default metric";
            type uint32 {
              tailf:info "<0-4294967295>;;ISIS default metric";
              range "0..4294967295";
            }
          }
          leaf metric-type {
            tailf:info "OSPF/IS-IS exterior metric type for "
            +"redistributed routes";
            type enumeration {
              enum external {
              tailf:info "Set IS-IS External metric type";
              }
              enum internal {
              tailf:info "Set IS-IS Internal metric type";
              }
            }
          }
        }

        // router isis * / redistribute maximum-prefix
        container maximum-prefix {
          tailf:info "Maximum number of prefixes redistributed to protocol";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf number {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1..4294967295";
              tailf:info "<1-4294967295>;;Maximum number of IP "
              +"prefixes redistributed";
            }
          }
          leaf threshold-value {
            tailf:cli-drop-node-name;
            tailf:cli-break-sequence-commands;
            type uint32 {
              tailf:info "<1-100>;;Threshold value (%) at which to "
                +"generate a warning message";
              range "1..100";
            }
          }
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            tailf:cli-full-command;
            type empty;
          }
          leaf withdraw {
            tailf:info "Withdraw redistibuted prefixes";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router isis * / redistribute maximum-prefix
        container mobile {
          tailf:info "Mobile routes";
          tailf:cli-compact-syntax;
          presence "Mobile routes";
          uses router-isis-redistribute-grouping;
        }

        // router isis * / redistribute odr
        container odr {
          tailf:info "On Demand stub Routes";
          tailf:cli-compact-syntax;
          presence "On Demand stub Routes";
          uses router-isis-redistribute-grouping;
        }

        // router isis * / redistribute ospf *
        list ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key process-id;
          leaf process-id {
            tailf:cli-suppress-range;
            type uint32 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          uses router-isis-redistribute-grouping;
          container match {
            tailf:info "Redistribution of OSPF routes";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses redistribute-ospf-match-grouping;
            uses isis-redist-ospf-match-grouping;
          }
        }

        // router isis * / redistribute rip
        container rip {
          tailf:info "Routing Information Protocol (RIP)";
          tailf:cli-compact-syntax;
          presence "Routing Information Protocol (RIP)";
          uses router-isis-redistribute-grouping;
        }

        // router isis * / redistribute static
        container static {
          tailf:info "Static routes";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence "Static routes";
          uses isis-redist-clns-ip-grouping;
        }
      }

      // router isis * / set-attached-bit
      container set-attached-bit {
        tailf:info "Conditionally advertise us as attached to L2";
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // router isis * / summary-address
      list summary-address {
        tailf:info "Configure IP address summaries";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP summary address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Summary mask";
          }
        }
        container level-1 {
          tailf:info "Summarize into level-1 area";
          presence "Summarize into level-1 area";
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
        container level-1-2 {
          tailf:info "Summarize into both area and sub-domain";
          presence "Summarize into both area and sub-domain";
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
        container level-2 {
          tailf:info "Summarize into level-2 sub-domain";
          presence "Summarize into level-2 sub-domain";
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
        container metric-tag-container {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
      }

      // router isis * / update-queue-depth
      leaf update-queue-depth {
        tailf:info "Set Update process queue depth";
        type uint32 {
          tailf:info "<1-2147483647>;;Max queue depth";
          range "1..2147483647";
        }
      }

      // router isis * / use
      container use {
        tailf:info "Use different algorithms during SPF";
        leaf external-metrics {
          tailf:info "Honour external metrics during SPF";
          type empty;
        }
      }
    }
  }

  // grouping interface-switch-grouping
  grouping interface-switch-grouping {

    // interface * / switchport
    // Note: Catalyst 6500/6000 Switches and 7600 Routers
    // show "switchport" when enabled and nothing when disabled.
    // AND: switchport xxx config is not deleted with "no switchport".
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-display-separated;
      // [removed 141218] Not done on real device: tailf:cli-delete-when-empty;
      tailf:callpoint interface-switchport-hook { tailf:set-hook node; }
      tailf:cli-diff-dependency "../ip/route-cache-conf/route-cache" {
        tailf:cli-trigger-on-set;
      }
      presence true;

      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          // Note: Can't use leafref cause of 'dynamic' keyword
          tailf:cli-diff-dependency "/ios:vlan/vlan-list/id";
          type union {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID of the VLAN when this port "+
                "is in access mode";
              range "1..4094";
            }
            type enumeration {
              enum dynamic {
                tailf:info "When in access mode, this interfaces VLAN is "+
                  "controlled by VMPS";
              }
            }
          }
        }
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";

        // interface * / switchport trunk encapsulation
        leaf encapsulation {
          tailf:info "Set encapsulation format on trunk port";
          type enumeration {
            enum "dot1q" {
              tailf:info "Interface uses only 802.1q trunking encapsulation "+
                "when trunking";
            }
            enum "isl" {
              tailf:info "Interface uses only ISL trunking encapsulation "+
                "when trunking";
            }
            enum "negotiate" {
              tailf:info "Device will negotiate trunking encapsulation "+
                "with peer on interface";
            }
          }
          default negotiate;
        }

        // interface * / switchport trunk native
        container native {
          tailf:info "Set trunking native characteristics when interface "+
            "is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                  +"this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }

        // interface * / switchport trunk allowed
        // Note: Java code makes a single entry of all 'add' entries.
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface "+
            "is in trunking mode";
          // interface * / switchport trunk allowed vlan
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-replace-all;
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }

        // interface * / switchport trunk pruning
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in "+
            "trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in "+
              "trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }

      // interface * / switchport autostate
      container autostate {
        tailf:info "Include or exclude this port from vlan link up calculation";
        tailf:cli-incomplete-command;
        leaf exclude {
          tailf:info "Exclude this port from vlan link up calculation";
          type empty;
        }
      }

      // interface * / switchport private-vlan
      container private-vlan {
        tailf:info "Set the private VLAN configuration";

        // interface * / switchport private-vlan trunk
        container trunk {
          tailf:info "Set the private vlan trunking configuration";

          // interface * / switchport private-vlan trunk native vlan
          container native {
            tailf:info "Set the private vlan trunking native configuration";
            leaf vlan {
              tailf:info "Set native VLAN configuration";
              type union {
                type enumeration {
                  enum "tag" {
                    tailf:info "Set native VLAN tagging state";
                  }
                }
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                    +"this port is in trunking mode";
                  range "1..4094";
                }
              }
            }
          }

          // interface * / switchport private-vlan trunk allowed vlan
          // Note: Java code makes a single entry of all 'add' entries.
          container allowed {
            tailf:info "Set allowed VLAN characteristics when interface "+
              "is in private-vlan trunking mode";
            container vlan {
              tailf:info "Set allowed VLANs when interface is in "+
                "private-vlan trunking mode";
              choice vlan-choice {
                leaf-list vlans {
                  tailf:cli-replace-all;
                  tailf:cli-range-list-syntax;
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "WORD;;VLAN IDs of the allowed VLANs when "+
                      "interface is in private-vlan trunking mode";
                  }
                }
                leaf all {
                  tailf:info "all VLANs";
                  type empty;
                }
                leaf-list except {
                  tailf:info "all VLANs except the following";
                  tailf:cli-range-list-syntax;
                  type uint16 {
                    tailf:info "WORD;;VLAN IDs of disallowed VLANS when "+
                      "this port is in trunking mode ";
                  }
                }
                leaf none {
                  tailf:info "no VLANs";
                  type empty;
                }
              }
            }
          }
        }

        // interface * / private-vlan association
        container association {
          tailf:info "Set the private VLAN association";

          // interface * / private-vlan association trunk *
          list trunk {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key primary-vlan-id;
            leaf primary-vlan-id {
              type uint16 {
                tailf:info "<2-4094>;;Primary VLAN ID of the private VLAN "+
                  "trunk association";
                range "2..4094";
              }
            }
            leaf secondary-vlan-id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<2-4094>;;Secondary VLAN ID of the private VLAN "+
                  "port/trunk association";
                range "2..4094";
              }
            }
          }
        }
      }

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          // interface * / switchport mode access
          container access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            presence "true";
          }
          // interface * / switchport mode dot1q-tunnel
          container dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            presence "true";
          }
          // interface * / switchport mode dynamic
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access "+
              "or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter "+
                  "to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter "+
                  "to DESIRABLE";
              }
            }
          }
          // interface * / switchport mode trunk
          container trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            tailf:cli-diff-dependency "../../trunk";
            presence "true";
          }
          // interface * / switchport mode private-vlan
          container private-vlan {
            tailf:info "Set private-vlan mode";
            choice private-vlan-choice {
              leaf host {
                tailf:info "Set the mode to private-vlan host";
                type empty;
              }
              leaf promiscuous {
                tailf:info "Set the mode to private-vlan promiscuous";
                type empty;
              }
              container trunk {
                tailf:info "Set the mode to private-vlan trunk";
                presence true;
              }
            }
          }
        }
      }

      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol "+
          "on this interface";
        tailf:cli-diff-dependency "../trunk";
        type empty;
      }

      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }

      // interface * / switchport voice
      container voice {
        tailf:info "Voice appliance attributes";
        leaf vlan {
          tailf:info "Vlan for voice traffic";
          type union {
            type enumeration {
              enum dot1p {
                tailf:info "Priority tagged on PVID";
              }
              enum none {
                tailf:info "Don't tell telephone about voice vlan";
              }
              enum untagged {
                tailf:info "Untagged on PVID";
              }
            }
            type uint16 {
              tailf:info "<1-4094>;;Vlan for voice traffic";
              range "1..4094";
            }
          }
        }
        container detect {
          tailf:info "detection enhancement keyword";
          tailf:cli-incomplete-command;
          container cisco-phone {
            tailf:info "Cisco IP phone";
            presence true;
            leaf full-duplex {
              tailf:info "full duplex keyword";
              type empty;
            }
          }
        }
      }

      // interface * / switchport port-security
      container port-security {
        tailf:info "Security related command";
        tailf:cli-display-separated;
        tailf:cli-diff-dependency "../trunk";
        presence true;
        container aging {
          tailf:info "Port-security aging commands";
          leaf time {
            tailf:info "Port-security aging time";
            type uint16 {
              tailf:info "<1-1440>;;Aging time in minutes. Enter a value "
                +"between 1 and 1440";
              range "1..1440";
            }
          }
          leaf type {
            tailf:info "Port-security aging type";
            type enumeration {
              enum absolute {
                tailf:info "Absolute aging (default)";
              }
              enum inactivity {
                tailf:info "Aging based on inactivity time period";
              }
            }
          }
        }
        container mac-address {
          tailf:info "Secure mac address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf sticky {
            tailf:info "Configure dynamic secure addresses as sticky";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf hw-address {
            tailf:cli-drop-node-name;
            type yang:mac-address {
              tailf:info "H.H.H;;48 bit mac address";
            }
          }
          leaf vlan {
            tailf:info "set VLAN ID of the VLAN on which this address can be "
              +"learned";
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID on which this address can be "
                +"learned";
              range "1..4094";
            }
          }
        }
        container maximum {
          tailf:info "Max secure addresses";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf max-addresses {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4097>;;Maximum addresses";
              range "1..4097";
            }
          }
          leaf vlan {
            tailf:info "Max secure addresses per vlan";
            type string {
              tailf:info "WORD;;VLAN IDs to which this maximum applies";
            }
          }
        }
        leaf violation {
          tailf:info "Security violation mode";
          type enumeration {
            enum protect {
              tailf:info "Security violation protect mode";
            }
            enum restrict {
              tailf:info "Security violation restrict mode";
            }
            enum shutdown {
              tailf:info "Security violation shutdown mode";
            }
          }
        }
      }

      // interface * / switchport priority
      container priority {
        tailf:info "Set appliance 802.1p priority";
        tailf:cli-incomplete-command;

        container extend {
          tailf:info "Set appliance 802.1p priority";
          tailf:cli-incomplete-command;
          choice trust-choice {
            leaf trust {
              tailf:cli-full-command;
              tailf:info "Trust 802.1p priorities of devices on appliance";
              type empty;
            }
            leaf cos {
              tailf:info "Override 802.1p priority of devices on appliance";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-7>;;Priority for devices on appliance";
                range "0..7";
              }
            }
          }
        }
      }

      // interface * / switchport protected
      leaf protected {
        tailf:info "Configure an interface to be a protected port";
        type empty;
      }

      // interface * / switchport host
      leaf host {
        tailf:info "Set port host";
        type empty;
      }
    }

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      // interface * / spanning-tree bpdufilter
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      // interface * / spanning-tree bpduguard
      container bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        choice bpduguard-choice {
          leaf disable {
            tailf:info "Disable BPDU guard for this interface";
            type empty;
          }
          leaf enable {
            type empty;
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      // interface * / spanning-tree cost
      leaf cost {
        tailf:info "To set the path cost of the interface";
        tailf:cli-full-command;
        type uint32 {
          range "1..200000000";
        }
      }
      // interface * / spanning-tree guard
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on "
              +"interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on "
              +"interface";
          }
        }
      }
      // interface * / spanning-tree link-type
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree "
          +"protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum auto {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media "
              +"duplex of this interface";
          }
          enum none {
            tailf:info "Consider the interface as point-to-"
              +"point";
          }
          enum point-to-point {
            tailf:info "Consider the interface as point-to-"
              +"point";
          }
          enum root {
            tailf:info "Consider the interface as shared";
          }
        }
      }
      // interface * / spanning-tree mst
      container mst {
        tailf:info "Multiple spanning tree";
        choice mst-choice {
          list instance-range {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-range-list-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "MST instance list, example 0,2-4,6,8-12";
              }
            }
            leaf cost {
              tailf:info "Change the interface spanning tree path cost "+
                "for an instance";
              type uint32 {
                tailf:info "<1-200000000>;;Change the interface spanning tree "+
                  "path cost for an instance";
                range "1..200000000";
              }
            }
            leaf port-priority {
              tailf:info "Change the spanning tree port priority "+
                "for an instance";
              type uint16 {
                tailf:info "<0-240>;;port priority in increments of 16";
                range "0..240" {
                  tailf:step 16;
                }
              }
            }
          }
          leaf pre-standard {
            tailf:info "Force pre-standard MST BPDU transmission on port";
            type empty;
          }
        }
      }
      // interface * / spanning-tree portfast
      container portfast {
        tailf:info "Spanning tree portfast options";
        tailf:cli-delete-when-empty;
        presence true;
        leaf enable {
          tailf:cli-full-command;
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Disable portfast for this interface";
            }
          }
        }
        leaf trunk {
          //FIXME: tailf:info
          type empty;
        }
      }
      // interface * / spanning-tree loopguard default
      container loopguard {
        tailf:info "Spanning tree loopguard options";
        leaf default {
          tailf:info "Enable loopguard by default on all ports";
          type empty;
        }
      }
    }

    // interface * / srr-queue
    container srr-queue {
      //tailf:info
      container bandwidth {
        //tailf:info
        // interface * / srr-queue bandwidth shape
        container shape {
          //tailf:info
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              //tailf:info
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              //tailf:info
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              //tailf:info
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint16 {
              //tailf:info
            }
          }
        }
        // interface * / srr-queue bandwidth share
        container share {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          //tailf:info
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "1..255";
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "1..255";
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "1..255";
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint8 {
              range "1..255";
            }
          }
        }
      }
    }

    // interface * / queue-set
    leaf queue-set {
      type uint8 {
      }
    }
  }

  // password-07-grouping
  grouping password-07-grouping {
    leaf "type" {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password/key will follow";
        }
        enum "7" {
          tailf:info "Specifies a HIDDEN password/key will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) password/key";
      }
    }
  }


  // router lisp / ipv4
  // router lisp / eid-table * ipv4
  grouping router-lisp-af4-common-grouping {

    // router lisp / ipv4 map-request-source
    leaf map-request-source {
      tailf:info "Configures inner header source address in Map-Request"+
        "message";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IPv4 Source address of inner header in "+
          "Map-Request message";
      }
    }

    // router lisp / ipv4 proxy-itr
    container proxy-itr {
      tailf:info "Configures a LISP Proxy Ingress Tunnel Router (PITR)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf ipv4-local-locator {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address in ITR-RLOC field of map-request";
        }
      }
      leaf ipv6-local-locator {
        tailf:cli-drop-node-name;
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address in ITR-RLOC field of "+
            "map-request";
        }
      }
    }
  }

  // router lisp / ipv6
  // router lisp / eid-table * ipv6
  grouping router-lisp-af6-common-grouping {

    // router lisp / ipv6 map-request-source
    leaf map-request-source {
      tailf:info "Configures inner header source address in Map-Request "+
        "message";
      type inet:ipv6-address {
        tailf:info "X:X:X:X::X;;IPv6 Source address of inner header in "+
          "Map-Request message";
      }
    }

    // router lisp / ipv6 proxy-itr
    container proxy-itr {
      tailf:info "Configures a LISP Proxy Ingress Tunnel Router (PITR)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf ipv6-local-locator {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address in ITR-RLOC field of "+
            "map-request";
        }
      }
      leaf ipv4-local-locator {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address in ITR-RLOC field of map-request";
        }
      }
    }

  }

  // router lisp / ipv4
  // router lisp / ipv6
  // router lisp / eid-table * ipv4
  // router lisp / eid-table * ipv6
  grouping router-lisp-af-common-grouping {

    // router lisp / ipv4 map-cache-limit
    leaf map-cache-limit {
      tailf:info "Configures maximum size of map-cache";
      type uint32 {
        tailf:info "<0-100000>;;Maximum number of map-cache entries";
        range "0..100000";
      }
    }

    // router lisp / ipv4 map-cache-persistent
    container map-cache-persistent {
      tailf:info "Dump map-cache onto flash, making it persistent "+
        "across reboots";
      tailf:cli-show-no;
      presence true;
      leaf interval {
        tailf:info "Interval in minutes of how often the "+
          "map-cache is saved";
        type uint16 {
          tailf:info "<1-1440>;;Interval in minutes, default 60";
          range "1..1440";
        }
      }
    }

    // router lisp / ipv4 proxy-etr
    leaf proxy-etr {
      tailf:info "Configures a LISP Proxy Engress Tunnel Router (PETR)";
      tailf:cli-full-command;
      type empty;
    }

    // router lisp / ipv4 use-petr
    list use-petr {
      tailf:info "Encapsulate to Proxy ETR when matching forward-native "+
        "entry";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 locator address of PETR";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 locator address of PETR";
          }
        }
      }
      leaf priority {
        tailf:info "Configures which Locators from a set are preferred";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Lower priority Locator takes preference";
        }
      }
      leaf weight {
        tailf:info "Traffic load-spreading among Locators";
        type uint8 {
          tailf:info "<0-100>;;Relative weight of locator";
          range "0..100";
        }
      }
    }

  }

  // router lisp / ipv4
  // router lisp / ipv6
  grouping router-lisp-af-grouping {

    // router lisp / ipv4 map-server
    // router lisp / ipv6 map-server
    leaf map-server {
      tailf:info "Configures a LISP Map Server (MS)";
      type empty;
    }

    // router lisp / ipv4 map-resolver
    // router lisp / ipv6 map-resolver
    leaf map-resolver {
      tailf:info "Configures a LISP Map Resolver (MR)";
      type empty;
    }

    // router lisp / ipv4 itr
    // router lisp / ipv6 itr
    container itr {
      tailf:info "Configures a LISP Ingress Tunnel Router (ITR)";
      tailf:cli-display-separated;
      presence true;
      // router lisp / ipv4 itr map-resolver *
      list map-resolver {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "IPv4 Address of map resolver";
            }
            type inet:ipv6-address {
              tailf:info "IPv6 Address of map resolver";
            }
          }
        }
      }
    }

    // router lisp / ipv4 etr
    // router lisp / ipv6 etr
    container etr {
      tailf:info "Configures a LISP Egress Tunnel Router (ETR)";
      tailf:cli-display-separated;
      presence true;
      // router lisp / ipv4 etr map-server *
      list map-server {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "IPv4 Address of map server";
            }
            type inet:ipv6-address {
              tailf:info "IPv6 Address of map server";
            }
          }
        }
        // router lisp / ipv4 etr map-server * key
        container "key" {
          tailf:info "Authentication key used with map server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf "encryption" {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum "0" {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum "6" {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf "key" {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
            }
          }
        }
      }
    }
  }

  // router-lisp-eid-table-grouping
  grouping router-lisp-eid-table-grouping {

    // router lisp / eid-table * instance-id
    leaf instance-id {
      tailf:info "EID instance-ID";
      tailf:cli-hide-in-submode;
      mandatory true;
      type uint32 {
        tailf:info "<0-16777214>;;Instance-ID";
        range "0..16777214";
      }
    }

    // router lisp / eid-table * / map-cache *
    list map-cache {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key "prefix";
      leaf "prefix" {
        type union {
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D/nn;;IPv4 EID-prefix for RLOC static mapping";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID-prefix for RLOC static mapping";
          }
        }
      }
      choice map-cache-choice {
        // router lisp / eid-table * / map-cache * <locator>
        case locator {
          leaf locator {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 Address of loopback or other ETR "+
                  "interface";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 Address of loopback or other ETR "+
                  "interface";
              }
            }
          }
          leaf priority {
            tailf:info "Lower priority Locator takes preference";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Lower priority Locator takes preference";
            }
          }
          leaf weight {
            tailf:info "Traffic load-spreading among Locators";
            type uint8 {
              tailf:info "<0-100>;;Relative weight of locator";
              range "0..100";
            }
          }
        }
        // router lisp / eid-table * / map-cache * map-request
        leaf map-request {
          tailf:info "Send Map-Request for LISP destination EID";
          tailf:cli-full-command;
          type empty;
        }
        // router lisp / eid-table * / map-cache * native-forward
        leaf native-forward {
          tailf:info "Natively forward packets that match this map-cache entry";
          tailf:cli-full-command;
          type empty;
        }
        // router lisp / eid-table * / map-cache * drop
        leaf drop {
          tailf:info "Drop packets that match this map-cache entry";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // router lisp / eid-table * / database-mapping *
    list database-mapping {
      tailf:info "Configures Locator addresses for an ETR";
      tailf:cli-incomplete-command;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "prefix";
      max-elements 100;
      leaf "prefix" {
        type union {
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D/nn;;EID-prefix to advertise locators for "+
              "(max 100 prefixes)";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;EID-prefix to advertise locators "+
              "for (max 100 prefixes)";
          }
        }
      }
      // router lisp / eid-table * / database-mapping * <rloc>
      choice rloc-choice {
        leaf ipv4-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 Address of loopback or other "+
              "ETR interface";
          }
        }
        container IPv4-interface {
          tailf:info "Use IPv4 address of interface as locator";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          uses interface-name-grouping;
        }
        container IPv6-interface {
          tailf:info "Use IPv6 address of interface as locator";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          uses interface-name-grouping;
        }
        leaf ipv6-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 Address of loopback or other "+
              "ETR interface";
          }
        }
        leaf auto-discover-rlocs {
          tailf:info "Auto discover locators registered by other xTRs";
          tailf:cli-full-command;
          type empty;
        }
        leaf locator-set {
          tailf:info "Use locators defined by locator-set";
          tailf:cli-full-command;
          type string;
          //type tailf:non-strict-leafref {
          //path "../../../locator-set/name";
          //}
        }
      }
      leaf priority {
        tailf:info "Configures which Locators from a set are preferred";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Lower priority Locator takes preference";
        }
      }
      leaf weight {
        tailf:info "Traffic load-spreading among Locators";
        type uint8 {
          tailf:info "<0-100>;;Relative weight of locator";
        }
      }
    }

    // router lisp / eid-table * / loc-reach-algorithm
    container loc-reach-algorithm {
      tailf:info "Configure locator reachability algorithm";
      leaf lsb-reports {
        tailf:info "Configure data packet LSB report handling";
        type enumeration {
          enum ignore {
            tailf:info "Ignore data packet LSB reports";
          }
        }
      }
      leaf rloc-probing {
        tailf:info "Probe high priority RLOCs with Map-Requests as last "+
          "resort";
        type empty;
      }
    }

    // router lisp / eid-table * / ipv4
    container ipv4 {
      tailf:info "IPv4 address family";
      uses router-lisp-af-common-grouping;
      uses router-lisp-af4-common-grouping;
    }

    // router lisp / eid-table * / ipv6
    container ipv6 {
      tailf:info "IPv6 address family";
      uses router-lisp-af-common-grouping;
      uses router-lisp-af6-common-grouping;
    }

  }

  // router-lisp-grouping
  grouping router-lisp-grouping {

    // router lisp / locator-set *
    list locator-set {
      tailf:info "Configure a named locator set";
      tailf:cli-mode-name "config-router-lisp-locator-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "Configure a named locator set";
        }
      }

      // router lisp / locator-set * / a.b.c.d
      list IPv4-address {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / X:X:X:X::X
      list IPv6-address {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Address of loopback or other ETR "+
              "interface";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / IPv4-interface *
      list IPv4-interface {
        tailf:info "Use IPv4 address of interface as locator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / IPv6-interface *
      list IPv6-interface {
        tailf:info "Use IPv6 address of interface as locator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }
    }

    // router lisp / map-request
    container map-request {
      tailf:info "Configure map-request handling";
      leaf itr-rlocs {
        tailf:info "Configure to use the specified RLOC set as ITR RLOC in "+
          "map-request";
        type string {
          tailf:info "WORD;;Existing locator set";
        }
        tailf:non-strict-leafref {
          path "../../locator-set/name";
        }
      }
    }

    // router lisp / eid-table
    container eid-table {
      tailf:info "Configure an EID instance for a VRF";

      // router lisp / eid-table default
      list default-vrf {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-router-lisp-eid-table";
        key name;
        leaf name {
          type enumeration {
            enum "default" {
              tailf:info "Default VRF";
            }
          }
        }
        uses router-lisp-eid-table-grouping;
      }

      // router lisp / eid-table vrf *
      list vrf {
        tailf:cli-mode-name "config-router-lisp-eid-table";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-lisp-eid-table-grouping;
      }
    }

    // router lisp / site *
    list site {
      tailf:info "Configure a LISP site on a map server (MS)";
      tailf:cli-mode-name "config-router-lisp-site";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;The site name";
        }
      }
      leaf "description" {
        tailf:info "Provide a description string for the LISP site";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Site description";
        }
      }
      container authentication-key {
        tailf:info "Authentication key used by LISP site";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "encryption" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "6" {
              tailf:info "Specifies an ENCRYPTED password will follow";
            }
          }
        }
        leaf "key" {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
          }
        }
      }
      list eid-prefix {
        tailf:info "Site EID address prefix";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "prefix";
        leaf "prefix" {
          type union {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
            }
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging "+
                "to the SITE";
            }
          }
        }
      }
      container eid-prefix-instance {
        tailf:cli-drop-node-name;
        list eid-prefix {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "instance-id prefix";
          leaf instance-id {
            tailf:info "EID instance-ID";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "<1-16777214>;;Instance-ID";
              range "1..16777214";
            }
          }
          leaf "prefix" {
            type union {
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
              }
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging "+
                  "to the SITE";
              }
            }
          }
        }
      }
    }

    // router lisp / ipv4
    container ipv4 {
      tailf:info "IPv4 address family";
      uses router-lisp-af-grouping;
      uses router-lisp-af-common-grouping;
      uses router-lisp-af4-common-grouping;
    }

    // router lisp / ipv6
    container ipv6 {
      tailf:info "IPv6 address family";
      uses router-lisp-af-grouping;
      uses router-lisp-af-common-grouping;
      uses router-lisp-af6-common-grouping;
    }

  }

  grouping ip-nat-inside-souce-static-grouping {
    // [extendable]
    leaf extendable {
      tailf:info "Extend this translation when used";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [no-alias]
    leaf no-alias {
      tailf:info "Do not create an alias for the global address";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [no-payload]
    leaf no-payload {
      tailf:info "No translation of embedded address/port in the "+
        "payload";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    //FIXME: [ route-map name [reversible] ]
    leaf route-map {
      tailf:info "Specify route-map";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Route-map name";
      }
    }
    leaf reversible {
      when "../route-map";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    //[ redundancy { group-name | rg-id mapping-id mapping-id } ]
    leaf redundancy {
      tailf:info "NAT redundancy operation";
      tailf:cli-optional-in-sequence;
      type union {
        type uint8 {
          tailf:info "<1-2>;IP redundancy ID";
        }
        type string {
          tailf:info "WORD;;IP redundancy name";
        }
      }
    }
    leaf mapping-id {
      when "../redundancy";
      tailf:info "Associate a mapping id to this mapping";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }
    // [ vrf name [match-in-vrf] ]
    leaf vrf {
      tailf:info "Specify vrf";
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      type string {
        tailf:info "WORD;;vrf name";
      }
    }
    leaf match-in-vrf {
      when "../vrf";
      tailf:info "Match incoming vrf";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [forced]
    leaf forced {
      tailf:info "Delete this entry and its children, "+
        "even if in use";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    //?? overload
    leaf overload {
      tailf:info "Overload an address translation";
      type empty;
    }
  }

  grouping ip-nat-inside-grouping {
    choice pool-or-interface {
      // ip nat inside source list * pool
      case pool-choice {
        leaf pool {
          tailf:info "Name pool of global addresses";
          type string;
          tailf:non-strict-leafref {
            path "/ios:ip/nat/pool/id";
          }
        }
        // [ redundancy <rg-id> ]
        leaf redundancy {
          tailf:info "NAT redundancy operation";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-2>;;IP redundancy ID";
            range "1..2";
          }
        }
        // [ mapping-id <map-id> ]
        leaf mapping-id {
          tailf:info "Associate a mapping id to this mapping";
          tailf:cli-optional-in-sequence;
          type uint32 {
            tailf:info "<1-2147483647>;;Stateful NAT mapping id";
            range "1..2147483647";
          }
        }
      }
      // ip nat inside source list * interface
      case interface-choice {
        container interface {
          tailf:info "Specify interface for global address";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }

    // [no-payload]
    leaf no-payload {
      tailf:info "No translation of embedded address/port in the "+
        "payload";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [reversible]
    leaf reversible {
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [vrf name [match-in-vrf] ]
    leaf vrf {
      tailf:info "Specify vrf";
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      type string {
        tailf:info "WORD;;vrf name";
      }
    }
    leaf match-in-vrf {
      when "../vrf";
      tailf:info "Match incoming vrf";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [overload]
    leaf overload {
      //tailf:cli-break-sequence-commands;
      tailf:info "Overload an address translation";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    // [oer]
    leaf oer {
      tailf:info "Use with vtemplate only. On new translation, "+
        "if OER BR is UP, OER will select IP from outgoing Interface."+
        " All packets matching translation are forwarded over "+
        "Interface for duration of translation.";
      type empty;
    }
    // [ portmap name ]
  }

  grouping mobile-ip-spi-grouping {
    choice spi-type-choice {
      leaf hex {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<100-FFFFFFFF>;;SPI hex value";
        }
      }
      leaf decimal {
        tailf:info "decimal Security parameter index - bidirectional";
        type uint32 {
          tailf:info "<256-4294967295>;;SPI decimal value";
          range "256..4294967295";
        }
      }
    }
  }

  // interface * / xconnect
  // interface * / service instance * ethernet / xconnect
  // cable l2vpn * / service instance * ethernet / xconnect
  grouping interface-xconnect-grouping {

    choice xconnect-choice {

      // interface * / xconnect encapsulation
      container xconnect {
        tailf:cli-break-sequence-commands;
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xconn";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter VC ID value";
            range "1..4294967295";
          }
        }
        leaf encapsulation {
          tailf:info "Data encapsulation method";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum mpls {
              tailf:info "Use MPLS encapsulation";
            }
            enum l2tpv3 {
              tailf:info "Use L2TPv3 encapsulation";
            }
          }
        }
        leaf manual {
          tailf:info "Manually configure L2TP session parameters";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf pw-class {
          tailf:info "Optional pseudowire-class to use for "+
            "advanced configuration";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
        }
        leaf pw-type {
          tailf:info "MPLS Pseudo-wire Type";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<4-5>;;Type-5 : Ethernet Port, Type-4 : Ethernet VLAN";
            range "4..5";
          }
        }
        leaf sequencing {
          tailf:info "Configure sequencing options for xconnect";
          tailf:cli-full-command;
          tailf:cli-hide-in-submode;
          when "../encapsulation = 'l2tpv3'";
          type enumeration {
            enum both {
              tailf:info "Transmit and receive sequence numbers";
            }
            enum receive {
              tailf:info "Receive sequence numbers";
            }
            enum transmit {
              tailf:info "Transmit sequence numbers";
            }
          }
        }

        // interface * / xconnect encapsulation / backup
        container backup {
          tailf:cli-break-sequence-commands;
          tailf:info "Xconnect backup configuration commands";

          // interface * / xconnect encapsulation / backup peer
          container peer {
            tailf:info "Backup pseudowire";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf peer-router-ip-addr {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of peer";
              }
            }
            leaf vcid {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Enter VC ID value";
                range "1..4294967295";
              }
            }
            leaf pw-class {
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "Optional Pseudowire-class to use for "+
                  "backup pseudowire";
              }
            }
            leaf priority {
              tailf:info "Optional priority to use for backup pseudowire.";
              type uint8 {
                tailf:info "Peer priority";
                range "1..10";
              }
            }
          }

          // interface * / xconnect encapsulation / backup delay
          container delay {
            tailf:info "Backup delay";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf enable-delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-180>;;Enable delay";
                range "0..180";
              }
              default 0;
            }
            leaf disable-delay {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<0-180>;;Disable delay";
                  range "0..180";
                }
                type enumeration {
                  enum never {
                    tailf:info "Disallow disable";
                  }
                }
              }
              default 0;
            }
          }
        }

        // interface * / xconnect encapsulation / mtu
        leaf mtu {
          tailf:info "set XCONNECT Maximum Transfer Unit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<64-9100>;;per Xconnect MTU size in bytes";
            range "64..9100";
          }
        }

        // interface * / xconnect encapsulation / ..
        // .. no remote link failure notification
        container remote {
          tailf:info "Xconnect remote peer configuration commands";
          container link {
            tailf:info "Link information";
            container failure {
              tailf:info "Failure information";
              leaf "notification" {
                tailf:info "Notify in case of remote link failure";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                type boolean;
                default true;
              }
            }
          }
        }
      }

      // interface * / xconnect pw-class
      container xconnect-pw-class {
        tailf:cli-drop-node-name;
        container xconnect {
          tailf:info "Xconnect commands";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of peer";
            }
          }
          leaf vcid {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          leaf pw-class {
            tailf:info "Pseudowire-class to use for encapsulation "+
              "and protocol configuration";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Pseudowire-class name";
            }
          }
        }
      }

    }
  }

  // ip pim
  // ip pim vrf *
  grouping ip-pim-grouping {

    // ip pim ssm
    container ssm {
      tailf:info "Configure Source Specific Multicast";
      choice ip-pim-ssm-choice {
        leaf "default" {
          tailf:info "Use 232/8 group range for SSM";
          type empty;
        }
        leaf "range" {
          tailf:info "ACL for group range to be used for SSM";
          type union {
            type uint16 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP named access list";
              pattern '[a-zA-Z].*';
            }
          }
        }
      }
    }

    // ip pim bsr-candidate *
    list bsr-candidate {
      tailf:info "Candidate bootstrap router (candidate BSR)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf hash-mask-length {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-32>;;Hash Mask length for RP selection";
          range "0..32";
        }
      }
      leaf priority {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-255>;;Priority value for candidate "+
            "bootstrap router";
        }
      }
    }

    // ip pim rp-address
    container rp-address {
      tailf:info "PIM RP-address (Rendezvous Point)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of Rendezvous-point for group";
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type std-acl-type;
      }
      leaf override {
        tailf:info "Overrides dynamically learnt RP mappings";
        type empty;
      }
    }

    // ip pim rp-candidate *
    list rp-candidate {
      tailf:info "To be a PIMv2 RP candidate";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf bidir {
        type empty;
      }
      leaf group-list {
        tailf:info "group-list";
        type union {
          type uint8 {
            tailf:info "<1-99>;;Access-list reference for group prefixes";
            range "1..99";
          }
          type string {
            tailf:info "WORD;;Named access list";
          }
        }
      }
      leaf interval {
        tailf:info "RP candidate advertisement interval";
        type uint16 {
          tailf:info "<1-16383>;;number of seconds";
          range "1..16383";
        }
      }
      leaf priority {
        tailf:info "RP candidate priority";
        type uint8 {
          tailf:info "<0-255>;;Priority value";
        }
      }
    }
  }


  // event manager applet * / event
  // event manager applet * / event tag *
  grouping event-manager-applet-event-grouping {

    // event manager applet * / event none
    container none {
      tailf:info "Manually run policy event";
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
        }
      }
    }

    // event manager applet * / event snmp-notification
    container snmp-notification {
      tailf:info "SNMP Notification Event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf oid {
        tailf:info "Object ID of data element";
        type string {
          tailf:info "WORD;;OID string";
        }
      }
      leaf oid-val {
        tailf:info "Comparison value";
        type string {
          tailf:info "WORD;;Comparision value";
        }
      }
      leaf op {
        tailf:info "Operator";
        type operator-type;
      }
      leaf src-ip-address {
        tailf:info "Source ip address";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source ip address value";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Source ip address value";
          }
        }
      }
      leaf dest-ip-address {
        tailf:info "Destination ip address";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination ip address value";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Destination ip address value";
          }
        }
      }
    }

    // event manager applet * / event syslog
    container syslog {
      tailf:info "Syslog event";
      // event manager applet * / event syslog pattern
      leaf "pattern" {
        tailf:info "Pattern match string for the entire message";
        type string {
          tailf:info "WORD;;Pattern match string for the entire message";
        }
      }
    }

    // event manager applet * / event cli
    container cli {
      tailf:info "CLI event";
      tailf:cli-compact-syntax;
      container "pattern" {
        tailf:info "CLI command pattern match";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf regular-expression {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Pattern match string";
          }
        }
        leaf sync {
          tailf:info "CLI and EEM policy execution sync or async";
          type enumeration {
            enum no {
              tailf:info "Policy and CLI will run asynchronously";
            }
            enum yes {
              tailf:info "Run policy and the result determines whether "+
                "to run CLI";
            }
          }
        }
      }
    }

    // event manager applet * / event track
    container track {
      tailf:info "Tracking object event";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf object-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-500>;;Tracking object number";
        }
      }
      leaf state {
        tailf:info "State of tracking object";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum any {
            tailf:info "Any state";
          }
          enum down {
            tailf:info "Down state";
          }
          enum up {
            tailf:info "Up state";
          }
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }
  }

  // vrf definition * / route-target
  // vrf definition * / address-family ipv4 / route-target
  // l2vpn vfi context * / autodiscovery bgp signaling * / route-target
  grouping vrf-route-target-grouping {
    list "export" {
      tailf:info "Export Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN "+
            "Extended Community";
        }
      }
    }
    list "import" {
      tailf:info "Import Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN "+
            "Extended Community";
        }
      }
    }
  }

  // vrf definition * / address-family ipv4
  // vrf definition * / address-family ipv6
  grouping vrf-definition-af-grouping {

    // vrf definition * / address-family ipv4 / export
    container export {
      tailf:info "VRF export";
      leaf map {
        tailf:info "Route-map based VRF export";
        type string {
          tailf:info "WORD;;Route-map reference";
        }
      }
    }

    // vrf definition * / address-family ipv4 / route-target
    container route-target {
      tailf:info "Specify Target VPN Extended Communities";
      uses vrf-route-target-grouping;
    }

    // vrf definition * / address-family ipv4 / maximum routes
    container maximum {
      tailf:info "Set a limit";
      container routes {
        tailf:info "Maximum number of routes allowed in this routing table";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967294>;;Maximum number of routes allowed";
          }
        }
        choice action {
          case a {
            leaf warning-only {
              tailf:info "Only give a warning message if limit is exceeded";
              type empty;
            }
          }
          case b {
            leaf warn-threshold {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Threshold value (%) at which to "+
                  "generate a warning msg";
                range "1..100";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due to over "+
                "maximum route limit";
              type uint8 {
                tailf:info "<1-100>;;Threshold value (%) at which to "+
                  "reinstall routes back to VRF";
                range "1..100";
              }
            }
          }
        }
      }
    }
  }

  // snmp-server host *
  grouping snmp-server-host-grouping {

    // snmp-server host * traps
    // snmp-server host * informs
    leaf message-type {
      tailf:cli-optional-in-sequence;
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum informs {
          tailf:info "Send Inform messages to this host";
        }
        enum traps {
          tailf:info "Send Trap messages to this host";
        }
      }
      default traps;
    }

    // snmp-server host * version
    container version {
      tailf:info "SNMP version to use for notification messages";
      tailf:cli-optional-in-sequence;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      leaf version {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "Use SNMPv1";
          }
          enum "2c" {
            tailf:info "Use SNMPv2c";
          }
          enum "3" {
            tailf:info "Use SNMPv3";
          }
        }
      }
      leaf security-level {
        tailf:cli-drop-node-name;
        when "../version = '3'";
        type enumeration {
          enum auth {
            tailf:info "Use the SNMPv3 authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Use the SNMPv3 noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Use the SNMPv3 authPriv Security Level";
          }
        }
      }
    }

    // snmp-server host * community-string
    leaf community-string {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "version|informs|traps|vrf";
      type string {
        tailf:info "WORD;;SNMPv1/v2c community string or SNMPv3 user name";
      }
    }

    // snmp-server host * community-string
    leaf-list allowed-traps {
      tailf:cli-drop-node-name;
      tailf:cli-flat-list-syntax {
        tailf:cli-replace-all;
      }
      type enumeration {
        enum aaa_server {
          tailf:info "Allow SNMP AAA traps";
        }
        enum alarms {
          tailf:info "Allow SNMP alarms traps";
        }
        enum atm {
          tailf:info "Allow SNMP atm traps";
        }
        enum bfd {
          tailf:info "Allow SNMP BFD traps";
        }
        enum bgp {
          tailf:info "Allow BGP state change traps";
        }
        enum bstun {
          tailf:info "Allow bstun event traps";
        }
        enum bulkstat {
          tailf:info "Allow Data-Collection-MIB traps";
        }
        enum cable {
          tailf:info "Allow SNMP cable traps";
        }
        enum call-home {
          tailf:info "Allow SNMP CISCO-CALLHOME-MIB traps";
        }
        enum casa {
          tailf:info "Allow casa event traps";
        }
        enum cef {
          tailf:info "Allows cef traps";
        }
        enum cnpd {
          tailf:info "Allow NBAR Protocol Discovery traps";
        }
        enum config {
          tailf:info "Allow SNMP config traps";
        }
        enum config-copy {
          tailf:info "Allow SNMP config-copy traps";
        }
        enum config-ctid {
          tailf:info "Allow SNMP config-ctid traps";
        }
        enum cpu {
          tailf:info "Allow cpu related traps";
        }
        enum dhcp {
          tailf:info "Allow dhcp traps";
        }
        enum dlsw {
          tailf:info "Allow dlsw traps";
        }
        enum ds1 {
          tailf:info "Allow SNMP ds1 traps";
        }
        enum dsp {
          tailf:info "Allow SNMP DSP traps";
        }
        enum dspu {
          tailf:info "Allow dspu event traps";
        }
        enum eigrp {
          tailf:info "Allow SNMP EIGRP traps";
        }
        enum entity {
          tailf:info "Allow SNMP entity traps";
        }
        enum entity-diag {
          tailf:info "Allow SNMP CISCO-ENTITY-DIAG-MIB traps";
        }
        enum entity-qfp {
          tailf:info "Allow SNMP CISCO-ENTITY-QFP-MIB traps";
        }
        enum entity-state {
          tailf:info "Allow ENTITY-STATE-MIB traps";
        }
        enum envmon {
          tailf:info "Allow environmental monitor traps";
        }
        enum ethernet-cfm {
          tailf:info "Allow SNMP Ethernet CFM traps";
        }
        enum evc {
          tailf:info "Allow SNMP EVC traps";
        }
        enum event-manager {
          tailf:info "Allow SNMP Embedded Event Manager traps";
        }
        enum firewall {
          tailf:info "Allow SNMP Firewall traps";
        }
        enum flash {
          tailf:info "Allow SNMP FLASH traps";
        }
        enum flowmon {
          tailf:info "Allow SNMP flow monitor notifications";
        }
        enum frame-relay {
          tailf:info "Allow SNMP frame-relay traps";
        }
        enum fru-ctrl {
          tailf:info "Allow entity FRU control traps";
        }
        enum gdoi {
          tailf:info "Allows gdoi traps";
        }
        enum hsrp {
          tailf:info "Allow SNMP HSRP traps";
        }
        enum iplocalpool {
          tailf:info "Allow SNMP IP Local Pool traps";
        }
        enum ipmulticast {
          tailf:info "Allow SNMP ipmulticast traps";
        }
        enum ipsec {
          tailf:info "Allow SNMP IPsec traps";
        }
        enum ipsla {
          tailf:info "Allow SNMP Host IP SLA traps";
        }
        enum isakmp {
          tailf:info "Allow SNMP ISAKMP traps";
        }
        enum isg-mib {
          tailf:info "Allow SNMP isgmib traps";
        }
        enum isis {
          tailf:info "Allow IS-IS traps";
        }
        enum l2tun-pseudowire-status {
          tailf:info "Allow SNMP L2 pseudowire status traps";
        }
        enum l2tun-session {
          tailf:info "Allow SNMP L2 session traps";
        }
        enum license {
          tailf:info "Allow license traps";
        }
        enum memory {
          tailf:info "Allow SNMP Mempool traps";
        }
        enum mpls-fast-reroute {
          tailf:info "Allow SNMP MPLS traffic engineering fast reroute traps";
        }
        enum mpls-ldp {
          tailf:info "Allow SNMP MPLS label distribution protocol traps";
        }
        enum mpls-traffic-eng {
          tailf:info "Allow SNMP MPLS traffic engineering traps";
        }
        enum mpls-vpn {
          tailf:info "Allow SNMP MPLS Virtual Private Network traps";
        }
        enum msdp {
          tailf:info "Allow SNMP MSDP traps";
        }
        enum mvpn {
          tailf:info "Allow Multicast Virtual Private Network traps";
        }
        enum nhrp {
          tailf:info "Allow SNMP NHRP traps";
        }
        enum ospf {
          tailf:info "Allow OSPF traps";
        }
        enum ospfv3 {
          tailf:info "Allow OSPFv3 traps";
        }
        enum pfr {
          tailf:info "Allow SNMP PfR traps";
        }
        enum pim {
          tailf:info "Allow SNMP PIM traps";
        }
        enum pw-vc {
          tailf:info "Allow SNMP Pseudowire VC traps";
        }
        enum resource-policy {
          tailf:info "Enable CISCO-ERM-MIB notifications";
        }
        enum rf {
          tailf:info "Allow all SNMP traps defined in CISCO-RF-MIB";
        }
        enum rsrb {
          tailf:info "Allow rsrb event traps";
        }
        enum rsvp {
          tailf:info "Allow RSVP flow change traps";
        }
        enum sdlc {
          tailf:info "Allow sdlc event traps";
        }
        enum sdllc {
          tailf:info "Allow sdllc event traps";
        }
        enum snmp {
          tailf:info "Allow SNMP-type notifications";
        }
        enum sonet {
          tailf:info "Allow SNMP SONET traps";
        }
        enum srp {
          tailf:info "Allow SRP protocol traps";
        }
        enum stun {
          tailf:info "Allow stun event traps";
        }
        enum syslog {
          tailf:info "Allow SNMP syslog traps";
        }
        enum trustsec-sxp {
          tailf:info "Allow SNMP CISCO-TRUSTSEC-SXP-MIB traps";
        }
        enum tty {
          tailf:info "Allow TCP connection traps";
        }
        enum udp-port {
          tailf:info "The notification host's UDP port number (default port "
            +"162)";
        }
        enum voice {
          tailf:info "Allow SNMP Voice traps";
        }
        enum vrfmib {
          tailf:info "Allow SNMP vrfmib traps";
        }
        enum vrrp {
          tailf:info "Allow SNMP vrrp traps";
        }
        enum x25 {
          tailf:info "Allow x25 event traps";
        }
      }
    }
  }

  // ip sla * / icmp-echo
  // ip sla * / udp-echo
  // ip sla * / udp-jitter
  grouping ip-sla-proto-grouping {

    // ip sla * / udp-jitter * / tos
    leaf tos {
      tailf:cli-break-sequence-commands;
      tailf:info "Type Of Service";
      type uint8 {
        tailf:info "<0-255>;;Type of Service Value";
      }
    }

    // ip sla * / udp-jitter * / verify-data
    leaf verify-data {
      tailf:info "Verify data";
      type empty;
    }

    // ip sla * / udp-jitter * / data-pattern
    leaf data-pattern {
      tailf:info "Data Pattern";
      type string {
        tailf:info "WORD;;Data Pattern in Hex";
        pattern "[a-fA-F0-9].*";
      }
    }

    // ip sla * / udp-jitter * / vrf
    leaf vrf {
      tailf:info "Configure IP SLAs for a VPN Routing/Forwarding instance";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      type string {
        tailf:info "WORD;;VRF name";
      }
    }

    // ip sla * / udp-jitter * / owner
    leaf owner {
      tailf:info "Owner of Entry";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Owner String";
      }
    }

    // ip sla * / udp-jitter * / tag
    leaf tag {
      tailf:info "User defined tag";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Tag string";
      }
    }

    // ip sla * / udp-jitter * / frequency
    leaf frequency {
      tailf:info "Frequency of an operation";
      type uint32 {
        tailf:info "<1-604800>;;Frequency in seconds (default 60)";
        range "1..604800";
      }
      default 60;
    }

    // ip sla * / udp-jitter * / timeout
    leaf timeout {
      tailf:info "Timeout of an operation";
      type uint32 {
        tailf:info "<0-604800000>;;Timeout in milliseconds";
        range "0..604800000";
      }
    }

    // ip sla * / udp-jitter * / threshold
    leaf threshold {
      tailf:info "Operation threshold in milliseconds";
      type uint16 {
        tailf:info "<0-60000>;;Millisecond threshold value";
        range "0..60000";
      }
    }

    // ip sla * / udp-jitter * / history
    container history {
      tailf:info "History and Distribution Data";
      // ip sla * / udp-jitter * / history hours-of-statistics-kept
      leaf hours-of-statistics-kept {
        tailf:info "Maximum number of statistics hour groups to capture";
        type uint8 {
          tailf:info "<0-25>;;Hour groups size value (default 2)";
          range "0..25";
        }
        default 2;
      }
      // ip sla * / udp-jitter * / history distributions-of-statistics-kept
      leaf distributions-of-statistics-kept {
        tailf:info "Maximum number of statistics distribution buckets to capture";
        type uint8 {
          tailf:info "<1-20>;;Distribution bucket size value (default 1)";
          range "1..20";
        }
        default 1;
      }
      // ip sla * / udp-jitter * / history statistics-distribution-interval
      leaf statistics-distribution-interval {
        tailf:info "Statistics distribution interval size";
        type uint8 {
          tailf:info "<1-100>;;Distribution interval value (default 20)";
          range "1..100";
        }
        default 20;
      }
      // ip sla * / udp-jitter * / history lives-kept
      leaf lives-kept {
        tailf:info "Maximum number of history lives to collect";
        type uint8 {
          tailf:info "<0-2>;;Life size value (default 0)";
          range "0..2";
        }
        default 0;
      }
      // ip sla * / udp-jitter * / history buckets-kept
      leaf buckets-kept {
        tailf:info "Maximum number of history buckets to collect";
        type uint8 {
          tailf:info "<1-60>;;Bucket size value (default 15)";
          range "1..60";
        }
        default 15;
      }
      // ip sla * / udp-jitter * / history filter
      leaf filter {
        tailf:info "Add operation to History when...";
        type enumeration {
          enum all {
            tailf:info "Collect every operation in History";
          }
          enum failures {
            tailf:info "Collect operations that fail in History";
          }
          enum none {
            tailf:info "Shutoff History collection";
          }
          enum overThreshold {
            tailf:info "Collect operations that are over threshold in History";
          }
        }
      }
      // ip sla * / udp-jitter * / history enhanced
      container enhanced {
        tailf:info "Enable enhanced history collection";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf interval {
          tailf:info "Aggregation interval";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-3600>;;Interval in seconds";
            range "1..3600";
          }
        }
        leaf buckets {
          tailf:info "Number of buckets to collect data";
          type uint8 {
            tailf:info "<1-100>;;Number of buckets";
            range "1..100";
          }
        }
      }
    }
  }

  // aaa authentication login *
  grouping aaa-authentication-method-grouping {

    // aaa authentication login * cache
    leaf cache {
      tailf:info "Use Cached-group";
      type aaa-group-type;
    }

    // aaa authentication login * group
    leaf group {
      tailf:info "Use Server-group";
      type aaa-group-type;
    }

    // aaa authentication login * krb5
    leaf krb5 {
      tailf:info "Use Kerberos 5 authentication.";
      type empty;
    }

    // aaa authentication login * local
    leaf local {
      tailf:info "Use local username authentication.";
      type empty;
    }

    // aaa authentication login * line
    leaf line {
      tailf:info "Use line password for authentication.";
      type empty;
    }

    // aaa authentication login * enable
    leaf enable {
      tailf:info "Use enable password for authentication.";
      type empty;
    }

    // aaa authentication login * none
    leaf none {
      tailf:info "NO authentication.";
      tailf:cli-full-command;
      type empty;
    }
  }

  // aaa authorization exec *
  // aaa authorization commands *
  // aaa authorization eventmanager *
  // aaa authorization network *
  grouping aaa-authorization-method-grouping {

    // aaa authorization exec * cache
    leaf cache {
      tailf:info "Use Cached-group";
      type aaa-group-type;
    }

    // aaa authorization exec * group
    leaf group {
      tailf:info "Use server-group.";
      type aaa-group-type;
    }

    // aaa authorization exec * krb5-instance
    leaf krb5-instance {
      tailf:info "Use Kerberos instance privilege maps.";
      type empty;
    }

    // aaa authorization exec * if-authenticated
    leaf if-authenticated {
      tailf:info "Succeed if user has authenticated.";
      type empty;
    }

    // aaa authorization exec * local
    leaf local {
      tailf:info "Use local database.";
      type empty;
    }

    // aaa authorization exec * none
    leaf none {
      tailf:info "No authorization (always succeeds).";
      tailf:cli-full-command;
      type empty;
    }
  }

  // aaa accounting exec *
  // aaa accounting commands *
  grouping aaa-accounting-method-grouping {

    // aaa accounting exec * none
    // aaa accounting exec * start-stop
    // aaa accounting exec * stop-only
    leaf action-type {
      tailf:cli-drop-node-name;
      type enumeration {
        enum none {
          tailf:info "No accounting.";
        }
        enum start-stop  {
          tailf:info "Record start and stop without waiting";
        }
        enum stop-only {
          tailf:info "Record stop when service terminates.";
        }
      }
    }

    // aaa accounting exec * broadcast
    leaf broadcast {
      tailf:info "Use Broadcast for Accounting";
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type empty;
    }

    // aaa accounting exec * group
    leaf group {
      tailf:info "Use Server-group";
      type aaa-group-type;
    }
  }

  // cable modulation-profile *
  grouping cable-modulation-profile-grouping {
    leaf fec-tbytes {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-16>;;FEC tbytes";
      }
    }
    leaf fec-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<16-253>;;FEC codeword length in k bytes";
      }
    }
    leaf burst-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-255>;;max burst size in minislots";
      }
    }
    leaf guard-t {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-255>;;guard time in symbols";
      }
    }
    leaf mod {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "8qam" {
          tailf:info "8-QAM modulation";
        }
        enum "16qam" {
          tailf:info "16-QAM modulation";
        }
        enum "32qam" {
          tailf:info "32-QAM modulation";
        }
        enum "64qam" {
          tailf:info "64-QAM modulation";
        }
        enum "qpsk" {
          tailf:info "qpsk modulation";
        }
      }
    }
    leaf scrambler {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum no-scrambler {
          tailf:info "scrambler disabled";
        }
        enum scrambler {
          tailf:info "scrambler enabled";
        }
      }
    }
    leaf seed {
      when "../scrambler = 'scrambler'" {
        tailf:dependency "../scrambler";
      }
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type string {
        tailf:info "<0x0-0x7FFF>;;scrambler seed in hex";
      }
    }
    leaf diff {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum diff {
          tailf:info "diff encoding enabled";
        }
        enum no-diff {
          tailf:info "diff encoding disabled";
        }
      }
    }
    leaf pre-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<4-1536>;;preamble length in bits";
      }
    }
    leaf last-cw {
      tailf:cli-drop-node-name;
      type enumeration {
        enum fixed {
          tailf:info "fixed codeword";
        }
        enum shortened {
          tailf:info "shortened codeword";
        }
      }
    }
    leaf preamble {
      tailf:cli-drop-node-name;
      type enumeration {
        enum qpsk0 {
          tailf:info "QPSK0 preamble";
        }
        enum qpsk1 {
          tailf:info "QPSK1 preamble";
        }
      }
    }
    leaf rs-interleave-depth {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-114>;;RS interleave depth";
      }
    }
    leaf rs-interleave-block {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<18-2048>;;RS interleave block size";
      }
    }
  }

  // cable load-balance docsis-group *
  // cable load-balance docsis-group FN *
  grouping cable-load-balance-docsis-group-grouping {

    // cable load-balance docsis-group * / restricted
    leaf restricted {
      tailf:info "Set load balance group as restricted";
      type empty;
    }

    // cable load-balance docsis-group * / downstream
    container downstream {
      tailf:info "Set downstream RF channels";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf Modular-Cable {
        tailf:info "Modular cable";
        tailf:cli-incomplete-command;
        type string {
          tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
        }
      }
      leaf rf-channel {
        tailf:info "RF channel";
        type string {
          tailf:info "<grouplist>;;List of port numbers and number ranges";
        }
      }
    }

    // cable load-balance docsis-group * / upstream
    container upstream {
      tailf:info "Set upstream channels";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-incomplete-command;
        type string {
          tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/port";
        }
      }
      leaf upstream-list {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<grouplist>;;List of Ranges for upstream channels <0-7>";
        }
      }
    }

    // cable load-balance docsis-group * / method
    container method {
      tailf:info "Set load balancing type/method";
      container utilization {
        tailf:info "Interface utilization";
        presence true;
      }
    }

    // cable load-balance docsis-group * / threshold
    container threshold {
      tailf:info "Load balancing threshold in %";

      // cable load-balance docsis-group * / threshold load
      container load {
        tailf:info "Interface load threshold settings";
        leaf percentage {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;Threshold value in %";
            range "1..100";
          }
        }
        // cable load-balance docsis-group * / threshold load minimum
        leaf minimum {
          tailf:info "Set minimum number of modems/flows difference "+
            "before loadbalancing starts";
          type uint8 {
            tailf:info "<1-100>;;Minimum number of modems/flows";
            range "1..100";
          }
        }
      }

      // cable load-balance docsis-group * / threshold stability
      leaf stability {
        tailf:info "Threshold for stability detection";
        type uint8 {
          tailf:info "<0-100>;;Stability condition detection threshold in %";
          range "0..100";
        }
      }
    }

    // cable load-balance docsis-group * / policy
    leaf policy {
      tailf:info "Set load balancing policy";
      type enumeration {
        tailf:info "pure-ds-load;;Do not count US load when calculating "+
          "DS utilization";
        enum pcmm {
          tailf:info "Enable balancing of modems with active PCMM service "+
            "flows";
        }
        enum pure-ds-load {
          tailf:info "Do not count US load when calculating DS utilization";
        }
        enum ugs {
          tailf:info "Enable balancing of modems with active UGS service "+
            "flows";
        }
        enum us-across-ds {
          tailf:info "Load balancing on US groups across DS, DS method will "+
            "be ignored";
        }
      }
    }

    // cable load-balance docsis-group * / interval
    leaf interval {
      tailf:info "Set interface polling interval";
      type uint16 {
        tailf:info "<1-1000>;;Interface polling interval in seconds";
        range "1..1000";
      }
    }

    // cable load-balance docsis-group * / init-tech-list
    container init-tech-list {
      tailf:info "Set DCC initialization technique list";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf grouplist {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<grouplist> ";
        }
      }
      leaf ucc {
        tailf:info "Allow the use of UCC in upstream load balancing";
        type empty;
      }
    }

    // cable load-balance docsis-group * / docsis-policy
    leaf docsis-policy {
      tailf:info "Enter load balance group policy";
      type uint32 {
        tailf:info "<0-4294967295>;;Load balance group policy number";
        range "0..4294967295";
      }
    }

    // cable load-balance docsis-group * / tag *
    list tag {
      tailf:info "Add tag to load balancing group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;tag name";
        }
      }
    }
  }

  // facility-alarm outlet-temperature
  grouping facility-alarm-grouping {

    // facility-alarm outlet-temperature major
    container major {
      tailf:info "Major warning threshold";
      leaf temperature {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<20-100>;;<##> threshold temperature (degrees C)";
          range "20..100";
        }
      }
    }

    // facility-alarm outlet-temperature minor
    container minor {
      tailf:info "Minor warning threshold";
      leaf temperature {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<20-100>;;<##> threshold temperature (degrees C)";
          range "20..100";
        }
      }
    }

    // facility-alarm outlet-temperature critical
    container critical {
      tailf:info "Critical warning threshold";

      // facility-alarm outlet-temperature critical exceed-action shutdown
      leaf exceed-action {
        tailf:info "Critical outlet temperature exceed action";
        tailf:cli-full-command;
        type enumeration {
          enum shutdown {
            tailf:info "Auto-shutdown when critical outlet temperature "+
              "is exceeded";
          }
        }
      }

      // facility-alarm outlet-temperature critical
      leaf temperature {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;<##> threshold temperature (degrees C)";
          range "1..255";
        }
      }
    }
  }

  // process cpu threshold type total
  // process cpu threshold type interrupt
  // process cpu threshold type process
  grouping process-cpu-threshold-grouping {
    leaf rising {
      tailf:info "rising threshold";
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-100>";
        range "1..100";
      }
    }
    leaf interval {
      tailf:info "observation interval";
      type uint32 {
        tailf:info "<5-86400>";
        range "5..86400";
      }
    }
    leaf falling {
      tailf:info "falling threshold ";
      type uint8 {
        tailf:info "<1-100>";
        range "1..100";
      }
    }
    container falling-interval {
      tailf:cli-flatten-container;
      tailf:cli-drop-node-name;
      leaf interval {
        tailf:info "observation interval";
        type uint32 {
          tailf:info "<5-86400>";
          range "5..86400";
        }
      }
    }
  }

  // cable submgmt default filter-group cm
  // cable submgmt default filter-group cpe
  // cable submgmt default filter-group mta
  // cable submgmt default filter-group stb
  // cable submgmt default filter-group ps
  grouping cable-submgmt-default-filter-group-grouping {
    leaf upstream {
      tailf:info "Default Upstream Group";
      type uint8 {
        tailf:info "<1-254>;;Group ID";
        range "1..254";
      }
    }
    leaf downstream {
      tailf:info "Default Downstream Group";
      type uint8 {
        tailf:info "<1-254>;;Group ID";
        range "1..254";
      }
    }
  }

  // interface * / storm-control broadcast level
  // interface * / storm-control multicast level
  // interface * / storm-control unicast level
  grouping storm-control-level-bps-pps-grouping {
    container level-bps-pps {
      tailf:cli-drop-node-name;
      container level {
        tailf:info "Set storm suppression level on this interface";
        choice level-choice {
          leaf bps {
            tailf:info "Enter suppression level in bits per second";
            type string {
              tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter rising threshold";
            }
          }
          leaf pps {
            tailf:info "Enter suppression level in packets per second";
            type string {
              tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter rising threshold";
            }
          }
        }
      }
    }
  }

  // service-group * / service-policy
  // control-plane service-policy
  // interface * / service-policy
  // interface pseudowire * / service-policy
  grouping service-policy-grouping {
    leaf "input" {
      tailf:info "Assign input policy-map";
      type string {
        tailf:info "WORD;;input Policy-map name";
      }
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
    }
    leaf "output" {
      tailf:info "Assign output policy-map";
      type string {
        tailf:info "WORD;;output Policy-map name";
      }
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// upgrade
  /// ========================================================================

  container upgrade {
    tailf:info "Global upgrade configuration subcommands";

    // upgrade fpd
    container fpd {
      tailf:info "Configure field programmable devices upgrade options";
      // upgrade fpd auto
      leaf auto {
        tailf:info "Auto upgrade all FPD images";
        type empty;
      }
      // upgrade fpd path
      leaf "path" {
        tailf:info "Set path to locate the FPD image package file for auto "+
          "upgrade";
        type string;
      }
    }
  }


  /// ========================================================================
  /// tailfned
  /// ========================================================================
  /// TAILF NED device info used for device specific support.

  container tailfned {

    // tailfned device
    leaf device {
      tailf:cli-no-value-on-delete;
      tailf:cli-suppress-no;
      type string;
    }

    // tailfned police
    leaf police {
      tailf:cli-no-value-on-delete;
      tailf:cli-suppress-no;
      type string {
        tailf:info "cirmode | bpsflat | numflat | cirflat";
      }
    }

  }


  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "Version";
    type string {
      tailf:info "WORD;;Version number";
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";

    // service config
    leaf "config" {
      tailf:info "TFTP load config files";
      tailf:cli-full-command;
      type empty;
    }

    // service exec-callback
    leaf exec-callback {
      tailf:info "Enable exec callback";
      tailf:cli-full-command;
      type empty;
    }

    // service nagle
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      tailf:cli-full-command;
      type empty;
    }

    // no service slave-log
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service pad cmns
    // service pad from-xot
    // service pad to-xot
    container pad {
      tailf:info "Enable PAD commands";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        tailf:cli-full-command;
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        tailf:cli-full-command;
        type empty;
      }
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        tailf:cli-full-command;
        type empty;
      }
    }

    // no service pad
    container conf {
      tailf:cli-drop-node-name;
      leaf pad {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // service tcp-keepalives-in
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service tcp-keepalives-out
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;

      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";

        choice timestamp-choice {
          // service timestamps debug uptime
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
          // service timestamps debug datetime
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";

        choice timestamp-choice {
          // service timestamps log uptime
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
          // service timestamps log datetime
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
        }
      }
    }

    // service password-encryption
    container password-encryption {
      tailf:info "Encrypt system passwords";
      tailf:cli-show-no;
      presence true;
    }

    // service exec-wait
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      tailf:cli-full-command;
      type empty;
    }

    // service linenumber
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      tailf:cli-full-command;
      type empty;
    }

    // service compress-config
    leaf compress-config {
      tailf:info "Compress the configuration file";
      tailf:cli-full-command;
      type empty;
    }

    // service udp-small-servers
    leaf udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      tailf:cli-full-command;
      type empty;
    }

    // service tcp-small-servers
    leaf tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      tailf:cli-full-command;
      type empty;
    }

    // service old-slip-prompts
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      tailf:cli-full-command;
      type empty;
    }

    // service pt-vty-logging
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      tailf:cli-full-command;
      type empty;
    }

    // service disable-ip-fast-frag
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      tailf:cli-full-command;
      type empty;
    }

    // service sequence-numbers
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      tailf:cli-full-command;
      type empty;
    }

    // service divert-rate-limit
    container divert-rate-limit {
      tailf:info "Set WAN-side divert-rate-limit parameters";

      // service divert-rate-limit ip *
      list ip {
        tailf:info "WAN-IPv4 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key divert-code;
        leaf divert-code {
          type string {
            tailf:info "WORD;;divert code";
          }
        }
        leaf rate {
          tailf:info "rate in packets/sec";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;rate in packets/second";
          }
        }
        leaf limit {
          tailf:info "limit in packets";
          type uint16 {
            tailf:info "<4-4194>;;limit in packets";
            range "4..4194";
          }
        }
      }

      // service divert-rate-limit ipv6 *
      list ipv6 {
        tailf:info "WAN-IPv6 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key divert-code;
        leaf divert-code {
          type string {
            tailf:info "WORD;;divert code";
          }
        }
        leaf rate {
          tailf:info "rate in packets/sec";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;rate in packets/second";
          }
        }
        leaf limit {
          tailf:info "limit in packets";
          type uint16 {
            tailf:info "<4-4194>;;limit in packets";
            range "4..4194";
          }
        }
      }

      // service divert-rate-limit trusted-site *
      list trusted-site {
        tailf:info "trusted-site configuration for WAN-IPv4";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip-address mask-ip-address tos mask";
        max-elements 4;
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;source IP address";
          }
        }
        leaf mask-ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP prefix mask";
          }
        }
        leaf tos {
          tailf:info "ToS value";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;ToS value";
          }
        }
        leaf mask {
          tailf:info "ToS mask";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;ToS mask";
          }
        }
        // [ global | vrf vrf-name ]
      }

      // service divert-rate-limit trusted-site-ipv6 *
      list trusted-site-ipv6 {
        tailf:info "trusted-site configuration for WAN-IPv6";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip-address traffic-class mask";
        max-elements 4;
        leaf ip-address {
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 Source address/Prefix length."+
              "(e.g., 1234::1/<prefix-length>)";
          }
        }
        leaf traffic-class {
          tailf:info "traffic-class value";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;traffic-class value";
          }
        }
        leaf mask {
          tailf:info "traffic-class mask";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;traffic-class mask";
          }
        }
        // [ global | vrf vrf-name ]
      }
    }

    // service counters
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";
        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds";
            range "0..60";
          }
        }
      }
    }

    // service alignment
    container alignment {
      tailf:info "Control alignment correction and logging";
      // no service alignment detection
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // no service alignment logging
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // service call-home
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }

    // no service dhcp
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service finger
    leaf finger {
      tailf:info "Allow responses to finger requests";
      tailf:cli-full-command;
      type empty;
    }

    // service heartbeat
    container heartbeat {
      tailf:info "Enable heartbeat processing";
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
          range "1..60";
        }
      }
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          tailf:info "<0-60>;;Interval between interrupt level tests";
          range "0..60";
        }
      }
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
          range "5..60";
        }
      }
    }

    // service hide-telnet-addresses
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      tailf:cli-full-command;
      type empty;
    }

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:info "";
      tailf:cli-full-command;
      type empty;
    }

    // service internal
    leaf internal {
      // Note: allow additional control of the LTE modem
      type empty;
    }
  }


  /// ========================================================================
  /// cdp
  /// ========================================================================
  // Must be before interface * / cdp enable

  container cdp {
    tailf:info "Global CDP configuration subcommands";

    // no cdp run
    leaf run {
      tailf:info "Enable CDP";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  list platform {
    tailf:info "platform specific configuration";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    ordered-by user;
    key name;
    leaf name {
      tailf:cli-multi-word-key;
      type string {
        tailf:info "Full path to platform variable";
      }
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "This system's network name";
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================
  // Note: /vrf must be before /ip and /ipv6

  container vrf {
    tailf:info "VRF commands";

    // vrf definition *
    list definition {
      tailf:info "VRF definition mode";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-vrf";
      ////tailf:callpoint vrf-definition-hook { tailf:set-hook node; }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // vrf definition * / description
      leaf "description" {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }

      // vrf definition * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type rd-type;
      }

      // vrf definition * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        uses vrf-route-target-grouping;
      }

      // vrf definition * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // vrf definition * / address-family ipv4
        container ipv4 {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-af";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-full-command;
          presence true;
          uses vrf-definition-af-grouping;

          // vrf definition * / address-family ipv4 / mdt
          container mdt {
            tailf:info "Backbone Multicast Distribution Tree";

            // vrf definition * / address-family ipv4 / mdt default
            container "default" {
              tailf:info "The default group";
              leaf address {
                // Note: when set, mdt/data & mdt/log-reuse should be deleted
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP multicast group address";
                }
              }
              container mpls {
                tailf:info "MPLS tunnel options";
                leaf mldp {
                  tailf:info "Use a MLDP LSP to create the default MDT";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;MP2MP LSP root address";
                  }
                }
              }
            }

            // vrf definition * / address-family ipv4 / mdt data
            container data {
              tailf:info "MDT data trees";
              list multicast {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "address wildcard";
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP multicast group address";
                  }
                }
                leaf wildcard {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Wildcard bits";
                  }
                }
              }
              leaf "list" {
                tailf:info "Access-list";
                type ext-acl-type;
              }
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in kilobits per second";
                }
              }
            }

            // vrf definition * / address-family ipv4 / mdt log-reuse
            leaf log-reuse {
              tailf:info "Event logging for data MDT reuse";
              type empty;
            }

            // vrf definition * / address-family ipv4 / mdt preference
            leaf-list preference {
              tailf:info "MDT preference (default pim mldp)";
              tailf:cli-flat-list-syntax {
                tailf:cli-replace-all;
              }
              type enumeration {
                enum mldp {
                  tailf:info "MDT preference mLDP";
                }
                enum pim {
                  tailf:info "MDT preference PIM";
                }
              }
            }
          }
        }

        // vrf definition * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-af";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-full-command;
          presence true;
          uses vrf-definition-af-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// security
  /// ========================================================================

  // security passwords min-length
  container security {
    tailf:info "Infra Security CLIs";
    container passwords {
      tailf:info "Password security CLIs";
      leaf min-length {
        tailf:info "Minimum length of passwords";
        type uint8 {
          tailf:info "<0-16>;;Minimum length of all user/enable passwords";
          range "0..16";
        }
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";

    // enable password
    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses password-07-grouping;

      // enable password level *
      list level {
        tailf:info "Set exec level password";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          type uint8 {
            tailf:info "<1-15>;;Level number";
          }
        }
        uses password-07-grouping;
      }
    }

    // enable last-resort
    leaf last-resort {
      tailf:info "Define enable action if no TACACS servers respond";
      tailf:cli-full-command;
      type enumeration {
        enum password {
          tailf:info "Enable by giving the local enable password";
        }
        enum succeed {
          tailf:info "Enable without further question";
        }
      }
    }

    // enable secret
    container secret {
      tailf:info "Assign the privileged level secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf level {
        tailf:info "Set exec level password";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<1-15>;;Level number";
        }
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "4" {
            //FIXME what type of secret is this?
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) 'enable' secret";
        }
      }
    }

    // enable use-tacacs
    leaf use-tacacs {
      tailf:info "Use TACACS to check enable passwords";
      tailf:cli-full-command;
      type empty;
    }

  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-incomplete-command;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions."+
        "(Disables OLD commands.)";
      type empty;
    }

    // aaa group
    container group {
      tailf:info "AAA group definitions";
      tailf:cli-diff-dependency "../new-model";

      // aaa group server
      container server {
        tailf:info "AAA Server group definitions";

        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }
          // aaa group server radius * / server
          container server {
            tailf:info "Specify a RADIUS server";
            // aaa group server radius * / server name
            list name {
              tailf:info "Name of radius server";
              tailf:cli-suppress-mode;
              key name;
              leaf name {
                type string;
                tailf:non-strict-leafref {
                  path "/ios:aaa/group/server/radius/name";
                }
              }
            }
            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-suppress-mode;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                }
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server "+
                  "(default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server "+
                  "(default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }
          container ip {
            tailf:info "Internet Protocol config commands";
            container radius {
              tailf:info "RADIUS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in RADIUS "
                  +"packets";
                uses interface-name-grouping;
              }
            }
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "/ios:ip/vrf";
                tailf:cli-diff-dependency "/ios:vrf/definition";
                type string {
                  tailf:info "WORD;;Table name";
                }
              }
            }
          }
        }

        // aaa group server tacacs+ *
        list "tacacsplus" {
          tailf:alt-name "tacacs+";
          tailf:info "Tacacs+ server-group definition";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }
          list server-private {
            tailf:info "Define a private TACACS server (per group)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            key name;
            leaf name {
              type host-type {
                tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
              }
            }
            leaf timeout {
              tailf:info "Time to wait for this TACACS server to reply "+
                "(overrides default)";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<1-1000>;;Timeout value in seconds to wait "+
                  "for server to reply";
                range "1..1000";
              }
            }
            container "key" {
              tailf:info "per-server encryption key (overrides default)";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf encryption {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                tailf:cli-optional-in-sequence;
                type enumeration {
                  enum "0" {
                    tailf:info "Specifies an UNENCRYPTED key will follow";
                  }
                  enum "7" {
                    tailf:info "Specifies HIDDEN key will follow";
                  }
                }
              }
              leaf key {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-multi-value;
                type string {
                  tailf:info "LINE;;The UNENCRYPTED (cleartext) shared key";
                }
              }
            }
          }
          container ip {
            tailf:info "Internet Protocol config commands";
            container tacacs {
              tailf:info "TACACS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in "+
                  "TACACS packets";
                uses interface-name-grouping;
              }
            }
          }
        }

      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";
      tailf:cli-diff-dependency "../new-model";

      // aaa authentication dot1x *
      list dot1x {
        tailf:info "Set authentication lists for IEEE 802.1x.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        leaf cache {
          tailf:info "Use Cached-group";
          type aaa-group-type;
        }
        leaf group {
          tailf:info "Use Server-group";
          type aaa-group-type;
        }
      }

      // aaa authentication login *
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }

      // aaa authentication enable
      container enable {
        tailf:info "Set authentication list for enable.";
        container "default" {
          tailf:info "The default authentication list.";
          tailf:cli-compact-syntax;
          leaf cache {
            tailf:info "Use Cached-group";
            type aaa-group-type;
          }
          leaf group {
            tailf:info "Use Server-group";
            type aaa-group-type;
          }
          leaf line {
            tailf:info "Use line password for authentication.";
            type empty;
          }
          leaf enable {
            tailf:info "Use enable password for authentication.";
            type empty;
          }
          leaf none {
            tailf:info "No authentication.";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // aaa authentication ppp *
      list ppp {
        tailf:info "Set authentication lists for ppp.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
            type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../new-model";

      // aaa authorization console
      leaf console {
        tailf:info "For enabling console authorization";
        type empty;
      }

      // aaa authorization config-commands
      leaf config-commands {
        tailf:info "For configuration mode commands.";
        type empty;
      }

      // aaa authorization exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key "level name";
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization eventmanager *
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../new-model";

      //FIXME: accounting accepts another version where you set
      //       leafs in submode as well.
      //tailf:cli-mode-name "cfg-acct-mlist";

      // aaa accounting commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "level name";
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting connection *
      list connection {
        tailf:info "For outbound connections. (telnet, rlogin)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting system default
      container system {
        tailf:info "For system events.";
        container "default" {
          tailf:cli-add-mode;
          tailf:cli-mode-name "cfg-acct-mlist";
          tailf:cli-delete-when-empty;
          presence true;
          uses aaa-accounting-method-grouping;
        }
      }

      // aaa accounting suppress
      container suppress {
        tailf:info "Do not generate accounting records "+
          "for a specific type of user.";
        leaf null-username {
          tailf:info "Do not generate accounting records for users "+
            "with a null-username";
          type empty;
        }
      }

      // aaa accounting update periodic
      container update {
        tailf:info "Enable accounting update records.";
        leaf periodic {
          tailf:info "Send accounting update records at regular intervals.";
          type uint32 {
            tailf:info "<1-71582>;;Periodic intervals to send accounting "+
              "update records(in minutes)";
            range "1..71582";
          }
        }
      }

    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-diff-dependency "../new-model";
      type enumeration {
        enum common {
          tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }

    // aaa attribute list *
    container attribute {
      tailf:info "AAA attribute definitions";
      list "list" {
        tailf:info "AAA attribute list definition";
        tailf:cli-mode-name "config-attr-list";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;name";
          }
        }

        // aaa attribute list * / attribute type interface-config
        container attribute {
          tailf:info "Specify an AAA attribute";
          container "type" {
            tailf:info " Specify an AAA attribute type";
            leaf interface-config {
              tailf:info "Configuration commands for an interface";
              type string {
                tailf:info "WORD;;string";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {
    tailf:info "Configure time-of-day clock";

    // clock timezone
    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;name of time zone";
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum +;
          enum -;
        }
      }
      leaf hours {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<-23 - 23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<0-59>;;Minutes ofset from UTC";
          range "0..59";
        }
      }
    }

    // clock summer-time
    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "date|recurring";
        type string {
          tailf:info "WORD;;name of time zone in summer";
        }
      }
      choice summer-choice {
        case date-case {
          leaf date {
            tailf:info "Configure absolute summer time";
            type empty;
          }
        }
        case recurring-case {
          leaf recurring {
            tailf:info "Configure recurring summer time";
            type empty;
          }
          leaf start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to start";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to start";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf end {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to end";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf end-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to end";
            }
          }
          leaf end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
        }
      }
    }

    // clock calendar-valid
    container calendar-valid {
      tailf:info "Calendar time is authoritative";
      presence true;
    }

  }


  /// ========================================================================
  /// facility-alarm
  /// ========================================================================

  container facility-alarm {
    tailf:info "Alarm thresholds configuration";

    // facility-alarm core-temperature
    container core-temperature {
      tailf:info "Threshold for processor module temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm outlet-temperature
    container outlet-temperature {
      tailf:info "Threshold for air outlet temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm intake-temperature
    container intake-temperature {
      tailf:info "Threshold for air inlet temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm critical exceed-action shutdown
    container critical {
      tailf:info "Behavior on critical threshold exceed";
      leaf exceed-action {
        tailf:info "Behavior on critical threshold exceed";
        type enumeration {
          enum shutdown {
            tailf:info "Behavior on critical threshold exceed";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cef
  /// ========================================================================

  container cef {
    tailf:info "Cisco Express Forwarding";
    container table {
      tailf:info "Set CEF forwarding table characteristics";
      container output-chain {
        tailf:info "Set table output chain characteristics";
        container build {
          tailf:info "Set table output chain building characteristics";

          // cef table output-chain build favor
          leaf favor {
            tailf:info "Set which table output chain building "+
              "characteristics to favor";
            type enumeration {
              enum convergence-speed {
                tailf:info "Favor faster convergence";
              }
              enum memory-utilization {
                tailf:info "Favor smaller memory utilization";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ipdr
  /// ========================================================================

  container ipdr {
    tailf:info "IPDR Configuration";

    // ipdr session *
    list session {
      tailf:info "IPDR session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf session-name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;IPDR session name";
        }
      }
      leaf session-descr {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;IPDR session description";
        }
      }
    }

    // ipdr type *
    list "type" {
      tailf:info "IPDR session type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      choice type-choice {
        leaf ad-hoc {
          tailf:info "Ad-hoc type session";
          type empty;
        }
        leaf event {
          tailf:info "Event type session";
          type empty;
        }
        leaf time-interval {
          tailf:info "Time interval type session";
          type uint16 {
            tailf:info "<15-1440>;;Interval in minute";
          }
        }
      }
    }

    // ipdr collector *
    list collector {
      tailf:info "IPDR collector";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;IPDR collector name string";
         }
      }
      leaf ip-addr {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPDR collector ip address";
        }
      }
      leaf port {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;IPDR collector port";
          range "1..65535";
        }
      }
    }

    // ipdr associate *
    list associate {
      tailf:info "IPDR collector to session association";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf collector-name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;IPDR collector name";
         }
      }
      leaf priority {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Priority of the collector in session, "+
            "lower number is higher priority";
          range "1..10";
        }
      }
    }

    // ipdr template *
    list template {
      tailf:info "IPDR template";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf template-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // ipdr exporter
    container exporter {
      tailf:info "IPDR exporter";

      // ipdr exporter start
      leaf start {
        tailf:info "start IPDR exporter";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// card
  /// ========================================================================

  container card {
    tailf:info "Configure card type";

    // card * 4jacket-1
    // Note: Cisco 10000
    list card-slot {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "slot card-type";
      leaf slot {
        type uint8 {
          tailf:info "<1-3>;;Enter odd slot";
          range "1|3";
        }
      }
      leaf card-type {
        type enumeration {
          enum "4jacket-1" {
            tailf:info "create a 4jacket-1 cardtype";
          }
        }
      }
    }

    // card *
    // Note: Cisco 10000
    list card-slot-subslot {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "slot-subslot card-type";
      leaf slot-subslot {
        type string {
          tailf:info "<1-8>/<0-3>;;Enter slot/subslot "+
            "(subslot 2 and 3 is for SPA only)";
          pattern "[1-8]/[0-3]";
        }
      }
      leaf card-type {
        type enumeration {
          enum "24rfchannel-spa-1" {
            tailf:info "create a Wideband DOCSIS SPA";
          }
          enum "2cable-dtcc" {
            tailf:info "Utility Card w/DTI (EightBells)";
          }
          enum "2cable-tccplus" {
            tailf:info "Utility Card";
          }
          enum SPA-1XTENGE-XFP-V2 {
            tailf:info "create a 10GE SPA 1 PORT cardtype";
          }
          enum SPA-2X1GE-V2 {
            tailf:info "create a GE SPA 2 PORT cardtype";
          }
          enum SPA-5X1GE-V2 {
            tailf:info "create a GE SPA 5 PORT cardtype";
          }
          enum SPA-8X1GE-V2 {
            tailf:info "create a GE SPA 8 PORT cardtype";
          }
          enum SPA-DOCSIS-HD-V1 {
            tailf:info "create a High Density DOCSIS SPA";
          }
          enum ubr10k-clc-3g60 {
            tailf:info "create a uBR10000 line card with MC3Gx60";
          }
          enum ubr10k-clc-mc2020v {
            tailf:info "create a uBR10000 line card with MC20x20";
          }
        }
      }
      leaf SPA-DOCSIS-HD-V1-port {
        when "../card-type = 'SPA-DOCSIS-HD-V1'";
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1x10GE" {
            tailf:info "using 1x10GE port";
          }
          enum "3x1GE" {
            tailf:info "using 3x1GE port";
          }
        }
      }
      leaf license {
        tailf:info "create a license for the line card";
        type string {
          tailf:info "WORD;;License string";
        }
      }
    }

    // card type
    container "type" {
      tailf:info "Configure card type";

      // card type t1 *
      list t1 {
        tailf:info "T1";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key slot;
        leaf slot {
          type uint8;
        }
      }
      container t1-bay {
        tailf:cli-drop-node-name;
        list t1 {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "slot bay";
          leaf slot {
            type uint8 {
              tailf:info "<0-2>;;Card slot number (always 0 "+
                "for 1800 series & 2801 routers)";
            }
          }
          leaf bay {
            type uint8 {
              tailf:info "<0-3>;;WIC slot number "+
                "(0:WIC, 1:Onboard for NM-HDV2)";
            }
          }
        }
      }

      // card type t3 *
      list t3 {
        tailf:info "T3";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key slot;
        leaf slot {
          type uint32;
        }
      }
    }

  }


  /// ========================================================================
  /// hw-module
  /// ========================================================================

  container hw-module {
    tailf:info "Slot/subslot/port level commands";

    // hw-module bay * shutdown
    list bay {
      tailf:info "Bay level commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;<1-3>/<0-3>";
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the target subslot";
        type empty;
      }
      choice power-choice {
        leaf powered {
          tailf:info "Hold the target subslot in reset";
          type empty;
        }
        leaf unpowered {
          tailf:info "Power-off the target subslot";
          type empty;
        }
      }
    }

  }


  /// ========================================================================
  /// cable
  /// ========================================================================

  container cable {
    tailf:info "Global cable configuration";

    // cable upstream
    container upstream {
      tailf:info "global upstream parameters";

      // cable upstream rate-adapt
      container rate-adapt {
        tailf:info "rate adapt";
        tailf:cli-compact-syntax;
        leaf priority {
          tailf:info "Configure priority to enable rate-adapt";
          type uint8 {
            tailf:info "<0-7>;;priority at or above enables rate-adapt.";
            range "0..7";
          }
        }
        leaf rate {
          tailf:info "Configure rate to enable rate-adapt";
          type uint32 {
            tailf:info "<0-30000000>;;rate at or above enables rate-adapt.";
            range "0..30000000";
          }
        }
        leaf local {
          tailf:info "Enable rate-adapt locally per upstream";
          type empty;
        }
      }
    }

    // cable admission-control preempt priority-voice
    // no cable admission-control preempt priority-voice
    container admission-control {
      tailf:info "Configure Cable Admission Control";
      container preempt {
        tailf:info "Reason for preemption";
        leaf priority-voice {
          tailf:info "Priority Voice call can preempt normal";
          tailf:cli-show-no;
          type empty;
        }
      }
    }

    // cable flap-list
    container flap-list {
      tailf:info "Cable flap-list configuration";

      // cable flap-list aging
      leaf aging {
        tailf:info "Flap-list aging";
        type uint32 {
          tailf:info "<1-86400>;;Maximum number of minutes the cable modem "+
            "is kept in the flap-list";
          range "1..86400";
        }
      }
    }

    // cable source-verify
    container source-verify {
      tailf:info "Source verify";

      // cable source-verify leasequery-filter downstream
      container leasequery-filter {
        tailf:info "Source verify Lease query filter";
        container downstream {
          tailf:info "Source verify Lease query filter for downstream pkts";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf threshold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Number of lease queries for unknown sid";
              range "0..255";
            }
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-10>;;size of time window in seconds";
              range "1..10";
            }
          }
        }
      }
    }

    // cable modem
    container modem {
      tailf:info "Modem polling using SNMP query";

      // cable modem remote-query
      container remote-query {
        tailf:info "Modem polling using SNMP query";

        // cable modem remote-query <interval> <community string>
        container gather {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf polling-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-86400>;;Periodic polling interval in seconds";
              range "1..86400";
            }
          }
          leaf community-string {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Community string ";
            }
          }
        }

        // cable modem remote-query src-ip
        leaf src-ip {
          tailf:info "source IP address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source IP addr";
          }
        }
      }

      // cable modem max-cpe
      leaf max-cpe {
        tailf:info "Max CPE override";
        type union {
          type uint8 {
            tailf:info "<1-255>;;Number";
          }
          type enumeration {
            enum unlimited {
              tailf:info "Max CPE not enforced";
            }
          }
        }
      }

      // cable modem v6-max-cpe-prefix
      leaf v6-max-cpe-prefix {
        tailf:info "Max CPE override";
        type uint16 {
          tailf:info "<0-1023>;;Number";
          range "0..1023";
        }
      }

      // cable modem vendor *
      list vendor {
        tailf:info "Cable modem vendor information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key oui;
        leaf oui {
          type string {
            tailf:info "WORD;;OUI of the vendor in the format "+
              "xx.xx.xx or xx:xx:xx";
          }
        }
        leaf vendor-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;Vendor name";
          }
        }
      }
    }

    // cable modulation-profile
    container modulation-profile {
      tailf:info "Modulation profile";

      // cable modulation-profile *
      list modulation-profile-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key profile;
        leaf profile {
          type string {
            tailf:info "WORD;;Modulation Profile Group";
          }
        }
        // cable modulation-profile * request
        container request {
          tailf:info "Request Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * initial
        container initial {
          tailf:info "Initial Ranging Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * station
        container station {
          tailf:info "Station Ranging Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * short
        container short {
          tailf:info "Short Grant Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * long
        container long {
          tailf:info "Long Grant Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * a-short
        container a-short {
          tailf:info "Advanced Phy Short Grant Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * a-long
        container a-long {
          tailf:info "Advanced Phy Long Grant Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
        // cable modulation-profile * a-ugs
        container a-ugs {
          tailf:info "Advanced Phy Unsolicited Grant Burst";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses cable-modulation-profile-grouping;
        }
      }
    }

    // cable tag *
    list tag {
      tailf:info "cable tag";
      tailf:cli-mode-name "config-cmts-tag";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-1000>;;The id of the tag";
          range "1..1000";
        }
      }
      // cable tag * / name
      leaf name {
        tailf:info "Name of the tag";
        type string {
          tailf:info "WORD;;Globally unique name string of the tag";
        }
      }

      // cable tag * / docsis-version
      leaf docsis-version {
        tailf:info "Set the match rule for DOCSIS version";
        type enumeration {
          enum docsis10 {
            tailf:info "Match docsis 1.0 modems";
          }
          enum docsis11 {
            tailf:info "Match docsis 1.1 modems";
          }
          enum docsis20 {
            tailf:info "Match docsis 2.0 modems";
          }
          enum docsis30 {
            tailf:info "Match docsis 3.0 modems";
          }
        }
      }

      // cable tag * / service-class
      leaf service-class {
        tailf:info "Set the match rule for service class name";
        type string {
          tailf:info "WORD;;Service class name";
        }
      }
    }

    // cable service
    container service {
      tailf:info "Service flow/class setting";

      // cable service class *
      list class {
        tailf:info "Service class settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key class-index;
        leaf class-index {
          type uint16 {
            tailf:info "<1-1023>;;Class Index";
            range "1..1023";
          }
        }

        // cable service class * name
        leaf name {
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;The ascii string identifier for this "+
              "Service Class";
          }
        }

        // cable service class * downstream
        leaf downstream {
          tailf:info "Service Class is downstream";
          tailf:cli-full-command;
          type empty;
        }

        // cable service class * upstream
        leaf upstream {
          tailf:info "Service Class is upstream";
          tailf:cli-full-command;
          type empty;
        }

        // cable service class * peak-rate
        leaf peak-rate {
          tailf:info "Peak Rate within maximum traffic burst";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Peak Rate (bps";
          }
        }

        // cable service class * max-concat-burst
        leaf max-concat-burst {
          tailf:info "Max Concat Burst";
          type uint16 {
            tailf:info "<0-65535>;;Enter Max Concat Burst (bytes)";
          }
        }

        // cable service class * tos-overwrite
        container tos-overwrite {
          tailf:info "Overwrite TOS byte by setting mask bits to value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf and-mask {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<0x0-0xFF>;,TOS-overwrite-mask-and byte in hex";
            }
          }
          leaf or-mask {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<0x0-0xFF>;;TOS-overwrite-mask-or byte in hex";
            }
          }
        }

        // cable service class * max-rate
        leaf max-rate {
          tailf:info "Max Rate";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Max Rate (bps)";
          }
        }

        // cable service class * max-burst
        leaf max-burst {
          tailf:info "Max Tx Burst";
          type uint32 {
            tailf:info "<1522-4294967295>;;Enter Max Tx Burst (bytes)";
            range "1522..4294967295";
          }
        }

        // cable service class * min-rate
        leaf min-rate {
          tailf:info "Min Rate";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Min Resv Rate (bps)";
          }
        }

        // cable service class * priority
        leaf priority {
          tailf:info "Priority";
          type uint8 {
            tailf:info "<0-7>;;Enter Priority";
            range "0..7";
          }
        }

        // cable service class * sched-type
        leaf sched-type {
          tailf:info "Service Class Schedule Type";
          type enumeration {
            enum "2" {
              tailf:info "Best Effort Schedule Type";
            }
            enum "3" {
              tailf:info "Non Real-Time Polling Service Schedule Type";
            }
            enum "4" {
              tailf:info "Real-Time Polling Service Schedule Type";
            }
            enum "5" {
              tailf:info "Unsolicited Grant Service with Activity "+
                "Detection Schedule Type";
            }
            enum "6" {
              tailf:info "Unsolicited Grant Service Schedule Type";
            }
          }
        }
      }

      // cable service attribute
      container attribute {
        tailf:info "Service attribute settings";

        // cable service attribute ds-bonded downstream-type bonding-enabled
        container ds-bonded {
          tailf:info "Downstream Bonding Settings";
          container downstream-type {
            tailf:info "Bonding downstream-type settings";
            container bonding-enabled {
              tailf:info "Channel Bonding only supported on Bonding-capable "+
                "interfaces";
              tailf:cli-delete-when-empty;
              presence true;
              leaf enforce {
                tailf:info "Enforce Bonding-capable interface selection";
                type empty;
              }
            }
          }
        }

        // cable service attribute withhold-tlvs peak-rate
        container withhold-tlvs {
          tailf:info "Withhold D3.0 TLVs from pre-D3.0 modems";
          leaf peak-rate {
            tailf:info "Peak Traffic Rate TLV 24/25.27";
            type empty;
          }
        }
      }
    }

    // cable qos
    container qos {
      tailf:info "Cable Quality of Service";
      // cable qos permission
      container permission {
        tailf:info "Permission for Creating Cable Quality of Service Profile";
        // cable qos permission create
        // no cable qos permission create
        leaf create {
          tailf:info "Allow create by management";
          tailf:cli-show-no;
          type empty;
        }
        // cable qos permission update
        // no cable qos permission update
        leaf update {
          tailf:info "Allow update by management";
          tailf:cli-show-no;
          type empty;
        }
        // cable qos permission modems
        // no cable qos permission modems
        leaf modems {
          tailf:info "Allow create by modems";
          tailf:cli-show-no;
          type empty;
        }
      }
    }

    // cable filter
    container filter {
      tailf:info "CMTS packet filter settings";

      // cable filter group *
      list group {
        tailf:info "CMTS packet filter group settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key group-id;
        leaf group-id {
          type uint8 {
            tailf:info "<1-254>;;Group ID";
            range "1..254";
          }
        }
        // cable filter group * index *
        list index {
          tailf:info "CMTS packet filter index settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key index-num;
          leaf index-num {
            type uint8 {
              tailf:info "<1-255>;;Filter Index";
            }
          }
          // cable filter group * index * src-ip
          leaf src-ip {
            tailf:info "IP source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP source address";
            }
          }
          // cable filter group * index * src-mask
          leaf src-mask {
            tailf:info "IP source address mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP source address mask";
            }
          }
          // cable filter group * index * dest-ip
          leaf dest-ip {
            tailf:info "IP destination address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP destination address";
            }
          }
          // cable filter group * index * dest-mask
          leaf dest-mask {
            tailf:info "IP destination address mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP destination address mask";
            }
          }
          // cable filter group * index * v6-src-address
          leaf v6-src-address {
            tailf:info "IPv6 source address";
            type inet:ipv6-address {
              tailf:info " X:X:X:X::X;;Enter IPv6 source address";
            }
          }
          // cable filter group * index * v6-src-pfxlen
          leaf v6-src-pfxlen {
            tailf:info "IPv6 source address prefix length";
            type uint8 {
              tailf:info "<0-128>;;Enter Source Address Prefix Length";
              range "0..128";
            }
          }
          // cable filter group * index * v6-dest-address
          leaf v6-dest-address {
            tailf:info "IPv6 destination address";
            type inet:ipv6-address {
              tailf:info " X:X:X:X::X;;Enter IPv6 destination address";
            }
          }
          // cable filter group * index * v6-dest-pfxlen
          leaf v6-dest-pfxlen {
            tailf:info "IPv6 destination address prefix length";
            type uint8 {
              tailf:info "<0-128>;;Enter Destination Address Prefix Length";
              range "0..128";
            }
          }
          // cable filter group * index * v6-flow-label
          leaf v6-flow-label {
            tailf:info "IPv6 flow label";
            type uint32 {
              tailf:info "<0-1048575>;;Enter IPv6 flow label";
              range "0..1048575";
            }
          }
          // cable filter group * index * ip-proto
          leaf ip-proto {
            tailf:info "IP protocol";
            type uint16 {
              tailf:info "<0-256>;;Enter IP protocol type";
              range "0..256";
            }
          }
          // cable filter group * index * ip-tos
          container ip-tos {
            tailf:info "IP TOS byte settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf tos-mask {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0xFF>;;Enter mask against TOS value, "+
                  "byte in hex";
              }
            }
            leaf tos-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0xFF>;;Enter TOS value, byte in hex";
              }
            }
          }
          // cable filter group * index * src-port
          leaf src-port {
            tailf:info "TCP/UDP source port";
            type uint16 {
              tailf:info "<0-65535>;;Enter TCP/UDP Source Port";
            }
          }
          // cable filter group * index * dest-port
          leaf dest-port {
            tailf:info "TCP/UDP destination port";
            type uint16 {
              tailf:info "<0-65535>;;Enter TCP/UDP Destination Port";
            }
          }
          // cable filter group * index * ip-version
          leaf ip-version {
            tailf:info "IP version of filter";
            type enumeration {
              enum IPv4 {
                tailf:info "Filter is for IPv4 (default)";
              }
              enum IPv6 {
                tailf:info "Filter is for IPv6";
              }
            }
            default IPv4;
          }
          // cable filter group * index * tcp-flags
          container tcp-flags {
            tailf:info "TCP flags settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf flags-mask {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0x3F;;Enter TCP Flags Mask in Hex";
              }
            }
            leaf flags-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0x3F>;;Enter TCP Flags Value in Hex";
              }
            }
          }
          // cable filter group * index * match-action
          leaf match-action {
            tailf:info "Filter Match action processing";
            type enumeration {
              enum accept {
                tailf:info "Accept Packet on Match";
              }
              enum drop {
                tailf:info "Drop Packet on Match";
              }
            }
          }
          // cable filter group * index * status
          leaf "status" {
            tailf:info "Status of filter";
            type enumeration {
              enum active {
                tailf:info "Filter is active";
              }
              enum inactive {
                tailf:info "Filter is inactive";
              }
            }
            default active;
          }
        }
      }
    }

    // cable submgmt
    container submgmt {
      tailf:info "CMTS Subscriber Management Objects";
      container "default" {
        tailf:info "Defaults";
        container filter-group {
          tailf:info "Configure Filter Group";
          // cable submgmt default filter-group cm
          container cm {
            tailf:info "CM Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group cpe
          container cpe {
            tailf:info "CPE Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group mta
          container mta {
            tailf:info "MTA Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group stb
          container stb {
            tailf:info "STB Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group ps
          container ps {
            tailf:info "PS Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
        }
        // cable submgmt default active
        leaf active {
          tailf:info "CPE Control for Subscriber Management Filtering";
          type empty;
        }
      }
    }

    // cable logging
    container logging {
      tailf:info "Logs specific cable messages";

      // cable logging badipsource
      container badipsource {
        tailf:info "cable BADIPSOURCE messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging layer2events
      container layer2events {
        tailf:info "cable layer 2 messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging overlapip
      container overlapip {
        tailf:info "cable OVERLAPIP messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging ironbus
      container ironbus {
        tailf:info "cable IRONBUS messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging downstream-index
      container downstream-index {
        tailf:info "cable downstream index messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }
    }

    // cable default-tos-qos10 tos-overwrite
    container default-tos-qos10 {
      tailf:info "Default DOCSIS 1.0 ToS Overwrite";
      container tos-overwrite {
        tailf:info "Overwrite ToS byte by setting mask bits to value";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf tos-and {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0x0-0xFF>;;ToS-overwrite-mask-and byte in hex";
          }
        }
        leaf tos-or {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<0x0-0xFF>;;ToS-overwrite-mask-or byte in hex";
          }
        }
      }
    }

    // cable primary-sflow-qos11 keep
    container primary-sflow-qos11 {
      tailf:info "Keep the primary service flows after CM in QoS DOCSIS11 "+
        "mode offline";
      leaf keep {
        tailf:info "Keep the primary service flows after CM in QoS "+
          "DOCSIS11 mode offline";
        type enumeration {
          enum all {
            tailf:info "Keep CLI and SNMP counters after CM in QoS DOCSIS11 "+
              "mode offline";
          }
          enum snmp-only {
            tailf:info "Keep SNMP counters only after CM in QoS DOCSIS11 "+
              "mode offline";
          }
        }
      }
    }

    // cable sflog
    container sflog {
      tailf:info "CMTS Service Flow Logging Configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf max-entry {
        tailf:info "Max. number of entries in service flow log.";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<30000-59999>;;Max. number of entries in the service flow log.";
          range "30000..59999";
        }
      }
      leaf entry-duration {
        tailf:info "Service flow log entry duration in second";
        type uint32 {
          tailf:info "<3600-86400>;;Service flow log entry duration in second.";
          range "3600..86400";
        }
      }
    }

    // cable dynamic-secret
    container dynamic-secret {
      tailf:info "Cable dynamic secret";

      // cable dynamic-secret exclude
      container exclude {
        tailf:info "Exclude single modem";
        // cable dynamic-secret exclude modem
        leaf modem {
          tailf:info "Exclude single modem";
          type string {
            tailf:info "H.H.H;;MAC address of the modem to exclude";
          }
        }
        // cable dynamic-secret exclude oui
        leaf oui {
          tailf:info "Exclude group of modems based on OUI";
          type string {
            tailf:info "WORD;;OUI to exclude";
          }
        }
      }

      // cable dynamic-secret tftp
      container tftp {
        tailf:info "TFTP Proxy Options";
        // cable dynamic-secret tftp insert-upgrade-server
        leaf insert-upgrade-server {
          tailf:info "Automatically insert upgrade server TLV into the "+
            "DOCSIS configuration file";
          type empty;
        }
      }
    }

    // cable docsis30-voice downstream
    container docsis30-voice {
      tailf:info "Docsis 3.0 voice default configurations";
      container downstream {
        tailf:info "Downstream Service parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf req-attr-mask {
          tailf:info "SF Required Attribute Mask";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }
        leaf forb-attr-mask {
          tailf:info "SF Forbidden Attribute Mask";
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }
      }
    }

    // cable util-interval
    leaf util-interval {
      tailf:info "Set channel utilization interval";
      type uint32 {
        tailf:info "<1-86400>;;The time interval in seconds";
        range "1..86400";
      }
    }

    // cable clock dti
    container clock {
      tailf:info "Clock card";
      leaf dti {
        tailf:info "set DTI clock reference mode";
        type empty;
      }
    }

    // cable bgsync
    container bgsync {
      tailf:info "switch snmp sync state";

      // no cable bgsync active
      leaf active {
        tailf:info "set background sync status";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // cable bgsync ptime
      leaf ptime {
        tailf:info "set how long(unit second) a p packet sent";
        type uint32 {
          tailf:info "<5-86400>;;in second";
          range "5..86400";
        }
        default 5;
      }

      // cable bgsync itime
      leaf itime {
        tailf:info "set how long(unit second) a i packet sent";
        type uint32 {
          tailf:info "<5-31536000>;;in second";
          range "5..31536000";
        }
        default 86400;
      }
    }

    // cable privacy
    container privacy {
      tailf:info "Cable Privacy";

      // cable privacy encrypt-alg-priority
      leaf encrypt-alg-priority {
        tailf:info "Encryption algorithm priority";
        type enumeration {
          enum aes128-des40-des56 {
            tailf:info "Priority AES128, DES40, DES56";
          }
          enum aes128-des56-des40 {
            tailf:info "Priority AES128, DES56, DES40";
          }
          enum des40-aes128-des56 {
            tailf:info "Priority DES40, AES128, DES56";
          }
          enum des40-des56-aes128 {
            tailf:info "Priority DES40, DES56, AES128";
          }
          enum des56-aes128-des40 {
            tailf:info "Priority DES56, AES128, DES40";
          }
          enum des56-des40-aes128 {
            tailf:info "Priority DES56, DES40, AES128";
          }
        }
      }
    }

    // cable dsg
    container dsg {
      tailf:info "Set DSG advance mode global parameters";

      // cable dsg client-list * id-index *
      list client-list {
        tailf:info "DSG client list settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key client-list-id;
        leaf client-list-id {
          type uint16 {
            tailf:info "<1-65535>;;DSG client list ID";
            range "1..65535";
          }
        }
        list id-index {
          tailf:info "DSG Client ID settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;DSG client ID index for the client list";
              range "1..65535";
            }
          }
          choice parameter-choice {
            leaf application-id {
              tailf:info "DSG Client type Application ID";
              type string {
                tailf:info "<1-FFFF>;;Hex value of DSG Client type Application ID";
              }
            }
            leaf broadcast {
              tailf:info "DSG Client type broadcast";
              type uint16 {
                tailf:info "<1--65535>;;DSG Broadcast client";
                range "1..65535";
              }
            }
            leaf ca-system-id {
              tailf:info "DSG Client type CA system ID";
              type string {
                tailf:info "<1-FFFF>;;Hex value of DSG Client type CA system ID";
              }
            }
            leaf mac-addr {
              tailf:info "DSG Client type Mac address";
              type string {
                tailf:info "H.H.H;;DSG Client MAC address";
              }
            }
          }
        }
      }

      // cable dsg tg *
      list tg {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key group-id;
        leaf group-id {
          type uint16 {
            tailf:info "<1-65535>;;DSG Tunnel Group ID";
            range "1..65535";
          }
        }
        // cable dsg tg * channel *
        list channel {
          tailf:info "DSG Channel";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key channel-id;
          leaf channel-id {
            type uint16 {
              tailf:info "<1-65535>;;DSG Channel ID";
              range "1..65535";
            }
          }
          // cable dsg tg * channel * priority
          leaf priority {
            tailf:info "DSG Rule priority";
            type uint8 {
              tailf:info "<0-255>;;DSG Rule priority";
            }
          }
          // cable dsg tg * channel * enable
          // cable dsg tg * channel * disable
          leaf "status" {
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                tailf:info "Disable DSG tunnel group";
              }
              enum enable {
                tailf:info "Enable DSG tunnel group";
              }
            }
            default enable;
          }
        }
      }

      // cable dsg tunnel *
      list tunnel {
        tailf:info "DSG tunnel";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key tunnel-id;
        leaf tunnel-id {
          type uint16 {
            tailf:info "<1-65535>;;Tunnel id";
            range "1..65535";
          }
        }
        leaf mac-addr {
          tailf:info "destination MAC address";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "H.H.H;;Multicast group MAC address";
          }
        }
        leaf tg {
          tailf:info "tunnel group id";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;tunnel group id";
            range "1..65535";
          }
        }
        leaf clients {
          tailf:info "DSG Clients";
          type uint16 {
            tailf:info "<1-65535>;;DSG Clients";
            range "1..65535";
          }
        }
        leaf "status" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "disable tunnel";
            }
            enum enable {
              tailf:info "enable tunnel";
            }
          }
          default enable;
        }
      }

      // cable dsg cfr *
      list cfr {
        tailf:info "DSG classifier";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key index;
        leaf index {
          type uint16 {
            tailf:info "<1-65535>;;Classifier index";
            range "1..65535";
          }
        }
        leaf dest-ip {
          tailf:info "destination IP address";
          type string {
            tailf:info "WORD;;Multicast group IP address or hostname";
          }
        }
        leaf tunnel {
          tailf:cli-break-sequence-commands;
          tailf:info "tunnel index";
          type uint16 {
            tailf:info "<1-65535>;;tunnel index";
            range "1..65535";
          }
        }
        leaf priority {
          tailf:info "Classifier priority";
          type uint8 {
            tailf:info "<0-255>;;Classifier priority";
          }
        }
        leaf src-ip {
          tailf:info "source IP address";
          type string {
            tailf:info "WORD;;source IP address or hostname";
          }
        }
        leaf in-dcd {
          tailf:info "classifier is included in DCD or not";
          type enumeration {
            enum ignore {
              tailf:info "classifier is not included in DCD regardless "+
                "of tunnel MAC address";
            }
            enum no {
              tailf:info "classifier is not included in DCD";
            }
            enum yes {
              tailf:info "classifier is included in DCD";
            }
          }
        }
      }

      // cable dsg timer *
      list timer {
        tailf:info "DSG Timer settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key index;
        leaf index {
          type uint16 {
            tailf:info "<1-65535>;;DSG Timer index";
            range "1..65535";
          }
        }
        leaf Tdsg1 {
          tailf:info "DSG Initialization Timeout (Tdsg1) setting";
          type uint16 {
            tailf:info "<1-65535>;;DSG Initialization Timeout (Tdsg1) value";
            range "1..65535";
          }
        }
        leaf Tdsg2 {
          tailf:info "DSG Operational Timeout (Tdsg2) setting";
          type uint16 {
            tailf:info "<1-65535>;;DSG Initialization Timeout (Tdsg2) value";
            range "1..65535";
          }
        }
        leaf Tdsg3 {
          tailf:info "DSG Two-Way Retry Timer (Tdsg3) setting";
          type uint16 {
            tailf:info "<0-65535>;;DSG Initialization Timeout (Tdsg3) value";
          }
        }
        leaf Tdsg4 {
          tailf:info "DSG One-Way Retry Timer (Tdsg4) setting";
          type uint16 {
            tailf:info "<0-65535>;;DSG Initialization Timeout (Tdsg4) value";
          }
        }
      }
    }

    // cable load-balance
    container load-balance {
      tailf:info "DOCSIS load balancing";

      // cable load-balance docsis-enable
      leaf docsis-enable {
        tailf:info "Enable docsis 2.0 load balancing";
        type empty;
      }

      // cable load-balance docsis30-enable
      leaf docsis30-enable {
        tailf:info "Enable docsis 3.0 load balancing";
        type empty;
      }

      // cable load-balance modem max-failures
      container modem {
        tailf:info "Modem settings";
        leaf max-failures {
          tailf:info "Set the time of failed movements before modem is "+
            "removed from dynamic LB";
          type uint8 {
            tailf:info "<0-100>;;Maximum failures before modem is "+
              "removed from dynamic LB";
            range "0..100";
          }
        }
      }

      // cable load-balance rule *
      list rule {
        tailf:info "Enter docsis load balance rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key rule-id;
        leaf rule-id {
          type uint32 {
            tailf:info "<1-4294967295>;;DOCSIS load balance rule ID";
            range "1..4294967295";
          }
        }
        choice status-choice {
          container ds {
            tailf:cli-drop-node-name;
            container disable-throughput-lowerbound {
              tailf:info "load balance is disabled if CM throughput is lower "+
                "than a threshold";
              // cable load-balance rule * disable-throughput-lowerbound ds
              leaf ds {
                tailf:info "Specify DS throughput lowerbound";
                type uint32 {
                  tailf:info "<0-1000000>;;Throughput lowerbound in kbps";
                  range "0..1000000";
                }
              }
            }
          }
          container us {
            tailf:cli-drop-node-name;
            container disable-throughput-lowerbound {
              tailf:info "load balance is disabled if CM throughput is lower "+
                "than a threshold";
              // cable load-balance rule * disable-throughput-lowerbound us
              leaf us {
                tailf:info "Specify US throughput lowerbound";
                type uint32 {
                  tailf:info "<0-1000000>;;Throughput lowerbound in kbps";
                  range "0..1000000";
                }
              }
            }
          }
          leaf disabled {
            tailf:info "load balance is always disabled";
            type empty;
          }
          leaf enabled {
            tailf:info "load balance is always enabled";
            type empty;
          }
        }
      }

      // cable load-balance docsis-policy *
      list docsis-policy {
        tailf:info "Enter docsis load balance policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key policy-id;
        leaf policy-id {
          type uint32 {
            tailf:info "<1-4294967295>;;DOCSIS load balance policy ID";
            range "1..4294967295";
          }
        }
        // cable load-balance docsis-policy * rule *
        list rule {
          tailf:info "Enter docsis load balance rule";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key rule-id;
          leaf rule-id {
            type uint32 {
              tailf:info "<1-4294967295>;;DOCSIS load balance rule ID";
            }
          }
        }
        // cable load-balance docsis-policy * tag
        leaf tag {
          tailf:info "Tag name";
          type string {
            tailf:info "WORD;;Tag name";
          }
        }
        // cable load-balance docsis-policy * override
        leaf override {
          tailf:info "Override the default";
          type empty;
        }
      }

      // cable load-balance d30-ggrp-default
      container d30-ggrp-default {
        tailf:info "Set DOCSIS 3.0 general group default value";

        // cable load-balance d30-ggrp-default disable
        leaf disable {
          tailf:info "Set disable DOCSIS GGRP as default";
          type empty;
        }

        // cable load-balance d30-ggrp-default init-tech-list
        leaf init-tech-list {
          tailf:info "Set DOCSIS GGRP DCC/DBC init tech as default";
          type string {
            tailf:info "<grouplist>;;Set DCC/DBC Initialization technique "+
              "list as default";
          }
        }

        // cable load-balance d30-ggrp-default docsis-policy
        leaf docsis-policy {
          tailf:info "Set DOCSIS GGRP policy ID as default";
          type uint32 {
            tailf:info "<0-4294967295>;;Set DOCSIS load balance policy ID as default";
          }
        }
      }

      // cable load-balance docsis-group
      container docsis-group {
        tailf:info "DOCSIS group";

        // cable load-balance docsis-group FN *
        list FN {
          tailf:cli-mode-name "config-lb-group";
          key fn-id;
          leaf fn-id {
            type uint16 {
              tailf:info "<1-256>;;cable fiber-node ID";
              range "1..256";
            }
          }
          container MD {
            tailf:info "Enter MAC-domain interface";
            tailf:cli-hide-in-submode;
            tailf:cli-flatten-container;
            leaf Cable {
              tailf:info "Cable;;CMTS interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              tailf:cli-hide-in-submode;
              type string {
                pattern "[0-9]+.*";
              }
              tailf:non-strict-leafref {
                path "/ios:interface/Cable/name";
              }
            }
          }
          uses cable-load-balance-docsis-group-grouping;
        }

        // cable load-balance docsis-group *
        list docsis-group-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-lb-group";
          key docsis-group-id;
          leaf docsis-group-id {
            type uint32 {
              tailf:info "<1-2147483647>;;DOCSIS load balance group number";
              range "1..2147483647";
            }
          }
          uses cable-load-balance-docsis-group-grouping;
        }
      }

      // cable load-balance exclude
      container exclude {
        tailf:info "Exclude modems from load balancing";

        // cable load-balance exclude oui *
        list oui {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key word;
          leaf word {
            type string {
              tailf:info "WORD;;OUI of exclude modem in the formatxx.xx.xx "+
                "or xx:xx:xx";
            }
          }
          leaf assignment {
            tailf:info "Exclude modem at assigning phase";
            tailf:cli-full-command;
            type empty;
          }
          leaf enforce {
            tailf:info "Exclude only for enforced load balancing";
            tailf:cli-full-command;
            type empty;
          }
          leaf static {
            tailf:info "Exclude only for static load balancing";
            type empty;
          }
          leaf strict {
            tailf:info "Exclude all forms of load balancing";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

    }

    // cable metering
    container metering {
      tailf:info "CMTS Metering Configuration";

      // cable metering destination
      // cable metering ipdr-d3 session
      choice cable-metering-choice {
        container destination {
          tailf:info "Cable Metering Collector IP address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf ip-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address of primary";
            }
          }
          leaf port {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Enter Port Number of primary";
              range "1..65535";
            }
          }
          leaf ip-address2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address of secondary";
            }
          }
          leaf port2 {
            when "../ip-address2";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Enter Port Number of secondary";
              range "1..65535";
            }
          }
          leaf retries {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-5>;;Enter number of retries ";
              range "0..5";
            }
          }
          leaf minutes {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<2-1440>;;Enter metering data collection interval "+
                "in minutes";
              range "2..1440";
            }
          }
          leaf security {
            tailf:cli-drop-node-name;
            type enumeration {
              enum non-secure {
                tailf:info "Non secure streaming";
              }
              enum secure {
                tailf:info "Secure streaming";
              }
            }
          }
          leaf flow-aggregate {
            tailf:cli-break-sequence-commands;
            tailf:info "Only aggregate service flow information";
            type empty;
          }
          leaf cpe-list-suppress {
            tailf:info "Suppress cpe information";
            type empty;
          }
          leaf full-records {
            tailf:info "Full service flow (active and idle) records";
            type empty;
          }
        }
        container ipdr-d3 {
          tailf:info "Cable Metering Exporter through IPDR D3.0";
          container session {
            tailf:info "IPDR D3 session";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf session-id {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-255>;;Enter metering ipdr D3 session id";
                range "1..255";
              }
            }
            leaf "type" {
              tailf:info "IPDR D3 Service Definition Type of Metering";
              type uint8 {
                tailf:info "<1-2>;;Enter metering IPDR D3 Service Definition Type";
                range "1..2";
              }
            }
            leaf flow-aggregate {
              tailf:info "Only aggregate service flow information";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf full-records {
              tailf:info "Full service flow (active and idle) records";
              type empty;
            }
          }
        }
      }

      // cable metering source-interface
      container source-interface {
        tailf:info "source-interface for the billing packets";
        uses interface-name-grouping;
      }

      // cable metering data-per-session
      container data-per-session {
        tailf:info "Number of flows per session";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf data-per-session {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<3-30>;;Enter # of data flows per session";
            range "3..30";
          }
        }
        leaf timer {
          tailf:info "CLC timer to wake up ";
          type uint16 {
            tailf:info "<8-500>;;Enter timer wake up interval in msec";
            range "8..500";
          }
        }
      }
    }

    // cable rf-change-trigger
    container rf-change-trigger {
      tailf:info "NP RF status change trigger";
      tailf:cli-compact-syntax;
      leaf percent {
        tailf:info "% of CM report NP RF status change";
        type uint8 {
          tailf:info "<1-100>;;% of CM report NP RF status change";
          range "1..100";
        }
      }
      leaf count {
        tailf:info "#of CM report NP RF status change";
        type uint16 {
          tailf:info "<1-65535>;;#of CM report NP RF status change";
          range "1..65535";
        }
      }
      leaf secondary {
        tailf:info "move secondary service flows";
        type empty;
      }
    }

    // cable throttle-modem
    container throttle-modem {
      tailf:info "Manage CM initialization/registration throttling on "+
        "large systems";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf init-rate {
        tailf:info "Maximum number of modems pass the initialization step per second";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-1000>;;Default value is 32 CM/Sec";
          range "1..1000";
        }
      }
      leaf holdoff-time {
        tailf:info "Maximum number of seconds a modem waiting in "+
          "throttling queue";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<5-100>;;Default value is 45 Seconds";
          range "5..100";
        }
      }
      leaf flush-rate {
        tailf:info "Maximum number of modems flushing from throttling queue "+
          "once holdoff time is expired";
        type uint16 {
          tailf:info "<100-1000>;;Default value is 300 CM/Sec";
          range "100..1000";
        }
      }
    }

    // cable ds-max-burst
    container ds-max-burst {
      tailf:info "Enable maximum traffic burst";
      tailf:cli-delete-when-empty;
      presence true;
      choice optional {
        leaf burst-threshold {
          tailf:info "Threshold to enable maximum traffic burst";
          type uint32 {
            tailf:info "<64-1000000>;;Burst Threshold in Kbytes (default = 1000)";
            range "64..1000000";
          }
          default 1000;
        }
        leaf peak-rate {
          tailf:info "Peak rate within the maximum traffic burst";
          type uint32 {
            tailf:info "<0-1000000>;;Peak Rate in Kbps (default is unshaped)";
            range "0..1000000";
          }
        }
      }
    }

    // cable acfe
    container acfe {
      tailf:info "Configure Fairness across DOCSIS interfaces";
      // cable acfe enable
      leaf enable {
        tailf:info "Enable Fairness across DOCSIS interfaces "+
          "(Adaptive CIR Fair EIR)";
        type empty;
      }
    }

    // cable l2-vpn-service xconnect nsi
    container l2-vpn-service {
      tailf:info "Use Layer-2 Tunnels for CPE traffic behind certain CMs";
      container xconnect {
        tailf:info "Tunnel traffic to L2VPN circuit";
        container nsi {
          tailf:info "Network System Interface";

          // cable l2-vpn-service xconnect nsi dot1q
          container dot1q {
            tailf:info "Tunnel traffic to DOT1Q L2VPN";
            tailf:cli-display-separated;
            presence true;
            // cable l2-vpn-service xconnect nsi dot1q interface
            container interface {
              tailf:info "Default Ethernet NSI interface";
              uses interface-name-grouping;
            }
          }

          // cable l2-vpn-service xconnect nsi mpls
          container mpls {
            tailf:info "Tunnel traffic to ATOM/MPLS PW";
            presence true;
          }
        }
      }
    }

    // cable dot1q-vc-map *
    list dot1q-vc-map {
      tailf:info "Map a CM to an Ethernet VLAN";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key mac-address;
      leaf mac-address {
        type string {
          tailf:info "H.H.H;;Modem MAC address";
        }
      }
      container ethernet-interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        uses interface-name-grouping;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<2-4095>;;IEEE 802.1Q VLAN ID";
          range "2..4095";
        }
      }
      leaf cust-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Customer Name";
        }
      }
    }

    // cable l2vpn *
    list l2vpn {
      tailf:info "Cable Modem Ethernet L2VPN Service";
      tailf:cli-mode-name "config-l2vpn";
      tailf:cli-sequence-commands;
      key mac-address;
      leaf mac-address {
        type string {
          tailf:info "H.H.H;;Modem MAC address";
        }
      }
      leaf customer-name {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type string {
          tailf:info "WORD;;Customer Name";
        }
      }

      // cable l2vpn * / service instance * ethernet
      container service {
        tailf:cli-break-sequence-commands;
        tailf:info "Ethernet service";
        list instance {
          tailf:info "Ethernet service Instance";
          tailf:cli-mode-name "config-ethsrv";
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          max-elements 1;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-8000>;;Ethernet service Instance id";
            }
          }
          leaf ethernet {
            tailf:info "Service Type  - Ethernet";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }

          // cable l2vpn * / service instance * ethernet / encapsulation
          // encapsulation default  - READ ONLY

          // cable l2vpn * / service instance * ethernet / xconnect
          uses interface-xconnect-grouping;

          // cable l2vpn * / service instance * ethernet / cable set
          container cable {
            tailf:info "Cable Specific commands";
            container set {
              tailf:info "Set parameters";
              leaf mpls-experimental {
                tailf:info "Set MPLS Pseudo-wire Experimental bits";
                type uint8 {
                  tailf:info "<0-7>;;MPLS Experimental Bits Value";
                }
              }
            }
          }
        }
      }
    }

    // cable wideband auto-reset
    container wideband {
      tailf:info "Wideband Configuration";
      leaf auto-reset {
        tailf:info "Reset WCMs reg'd traditional-DOCSIS";
        type empty;
      }
    }

    // cable rcc-template *
    list rcc-template {
      tailf:info "Create Cable RCC-Template";
      tailf:cli-mode-name "config-rcc-template";
      key index;
      leaf index {
        type uint8 {
          tailf:info "<1-255>;;cable rcc-template id";
          range "1..255";
        }
      }

      // cable rcc-template * / rcp-id
      leaf rcp-id {
        tailf:info "Receive Channel Profile ID";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "<0x0-0xFF>;;RCP ID in hex";
        }
      }

      // cable rcc-template * / receive-module
      list receive-module {
        tailf:info "Receive Module entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key index;
        leaf index {
          type uint8 {
            tailf:info "<1-10>;;Receive Module index";
            range "1..10";
          }
        }
        leaf first-center-frequency {
          tailf:info "Module Center frequency";
          type uint32 {
            tailf:info "<55000000-1050000000>;;Center Frequency - Hz";
            range "55000000..1050000000";
          }
        }
        leaf connected-receive-module {
          tailf:info "Receive Modules";
          type uint8 {
            tailf:info "<1-10>;;Connected Receive Module index";
            range "1..10";
          }
        }
      }

      // cable rcc-template * / receive-channel
      list receive-channel {
        tailf:info "Receive Channel entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key index;
        leaf index {
          type uint8 {
            tailf:info "<1-24>;;Receive Channel index";
            range "1..24";
          }
        }
        leaf center-frequency {
          tailf:info "Channel Center frequency";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<55000000-1050000000>;;Center Frequency - Hz";
            range "55000000..1050000000";
          }
        }
        leaf connected-receive-module {
          tailf:info "Receive Modules";
          type uint8 {
            tailf:info "<1-10>;;Connected Receive Module index";
            range "1..10";
          }
        }
        leaf primary {
          tailf:info "Receive Channel Primary indicator";
          type empty;
        }
      }
    }

    // cable fiber-node *
    list fiber-node {
      tailf:info "Create Cable fiber-node";
      tailf:cli-mode-name "config-fiber-node";
      key fiber-node-id;
      leaf fiber-node-id {
        type uint16 {
          tailf:info "<1-256>;;cable fiber-node id";
          range "1..256";
        }
      }

      // cable fiber-node * / description
      leaf "description" {
        tailf:info "Fiber node name/description";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this fiber node that will be "+
            "truncated to 80 characters.";
        }
      }

      // cable fiber-node * / downstream
      container downstream {
        tailf:info "Cable downstream channel";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice downstream-choice {
          leaf Modular-Cable {
            tailf:info "Modular cable";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/port";
            }
          }
          leaf Cable {
            tailf:info "CMTS interface";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/port";
            }
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }

      // cable fiber-node * / upstream
      container upstream {
        tailf:info "Cable upstream channel";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf Cable {
          type string {
            tailf:info "<5-8>/<0-1>;;Enter slot/subslot numbers";
          }
        }
        leaf connector {
          tailf:info "Physical upstream port connector on LC";
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }
    }

    // cable ipv6
    container ipv6 {
      tailf:info "Configure CMTS-wide IPv6 commands";

      // cable ipv6 pd-route
      container pd-route {
        tailf:info "Configure PD enclosing route";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf "prefix" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
        leaf Bundle {
          tailf:info "Virtual Bundle";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint8 {
            tailf:info "<1-255>;;Bundle interface number";
            range "1..255";
          }
        }
      }

      // cable ipv6 source-verify
      container source-verify {
        tailf:info "IPv6 Source verify";
        container leasequery-filter {
          tailf:info "Source verify Lease query filter";
          container downstream {
            tailf:info "Source verify IPv6 Lease query filter for "+
              "downstream pkts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf threshold {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-255>;;Number of ipv6 lease queries for unknown sid";
                range "0..255";
              }
            }
            leaf interval {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-10>;;size of time window in seconds";
                range "1..10";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2tp-class
  /// ========================================================================

  // l2tp-class *
  list l2tp-class {
    tailf:info "l2tp-class configuration";
    tailf:cli-mode-name "config-l2tp-class";
    key l2tp-class-name;
    leaf l2tp-class-name {
      type string {
        tailf:info "WORD;;l2tp-class name";
      }
    }

    // l2tp-class * / hello
    leaf hello {
      tailf:info "Set HELLO message interval";
      type uint16 {
        tailf:info "<0-1000>;;Seconds, default is 60";
        range "0..1000";
      }
      default 60;
    }

    // l2tp-class * / retransmit
    container retransmit {
      tailf:info "Control message retransmission parameters";

      // l2tp-class * / retransmit retries
      leaf retries {
        tailf:info "Number of retries before tearing down a control "+
          "connection";
        type uint16 {
          tailf:info "<5-1000>;;Maximum retransmissions";
          range "5..1000";
        }
      }

      // l2tp-class * / retransmit timeout
      container timeout {
        tailf:info "Control packet retransmission timeout parameters";
        choice timeout-choice {
          leaf max {
            tailf:info "Maximum timeout";
            type uint8 {
              tailf:info "<1-8>;;Seconds";
              range "1..8";
            }
          }
          leaf min {
            tailf:info "Minimum timeout";
            type uint8 {
              tailf:info "<1-8>;;Seconds";
              range "1..8";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// packetcable
  /// ========================================================================

  container packetcable {
    tailf:info "Global packetcable configuration";
    tailf:cli-display-separated;
    presence true;

    // packetcable multimedia
    leaf multimedia {
      tailf:info "Enable Packetcable Multimedia functionality";
      type empty;
    }
  }


  /// ========================================================================
  /// depi-class
  /// ========================================================================

  // depi-class *
  list depi-class {
    tailf:info "depi-class configuration";
    tailf:cli-mode-name "config-depi-class";
    key depi-class-name;
    leaf depi-class-name {
      type string {
        tailf:info "WORD;;depi-class name";
      }
    }

    // depi-class * / mode
    container mode {
      tailf:info "Set DEPI Mode";
      leaf mpt {
        tailf:info "MPT Mode";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// depi-tunnel
  /// ========================================================================

  // depi-tunnel *
  list depi-tunnel {
    tailf:info "depi-tunnel configuration";
    tailf:cli-mode-name "config-depi-tunnel";
    key depi-tunnel-name;
    leaf depi-tunnel-name {
      type string {
        tailf:info "WORD;depi-tunnel name";
      }
    }

    // depi-tunnel * / dest-ip
    leaf dest-ip {
      tailf:info "Set Destination IP address of Tunnel";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Peer IP address";
      }
    }

    // depi-tunnel * / l2tp-class
    leaf l2tp-class {
      tailf:info "Set l2tp-class to associate depi tunnel with";
      type string {
        tailf:info "WORD;;L2TP class with which this depi-tunnel is "+
          "associated";
      }
    }

    // depi-tunnel * / depi-class
    leaf depi-class {
      tailf:info "Set depi-class to associate depi tunnel with";
      type string {
        tailf:info "WORD;;depi-class with which this depi-tunnel is "+
          "associated";
      }
    }

    // depi-tunnel * / protect-tunnel
    leaf protect-tunnel {
      tailf:info "Specify protect depi-tunnel";
      type string {
        tailf:info "WORD;;protect depi-tunnel with which this depi-tunnel is "+
          "associated";
      }
    }
  }


  /// ========================================================================
  /// chat-script
  /// ========================================================================

  list chat-script {
    tailf:info "Define a modem chat script";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of chat script";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Chat script in form EXPECT SEND EXPECT SEND ...";
      }
    }
  }


  /// ========================================================================
  /// autonomic
  /// ========================================================================

  container autonomic {
    tailf:info "Autonomic Networking";

    // autonomic registrar
    container registrar {
      tailf:info "Registrar";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-registrar";

      // autonomic registrar / domain-id
      leaf domain-id {
        tailf:info "Autonomic Domain ID";
        type string {
          tailf:info "WORD;;Autonomic Domain ID in string format";
        }
      }

      // autonomic registrar / CA
      container CA {
        tailf:info "Create a Certificate Authority";
        leaf local {
          tailf:info "Create local Certificate Authority";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// controller
  /// ========================================================================

  container controller {
    tailf:info "Configure controller";

    // controller t1 *
    // controller e1 *
    // controller t3 *
    list controller-tx-ex-list {
      tailf:cli-mode-name "config-controller";
      tailf:cli-drop-node-name;
      key "name number";
      leaf name {
        type enumeration {
          tailf:info "Controller name";
          enum T1 {
            tailf:info "T1 controller";
          }
          enum E1 {
            tailf:info "E1 controller";
          }
          enum T3 {
            tailf:info "T3 controller";
          }
        }
      }
      leaf number {
        type string {
          tailf:info "WORD;;slot/subslot or port[/:]port";
        }
      }

      // controller * / framing
      leaf framing {
        tailf:info "Specify the type of Framing on a DS1 link";
        tailf:cli-full-command;
        type string;
      }

      // controller * / clock
      container clock {
        tailf:info "Specify the clock source for a DS1 link";
        // controller * / clock source
        container source {
          tailf:info "Specify the clock source for a DS1 link";
          choice source-choice {
            container line {
              tailf:info "Recovered Clock";
              tailf:cli-delete-when-empty;
              presence true;
              leaf line-mode {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type enumeration {
                  enum primary {
                    tailf:info "Primary Source";
                  }
                  enum secondary {
                  }
                  enum bits {
                    tailf:info "Bits Clocking";
                  }
                  enum independent {
                    tailf:info "Independent Source";
                  }
                }
              }
            }
            leaf internal {
              tailf:info "Internal Clock";
              tailf:cli-full-command;
              type empty;
            }
            leaf loop-timed {
              tailf:cli-full-command;
              type empty;
            }
            leaf free-running {
              tailf:info "Free Running Clock";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }

      // controller * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
          enum hdb3 { // E1 only (default)
          }
        }
      }

      // controller * / cablelength
      container cablelength {
        tailf:info "Specify the cable length for a DS1 link";
        choice cablelength-choice {
          leaf "value" {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint32;
          }
          leaf long {
            tailf:info "long cable";
            tailf:cli-full-command;
            type string;
          }
          leaf short {
            tailf:info "short cable";
            tailf:cli-full-command;
            type string;
          }
        }
      }

      // controller * / pri-group
      container pri-group {
        tailf:info "Configure the specified timeslots for PRI";
        list timeslots {
          tailf:info "List of timeslots in the pri-group";
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type uint8;
          }
          leaf nfas_d {
            tailf:info "Specify the operation of the D-channel timeslot.";
            type enumeration {
              enum primary {}
              enum backup {}
              enum none {}
            }
          }
          leaf nfas_int {
            when "../nfas_d";
            tailf:info "Specify the provisioned NFAS interface value.";
            type uint32 {
              tailf:info "<0-48>;;The NFAS interface value.";
            }
          }
          leaf nfas_group {
            when "../nfas_int";
            tailf:info "Specify the NFAS group.";
            type uint8 {
              range "1..24";
            }
          }
          leaf service {
            tailf:info "Specify the service type";
            type enumeration {
              enum mgcp {
                tailf:info "Media Gateway Control Protocol service";
              }
            }
          }
        }
      }

      // controller * / channel-group
      list channel-group {
        tailf:info "Specify the timeslots to channel-group "+
          "mapping for an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key number;
        leaf number {
          type uint8 {
            range "0..30";
          }
        }
        leaf-list timeslots {
          tailf:cli-replace-all;
          tailf:cli-range-list-syntax;
          type uint16;
        }
      }

      // controller * / description
      leaf "description" {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this interface";
        }
      }

      // controller * / t1 *
      list t1 {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint8;
        }
        leaf channel-group {
          type uint8 {
            range "0..23";
          }
        }
        leaf-list timeslots {
          tailf:cli-range-list-syntax;
          type uint8 {
            range "1..24";
          }
        }
        leaf speed {
          type enumeration {
            enum "56" {}
            enum "64" {}
          }
        }
      }

      // controller * / shutdown
      leaf shutdown {
        tailf:info "Shut down a DS1 link (send Blue Alarm)";
        type empty;
      }
    }

    // controller BITS input applique
    container BITS {
      tailf:info "Configure BITS Interface";
      container "input" {
        tailf:info "Configure BITS input";
        container applique  {
          tailf:info "Link type E1 or T1";
          container E1 {
            tailf:info "E1;;Link type E1";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            choice E1-choice {
              case clock-case {
                leaf clock-if {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "2048KHz" {
                      tailf:info "2048 KHz clock interface";
                    }
                  }
                }
              }
              case framing-case {
                leaf framing {
                  tailf:info "BITS framing options for E1";
                  tailf:cli-incomplete-command;
                  type enumeration {
                    enum fas_crc4 {
                      tailf:info "FASCRC4";
                    }
                    enum fas_nocrc {
                      tailf:info "FAS";
                    }
                    enum mfas_crc4 {
                      tailf:info "MFASCRC4";
                    }
                    enum mfas_nocrc {
                      tailf:info "MFAS";
                    }
                  }
                }
                leaf linecode {
                  tailf:info "BITS linecode options for E1";
                  type enumeration {
                    enum ami {
                      tailf:info "AMI encoding";
                    }
                    enum hdb3 {
                      tailf:info "HDB3 encoding";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // controller Cellular *
    list Cellular {
      tailf:info "3G/4G WWAN Cellular controller";
      tailf:cli-mode-name "config-controller";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<0-0>;;Controller unit number";
          range "0";
        }
      }

      // controller Cellular * / description
      leaf "description" {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this interface";
          length "1..80";
        }
      }

      // controller Cellular * / lte gps nmea
      container lte {
        tailf:info "LTE type carrier";

        // controller Cellular * / lte gps
        container gps {
          tailf:info "GPS configuration";

          // controller Cellular * / lte gps enable
          leaf enable {
            tailf:info "enable GPS feature";
            type empty;
          }

          // controller Cellular * / lte gps mode
          container mode {
            tailf:info "select GPS mode";
            leaf standalone {
              tailf:info "select Standalone mode";
              type empty;
            }
          }

          // controller Cellular * / lte gps nmea
          container nmea {
            tailf:info "enable NMEA data";
            choice nmea-choice {
              container ip {
                tailf:info "NMEA over IP interface";
                presence true;
              }
              container serial {
                tailf:info "NMEA over serial interface";
                presence true;
                leaf streaming {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "38400" {
                      tailf:info "38400 bps, 8 databits, No parity, 1 stopbit";
                    }
                    enum "4800" {
                      tailf:info "4800 bps, 8 databits, No parity, 1 stopbit "+
                        "(default)";
                    }
                    enum line-config {
                      tailf:info "Use tty line configuration";
                    }
                  }
                }
              }
            }
          }
        }

        // controller Cellular * / lte modem
        container modem {
          tailf:info "Modem logging configuration";
          container link-recovery {
            tailf:info "Cellular Link Recovery";
            leaf enable {
              type empty;
            }
            container rssi {
              tailf:info "RSSI Onset Threshold value";
              leaf onset-threshold {
                tailf:info "RSSI Onset Threshold";
                type int8 {
                  tailf:info "<-125 - -90>;;RSSI value in -dbm";
                  range "-125..-90";
                }
              }
            }
            leaf monitor-timer {
              tailf:info "Monitor Timer";
              type uint8 {
                tailf:info "<20 - 60>;;Monitor Timer value in seconds";
                range "20..60";
              }
            }
            leaf wait-timer {
              tailf:info "Wait Timer";
              type uint8 {
                tailf:info "<5 - 60>;;Wait Timer value in seconds";
                range "5..60";
              }
            }
            leaf debounce-count {
              tailf:info "Debounce Count";
              type uint8 {
                tailf:info "<6 - 20>;;Debounce Count value";
                range "6..20";
              }
            }
          }
        }
      }
    }

    // controller Modular-Cable *
    list Modular-Cable {
      tailf:info "Modular-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Modular-Cable * / ip-address
      leaf ip-address {
        tailf:info "Configure IP address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of Blaze";
        }
      }

      // controller Modular-Cable * / modular-host subslot
      container modular-host {
        tailf:info "Configure modular host";
        leaf subslot {
          tailf:info "Configure slot";
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;slot/subslot";
          }
        }
      }

      // controller Modular-Cable * / rf-channel *
      list rf-channel {
        tailf:info "RF channel configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key rf-port;
        leaf rf-port {
          type uint8 {
            tailf:info "<0-23>;;RF channel number";
            range "0..23";
          }
        }
        // controller Modular-Cable * / rf-channel * description
        leaf "description" {
          tailf:info "configure RF channel name/description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Description of this RF channel that will be "+
              "truncated to 80 characters";
          }
        }
        // controller Modular-Cable * / rf-channel * cable downstream
        container cable {
          tailf:info "configure RF channel cable downstream channel-id";
          container downstream {
            tailf:info "configure RF channel cable downstream channel-id";
            leaf channel-id {
              tailf:info "configure RF channel cable downstream channel-id";
              type uint8 {
                tailf:info "<1-255>;;RF channel cable downstream channel-id";
                range "1..255";
              }
            }
          }
        }
        // controller Modular-Cable * / rf-channel * frequency
        container frequency {
          tailf:info "configure RF channel frequency in Hz";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf freq {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<55000000-1050000000>;;Frequency in Hz";
              range "55000000..1050000000";
            }
          }
          leaf annex {
            tailf:info "ITU-T J.83 MPEG standard";
            tailf:cli-incomplete-command;
            type enumeration {
              enum "A" {
                tailf:info "Annex A, European Standard";
              }
              enum "B" {
                tailf:info "Annex B, North American Standard";
              }
            }
          }
          leaf modulation {
            tailf:info "configure RF channel modulation type";
            type enumeration {
              enum "256qam" {
                tailf:info "256-QAM modulation";
              }
              enum "64qam" {
                tailf:info "64-QAM modulation";
              }
            }
          }
          leaf interleave-depth {
            tailf:info "Interleave depth";
            type enumeration {
              enum 128 {
                tailf:info "R/S Interleave I=128, J=1";
              }
              enum 16 {
                tailf:info "R/S Interleave I=16, J=8";
              }
              enum 32 {
                tailf:info "R/S Interleave I=32, J=4";
              }
              enum 64 {
                tailf:info "R/S Interleave I=64, J=2";
              }
              enum 8 {
                tailf:info "R/S Interleave I=8, J=16";
              }
              enum 12 {
                tailf:info "R/S Interleave I=12, J=17";
              }
            }
          }
        }
        // controller Modular-Cable * / rf-channel * ip-address
        container ip-address {
          tailf:info "configure IP address of edge QAM";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf ip-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of edge QAM";
            }
          }
          leaf mac-address {
            tailf:info "MAC address of edge QAM";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "H.H.H;;MAC address of edge QAM";
            }
          }
          leaf depi-remote-id {
            tailf:info "configure DEPI session ID for edge QAM";
            type uint32 {
              tailf:info "<1-4294967295>;;DEPI remote ID";
              range "1..4294967295";
            }
          }
          leaf eqam-headroom {
            tailf:info "Headroom for Edge QAM channel";
            type uint8 {
              tailf:info "<0-28>;;EdgeQAM Headroom";
              range "0..28";
            }
          }
        }
        // controller Modular-Cable * / rf-channel * depi-tunnel
        container depi-tunnel {
          tailf:info "DEPI Data Session Configuration";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf depi-tunnel-name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;depi-tunnel name";
            }
          }
          leaf tsid {
            tailf:info "tsid ";
            type uint16 {
              tailf:info "<0-65535>;;tsid value";
            }
          }
        }
        // controller Modular-Cable * / rf-channel * rf-power
        leaf rf-power {
          tailf:info "Set RF Power";
          type string {
            tailf:info "<1-100>;;dBmV (The format is XY.Z; by default, .Z is .0)";
          }
        }
        // controller Modular-Cable * / no rf-channel * rf-shutdown
        leaf rf-shutdown {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // controller wanphy *
    list wanphy {
      tailf:info "WANPHY controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }
    }

  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";

    // no ip subnet-zero
    leaf subnet-zero {
      tailf:info "Allow 'subnet zero' subnets";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip source-route
    // no ip source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-boolean-no;
      tailf:cli-show-with-default;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // no ip routing
    leaf routing {
      tailf:info "Enable IP routing";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../../router" {
        tailf:cli-trigger-on-set;
      }
      tailf:callpoint ip-routing-hook { tailf:set-hook node; }
      type boolean;
      default true;
    }

    // ip arp
    container arp {
      tailf:info "IP ARP global configuration";

      // ip arp proxy disable
      container proxy {
        tailf:info "Global proxy ARP configuration";
        leaf disable {
          tailf:info "Disable proxy ARP on all interfaces";
          tailf:cli-full-command;
          type empty;
        }
      }

      // ip arp inspection
      container inspection {
        tailf:info "Arp Inspection configuration";

        // ip arp inspection bridge-domain
        leaf-list bridge-domain {
          tailf:info "Enable/Disable ARP Inspection on bridge-domains";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
            range "1..4094";
          }
        }

        // ip arp inspection bridge-domain * logging
        container bridge-domain-list {
          tailf:cli-drop-node-name;
          list bridge-domain {
            tailf:info "Enable/Disable ARP Inspection on bridge-domains";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
                range "1..4094";
              }
            }
            container logging {
              tailf:cli-flatten-container;
              choice logging-choice {
                // ip arp inspection bridge-domain * logging acl-match
                leaf acl-match {
                  tailf:info "Logging of packets that match ACLs";
                  type enumeration {
                    enum matchlog {
                      tailf:info "Log packets on ACE logging configuration";
                    }
                    enum none {
                      tailf:info "Do not log packets that match ACLs";
                    }
                  }
                }
                // ip arp inspection bridge-domain * logging dhcp-bindings
                leaf dhcp-bindings {
                  tailf:info "Logging of packet that match DHCP bindings";
                  type enumeration {
                    enum all {
                      tailf:info "Log all packets that match DHCP bindings";
                    }
                    enum none {
                      tailf:info "Do not log packets that match DHCP bindings";
                    }
                    enum permit {
                      tailf:info "Log DHCP Binding Permitted packets";
                    }
                  }
                }
              }
            }
          }
        }

        // ip arp inspection validate
        leaf-list validate {
          tailf:info "Validate addresses";
          tailf:cli-flat-list-syntax {
            tailf:cli-replace-all;
          }
          type enumeration {
            enum src-mac {
              tailf:info "Validate source MAC address";
            }
            enum dst-mac {
              tailf:info "Validate destination MAC address";
            }
            enum ip {
              tailf:info "Validate IP addresses";
            }
          }
        }

        // ip arp inspection log-buffer
        container log-buffer {
          tailf:info "Log Buffer Configuration";
          // ip arp inspection log-buffer entries
          leaf entries {
            tailf:info "Number of entries for log buffer";
            type uint16 {
              tailf:info "<0-1024>;;Number of entries for log buffer";
              range "0..1024";
            }
          }
          // ip arp inspection log-buffer logs interval
          container logs {
            tailf:info "Number of logs per interval";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf number {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-1024>;;Number of entries";
                range "0..1024";
              }
            }
            leaf interval {
              tailf:info "Interval for controlling logging rate";
              type uint32 {
                tailf:info "<0-86400>;;Interval (seconds)";
              }
            }
          }
        }
      }
    }

    // ip gratuitous-arps
    choice gratuitous-arps-choice {
      // ip gratuitous-arps
      // no ip gratuitous-arps
      container gratuitous-arps-conf {
        tailf:cli-drop-node-name;
        leaf gratuitous-arps {
          tailf:info "Generate gratuitous ARPs for PPP/SLIP peer addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
        }
      }
      container gratuitous-arps {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        // no ip gratuitous-arps non-local
        leaf non-local {
          tailf:info "Send only non-local PPP/SLIP gratuitous ARPs (default)";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
      default gratuitous-arps;
    }

    // ip cef
    // no ip cef
    container cef-conf {
      tailf:cli-drop-node-name;
      leaf cef {
        tailf:info "Cisco Express Forwarding";
        tailf:cli-show-no;
        type empty;
      }
    }
    container cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      // ip cef distributed
      leaf distributed {
        tailf:info "Distributed Cisco Express Forwarding";
        tailf:cli-full-command;
        type empty;
      }
      // no ip cef optimize neighbor resolution
      container optimize {
        tailf:info "Optimizations";
        container neighbor {
          tailf:info "Optimizations for directly connected neighbors";
          leaf resolution {
            tailf:info "Trigger layer 2 address resolution directly from CEF";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }
    }

    // ip vrf *
    list vrf {
      tailf:info "Configure an IP VPN Routing/Forwarding instance";
      tailf:cli-mode-name "config-vrf";
      tailf:callpoint ip-vrf-hook { tailf:set-hook node; }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // ip vrf * / description
      leaf "description" {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }

      // ip vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        tailf:cli-remove-before-change;
        type rd-type;
      }

      // ip vrf * / vpn
      container vpn {
        tailf:info "Configure VPN ID as specified in rfc2685";
        leaf id {
          tailf:info "Configure VPN ID in rfc2685 format";
          type vpn-id-type;
        }
      }

      // ip vrf * / context
      leaf context {
        tailf:info "Associate SNMP context with this vrf";
        type string {
          tailf:info "WORD;;SNMP Context Name";
        }
      }

      // ip vrf * / import
      container "import" {
        tailf:info "VRF import";

        // ip vrf * / import map
        leaf map {
          tailf:info "Route-map based VRF import";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../ipv4" {
            tailf:cli-trigger-on-set;
          }
          type string {
            tailf:info "WORD;;VRF import route-map name";
          }
        }

        // ip vrf * / import ipv4
        container ipv4 {
          tailf:info "Address family based VRF import";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-dependency "../map" {
            tailf:cli-trigger-on-set;
          }
          leaf ipv4-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum unicast {
                tailf:info "Import prefixes from IPv4 Unicast table";
              }
              enum multicast {
                tailf:info "Import prefixes from IPv4 Multicast table";
              }
            }
          }
          leaf upper-limit {
            tailf:cli-break-sequence-commands;
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Upper limit on import prefixes "+
                "without hogging memory";
              range "1..2147483647";
            }
          }
          leaf map {
            tailf:info "Route-map based VRF import";
            type string {
              tailf:info "WORD;;VRF import route-map name";
            }
          }
        }
      }

      // ip vrf * / export
      container export {
        tailf:info "VRF export";
        leaf map {
          tailf:info "Route-map based VRF export";
          type string {
            tailf:info "WORD;;VRF export route-map name";
          }
        }
      }

      // ip vrf * / maximum
      container maximum {
        tailf:info "Set a limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        presence true;
        leaf routes {
          tailf:info "Maximum number of routes allowed in this routing table";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of routes allowed";
            range "1..4294967295";
          }
        }
        choice maximum-choice {
          mandatory true;
          case threshold-case {
            leaf threshold {
              tailf:cli-drop-node-name;
              type uint16 {
                range "1..100";
                tailf:info "<1-100>;;Threshold value (%) at "
                  +"which to generate a warning msg";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due "
                +"to over maximum route limit";
              type uint16 {
                tailf:info "<1-100>;;Threshold value (%) at "
                  +"which to reinstall routes back to VRF";
                range "1..100";
              }
            }
          }
          case warning-case {
            leaf warning-only {
              tailf:info "Only give a warning message if is "
                +"limit exceeded";
              type empty;
            }
          }
        }
      }

      // ip vrf * / bgp next-hop Loopback
      container bgp {
        tailf:info "Commands pertaining to BGP";
        container next-hop {
          tailf:info "Next-hop for the routes of a VRF in the backbone";
          leaf Loopback {
            tailf:info "Loopback interface number";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Loopback interface number";
              range "0..2147483647";
            }
          }
        }
      }

      // ip vrf * / mdt
      container mdt {
        tailf:info "Backbone Multicast Distribution Tree";
        tailf:cli-incomplete-command;
        presence "Backbone Multicast Distribution Tree";
        leaf "default" {
          tailf:info "The default group";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP multicast group address";
          }
        }
        container data {
          tailf:info "MDT data group range";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          leaf mulicast-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP multicast group address";
            }
          }
          leaf wildcard-bits {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Wildcard bits";
            }
          }
          choice mdt-data-choice {
            case mdt-data-threshold {
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in "
                    +"kilobits per second";
                  range "1..4294967";
                }
              }
              leaf threshold-list {
                tailf:info "Access-list";
                tailf:alt-name "list";
                type ext-acl-type;
              }
            }
            case mdt-data-list {
              leaf "list" {
                tailf:info "Access-list";
                type ext-acl-type;
              }
            }
          }
        }
        leaf log-reuse {
          tailf:info "Event logging for data MDT reuse";
          type empty;
        }
      }

      // ip vrf * / route-target
      list route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "direction target";
        // NOTE: the Cisco CLI does not require you to give
        // the direction, it will default to 'export' if not
        // given.
        leaf direction {
          type enumeration {
            enum "both" {
              tailf:info "Both import and export Target-VPN "
                +"community";
            }
            enum "export" {
              tailf:code-name "direction_export";
              tailf:info "Export Target-VPN community";
            }
            enum "import" {
              tailf:code-name "direction_import";
              tailf:info "Import Target-VPN community";
            }
          }
        }
        leaf target {
          type rd-type {
            tailf:info "ASN:nn or IP-address:nn;;Target VPN "
              +"Extended Community";
          }
        }
      }
    }

    // ip dhcp-server
    container dhcp-server {
      tailf:info "Specify target DHCP server parameters";

      // ip dhcp-server *
      list dhcp-server-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key server;
        leaf server {
          //tailf:cli-disallow-value "vrf";
          type string {
            tailf:info "Hostname or A.B.C.D;;IP address or Name of DHCP server";
          }
        }
      }
    }

    // ip dhcp
    container dhcp {
      tailf:info "Configure DHCP server and relay parameters";

      // ip dhcp smart-relay
      leaf smart-relay {
        tailf:info "Enable Smart Relay feature";
        type empty;
      }

      // ip dhcp use
      container use {
        tailf:info "Configure use of certain parameters during allocation";
        container vrf {
          tailf:info "Ignore or use receiving interface VRF";
          // no ip dhcp use vrf connected
          leaf connected {
            tailf:info "Use input interface VRF when servicing "+
              "connected clients";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // no ip dhcp conflict logging
      container conflict {
        tailf:info "DHCP address conflict parameters";
        leaf logging {
          tailf:info "Record address conflicts in a log file";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // ip dhcp excluded-address *
      container excluded-address {
        tailf:info "Prevent DHCP from assigning certain addresses";
        uses ip-dhcp-excluded-address-grouping;
        list vrf {
          tailf:info "VRF name for excluded address range";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses ip-dhcp-excluded-address-grouping;
        }
      }

      // ip dhcp pool *
      list pool {
        tailf:info "Configure DHCP address pools";
        tailf:cli-mode-name "dhcp-config";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }

        // ip dhcp pool * / vrf
        leaf vrf {
          tailf:info "Associate this pool with a VRF";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ip dhcp pool * / network
        container network {
          tailf:info "Network number and mask";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf network-number {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "Network number in dotted-decimal notation";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
        }

        // ip dhcp pool * / dns-server *
        leaf-list dns-server {
          tailf:info "DNS servers";
          tailf:cli-flat-list-syntax;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / domain-name
        leaf domain-name {
          tailf:info "Domain name";
          tailf:cli-full-command;
          type string {
            tailf:info "NAME;;Domain name";
          }
        }

        // ip dhcp pool * / default-router *
        leaf-list default-router {
          tailf:info "Default routers";
          tailf:cli-flat-list-syntax;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Router's name or IP address";
          }
        }

        // ip dhcp pool * / option
        list option {
          tailf:info "Raw DHCP options";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          key code;
          leaf code {
            type uint8 {
              tailf:info "<0-254>;;DHCP option code";
              range "0..254";
            }
          }
          leaf ascii {
            tailf:info "Data is an NVT ASCII string";
            type string {
              tailf:info "LINE;;NVT ASCII string";
            }
          }
          leaf hex {
            tailf:info "Data is a hexadecimal string";
            type union {
              type string {
                tailf:info "LINE;;Hexadecimal string";
              }
              type enumeration {
                enum none {
                  tailf:info "No data";
                }
              }
            }
          }
          leaf instance {
            tailf:info "Specify the option instance";
            type uint8 {
              tailf:info "<0-255>;;DHCP option instance";
            }
          }
          leaf-list ip {
            tailf:info "Data is one or more IP addresses";
            tailf:cli-flat-list-syntax;
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
            }
          }
        }

        // ip dhcp pool * / netbios-name-server
        leaf netbios-name-server {
          tailf:info "NetBIOS (WINS) name servers";
          type inet:host {
            tailf:info "Hostname or A.B.C.D  Server's name or IP address";
          }
        }

        // ip dhcp pool * / lease
        container lease {
          tailf:info "Address lease time";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          choice lease-choice {
            case a {
              leaf infinite {
                tailf:info "Infinite lease";
                type empty;
              }
            }
            case b {
              leaf days {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-365>;;Days";
                  range "0..365";
                }
              }
              leaf hours {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-23>;;Hours";
                  range "0..23";
                }
              }
              leaf minutes {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-59>;;Minutes";
                  range "0..59";
                }
              }
            }
          }
        }
      }

      // ip dhcp class *
      list class {
        tailf:info "Configure DHCP classes";
        tailf:cli-mode-name "config-dhcp-class";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Class name";
          }
        }

        // ip dhcp class * / remark
        leaf remark {
          tailf:info "Specify a remark for this class";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this class";
            length "1..240";
          }
        }

        // ip dhcp class * / relay agent information /
        container relay {
          tailf:info "Enter relay agent information option configuration "
            +"submode";
          container agent {
            tailf:info "Enter relay agent information option configuration "
              +"submode";
            container information {
              tailf:info "Enter relay agent information option configuration "
                +"submode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-dhcp-class-relayinfo";
              presence true;
            }
          }
        }
      }

      // ip dhcp snooping
      container snooping {
        tailf:info "DHCP Snooping";
        tailf:cli-display-separated;
        presence true;

        // ip dhcp snooping bridge-domain
        leaf-list bridge-domain {
          tailf:info "DHCP Snooping bridge-domain";
          tailf:cli-range-list-syntax;
          tailf:cli-suppress-list-no;
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../../snooping";
          type uint16 {
            tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
            range "1..4094";
          }
        }

        // ip dhcp snooping information
        container information {
          tailf:info "DHCP Snooping information";
          container option {
            tailf:info "DHCP Snooping information option";
            presence true;
            leaf allow-untrusted {
              tailf:info "DHCP Snooping information option allow-untrusted";
              type empty;
            }
            container format {
              tailf:info "Option 82 information format";
              container remote-id {
                tailf:info "Remote id option 82 format";
                choice remote-id-choice {
                  leaf hostname {
                    tailf:info "Use configured hostname for remote id";
                    type empty;
                  }
                  leaf string {
                    tailf:info "User defined string for remote id";
                    type string {
                      tailf:info "WORD;;Use string for remote id (max length "
                        +"63)";
                    }
                  }
                }
              }
            }
          }
        }

        // ip dhcp snooping database
        container database {
          tailf:info "DHCP snooping database agent";
          leaf url {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Database agent URL";
            }
          }
        }

        // ip dhcp snooping track
        container track {
          tailf:info "DHCP snooping track";
          leaf host {
            tailf:info "DHCP snooping track host";
            type empty;
          }
        }

        // ip dhcp snooping verify
        container verify {
          tailf:info "DHCP snooping verify";
          leaf mac-address {
            tailf:info "DHCP snooping verify mac-address";
            type empty;
          }
          leaf no-relay-agent-address {
            tailf:info "DHCP snooping verify giaddr";
            type empty;
          }
        }

        // ip dhcp snooping vlan
        leaf-list vlan {
          tailf:info "DHCP Snooping vlan";
          type uint16 {
            tailf:info "WORD;;DHCP Snooping vlan fist number or vlan range, "
              +"example: 1,3-5,7,9-11";
          }
        }
      }

      // ip dhcp relay
      container relay {
        tailf:info "DHCP relay agent parameters";

        // ip dhcp relay information
        container information {
          tailf:info "Relay agent information option";

          // ip dhcp relay information option
          container option {
            tailf:info "Insert relay information in BOOTREQUEST";
            presence true;
          }

          // no ip dhcp relay information check
          leaf check {
            tailf:info "Validate relay information in BOOTREPLY";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // ip dhcp relay information trust-all
          leaf trust-all {
            tailf:info "Received DHCP packets may contain relay info "+
              "option with zero giaddr";
            type empty;
          }
        }
      }
    }

    // no ip bootp server
    container bootp {
      tailf:info "Config BOOTP services";
      leaf server {
        tailf:info "Enable BOOTP server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // ip domain
    container domain {
      tailf:info "IP DNS Resolver";
      tailf:cli-incomplete-no;

      // ip domain round-robin
      leaf round-robin {
        tailf:info "Round-robin multiple IP addresses in cache";
        tailf:cli-full-command;
        type empty;
      }

      // ip domain list vrf *
      container list-vrf {
        tailf:cli-drop-node-name;
        container "list" {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list vrf {
            tailf:info "Specify VRF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf domain-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;A domain name";
              }
            }
          }
        }
      }

      // ip domain list *
      // ip domain-list *
      list "list" {
        tailf:info "Domain name to complete unqualified host names";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;A domain name";
          }
        }
      }

      // ip domain retry
      leaf retry {
        tailf:info "Specify times to retry sending a DNS query";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-100>;;Number of retries";
          range "0..100";
        }
      }

      // ip domain timeout
      leaf timeout {
        tailf:info "Specify timeout waiting for response to a DNS query";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-3600>;;Timeout value in seconds";
          range "1..3600";
        }
      }

      // no ip domain lookup
      container lookup-conf {
        tailf:cli-drop-node-name;
        leaf lookup {
          tailf:info "Enable IP Domain Name System hostname translation";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // ip domain lookup
      container lookup {
        tailf:info "Enable IP Domain Name System hostname translation";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        // ip domain lookup nsap
        leaf nsap {
          tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
        // ip domain lookup recursive
        leaf recursive {
          tailf:info "Enable IP DNS recursive lookup";
          tailf:cli-full-command;
          type empty;
        }
        // ip domain lookup source-interface
        container source-interface {
          tailf:info "Specify source interface for DNS resolver";
          uses interface-name-grouping;
        }
        // ip domain lookup vrf
        leaf vrf {
          tailf:info "Specify VRF";
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }

      // ip domain name vrf *
      container name-vrf {
        tailf:cli-drop-node-name;
        container name {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list vrf {
            tailf:info "Specify VRF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf domain-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Default domain name";
              }
            }
          }
        }
      }

      // ip domain name
      // ip domain-name
      leaf name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }

      // ip domain multicast
      leaf multicast {
        tailf:info "Define the domain name for multicast address lookups";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Multicast domain name";
        }
      }

      // ip domain recursive
      container recursive {
        tailf:info "Configure recursive DNS lookup";
        leaf retry {
          tailf:info "Configure maximum no. referrals to be allowed";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-100>;;Maximum no. of referrals allowed "+
              "- default 10";
            range "0..100";
          }
        }
        leaf allow-soa {
          tailf:info "Treat response containing SOA RR in AUTHORITY as a "+
            "referral";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // ip host *
    container host {
      tailf:info "Add an entry to the ip hostname table";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      uses ip-host-grouping;
      // ip host vrf *
      list vrf {
        tailf:info "Specify VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // ip host vrf * *
        uses ip-host-grouping;
      }
    }

    // ip name-server *
    container name-server {
      tailf:info "Specify address of name server to use";
      uses ip-name-server-grouping;
      list vrf {
        tailf:info "Specify VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // ip name-server vrf * *
        uses ip-name-server-grouping;
      }
    }

    // ip multicast-routing
    container mcr-conf {
      tailf:cli-drop-node-name;
      leaf multicast-routing {
        tailf:info "Enable IP multicast forwarding";
        type empty;
      }
    }

    // ip multicast-routing vrf *
    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "../mcr-conf/multicast-routing";
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-list-no;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-diff-dependency "../../mcr-conf/multicast-routing";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf distributed {
          tailf:info "Distributed multicast switching";
          type empty;
        }
      }
      // ip multicast-routing distributed
      leaf distributed {
        tailf:info "Distributed multicast switching";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";

      // ip multicast route-limit
      leaf route-limit {
        tailf:info "Maximum number of multicast routes";
        type uint32 {
          tailf:info "<1-2147483647>;;number of routes";
          range "1..2147483647";
        }
      }

      // ip multicast multipath
      container multipath {
        tailf:info "RPF across equal-cost paths";
        presence true;
        leaf s-g-hash {
          tailf:info "Per-(source, group) load sharing algorithm selection";
          type enumeration {
            enum basic {
              tailf:info "Basic hash on (source, group)";
            }
            enum next-hop-based {
              tailf:info "Advanced hash on (source, group) and next-hop";
            }
          }
        }
      }
    }

    // ip icmp
    container icmp {
      tailf:info "ICMP options";
      container rate-limit {
        tailf:info "rate limit ICMP messages generated";
        container unreachable {
          tailf:info "ICMP type 3, Destination Unreachable";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf DF {
            tailf:info "code 4, fragmentation needed and DF set";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf ms {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Once per milliseconds";
            }
          }
          container log {
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            presence true;
            leaf packets {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;number of unreachables within "+
                  "interval to trigger a message";
                range "1..4294967295";
              }
            }
            leaf interval-ms {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<10000-4294967295>;;log message once per "+
                  "milliseconds";
                range "10000..4294967295";
              }
            }
          }
        }
      }
    }

    // ip igmp
    container igmp {
      tailf:info "IGMP global configuration";

      // ip igmp limit
      leaf limit {
        tailf:info "IGMP limit";
        type uint16 {
          tailf:info "<1-64000>;;Max Allowed State";
          range "1..64000";
        }
      }

      // ip igmp snooping
      container snooping {
        tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
        presence true;
        leaf l2-entry-limit {
          tailf:info "limit on the l2 entry that can be installed by IGMP "
          +"snooping";
          type uint32 {
            tailf:info "<1-100000>;;maximum number of l2 entries";
            range "1..100000";
          }
        }
      }
    }

    // ip device tracking
    container device {
      tailf:info "Device tracking";
      container tracking {
        tailf:info "Device tracking";
        tailf:cli-delete-when-empty;
        presence true;
      }
    }

    // ip finger
    container finger {
      tailf:info "finger server";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf rfc-compliant {
        tailf:info "Comply with RFC 1288";
        type empty;
      }
    }

    // ip tcp
    container tcp {
      tailf:info "Global TCP parameters";

      // ip tcp mss
      leaf mss {
        tailf:info "TCP initial maximum segment size ";
        type uint16 {
          tailf:info "<68-10000>;;MSS";
          range "68..10000";
        }
      }

      // ip tcp path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Enable path-MTU discovery on new TCP connections";
        presence true;
        leaf age-timer {
          tailf:info "Set PMTU aging timer";
          type union {
            type enumeration {
              enum "infinite" {
                tailf:info "Disable pathmtu aging timer";
              }
            }
            type uint8 {
              tailf:info "<10-30>;;Aging time";
              range "10..30";
            }
          }
        }
      }
    }

    // ip telnet
    container telnet {
      tailf:info "Specify telnet options";
      container source-interface {
        tailf:info "Specify source interface";
        uses interface-name-grouping;
      }
    }

    // ip ftp
    container ftp {
      tailf:info "FTP configuration commands";
      // no ip ftp passive
      leaf passive {
        tailf:info "Connect using passive mode";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // ip ftp source-interface
      container source-interface {
        tailf:info "Specify interface for source address in"+
          " FTP connections";
        uses interface-name-grouping;
      }
      // ip ftp username
      leaf username {
        tailf:info "Specify username for FTP connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Username";
        }
      }
      // ip ftp password
      container password {
        tailf:info "Specify password for FTP connections;";
        uses password-grouping;
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";

      // ip tftp source-interface
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }

      // ip tftp boot-interface
      container boot-interface {
        tailf:info "Force interface to use for TFTP booting";
        uses interface-name-grouping;
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";

      // ip ssh time-out
      leaf time-out {
        tailf:info "Specify SSH time-out interval";
        type uint8 {
          tailf:info "<1-120>;;SSH time-out interval (secs)";
          range "1..120";
        }
      }

      // ip ssh authentication-retries
      leaf authentication-retries {
        tailf:info "Specify number of authentication retries";
        type uint8 {
          tailf:info "<0-5>;;Number of authentication retries";
          range "0..5";
        }
      }

      // ip ssh dscp
      leaf dscp {
        tailf:info "IP DSCP value for SSH traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0)";
          range "0..63";
        }
      }

      // ip ssh logging
      container logging {
        tailf:info "Configure logging for SSH";
        leaf events {
          tailf:info "Log SSH events";
          type empty;
        }
      }

      // ip ssh version
      leaf version {
        tailf:info "Specify protocol version supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }

      // ip ssh precedence
      leaf precedence {
        tailf:info "IP Precedence value for SSH traffic";
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }

      // ip ssh stricthostkeycheck
      leaf stricthostkeycheck {
        tailf:info "Enable SSH Server Authentication";
        type empty;
      }

      // ip ssh source-interface
      container source-interface {
        tailf:info "Specify interface for source address in SSH connections";
        uses interface-name-grouping;
      }
    }

    // ip scp server enable
    container scp {
      tailf:info "Scp commands";
      container server {
        tailf:info "Configure SCP server-side functionality";
        leaf enable {
          tailf:info "Enable server side of SCP";
          type empty;
        }
      }
    }

    // <INTERFACE>

    // ip local pool *
    container local {
      tailf:info "Specify local options";
      list pool {
        tailf:info "IP Local address pool lists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type union {
            type string {
              tailf:info "WORD;;Create named local address pool";
            }
            type enumeration {
              enum "default" {
                tailf:info "Create default local address pool";
              }
            }
          }
        }
        leaf start {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;First IP address of range";
          }
        }
        leaf last {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Last IP address of range";
          }
        }
        leaf group {
          tailf:info "Create ip local pool group";
          type string {
            tailf:info "WORD;;Group name for this named local address pool";
          }
        }
      }
    }

    // ip default-gateway
    leaf default-gateway {
      tailf:info "Specify default gateway (if not routing IP)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address of default gateway";
      }
    }

    // no ip classless
    leaf classless {
      tailf:info "Follow classless routing forwarding rules";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";
      // ip forward-protocol nd
      // no ip forward-protocol nd
      leaf nd {
        tailf:info "Sun's Network Disk protocol";
        tailf:cli-show-no;
        type empty;
      }
      // ip forward-protocol sdns
      leaf sdns {
        tailf:info "Network Security Protocol";
        tailf:cli-boolean-no;
        type boolean;
      }
      // ip forward-protocol turbo-flood
      leaf turbo-flood {
        tailf:info "Fast flooding of UDP broadcasts";
        tailf:cli-boolean-no;
        type boolean;
      }
      // ip forward-protocol spanning-tree
      container spanning-tree {
        tailf:info "Use transparent bridging to flood UDP broadcasts";
        presence true;
        leaf any-local-broadcast {
          tailf:info "Accept any local broadcast when flooding";
          type empty;
        }
      }
      // ip forward-protocol udp
      container udp {
        tailf:info "Packets to a specific UDP port";
        presence true;
        leaf service {
          tailf:cli-drop-node-name;
          type string;
        }
      }
    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";
      // ip http server
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }
      // ip http access-class
      leaf access-class {
        tailf:info "Restrict http server access by access-class";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-99>;;Access list number";
          range "1..99";
        }
      }
      // ip http authentication
      container authentication {
        tailf:info "Set http server authentication method";
        choice authentication-choice {
          // ip http authentication aaa
          leaf aaa {
            tailf:info "Use AAA access control methods";
            tailf:cli-full-command;
            type empty;
          }
          // ip http authentication local
          leaf local {
            tailf:info "Use local username and passwords";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      // ip http secure-server
      leaf secure-server {
        tailf:info "Enable HTTP secure server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }
      // ip http timeout-policy
      container timeout-policy {
        tailf:info "Set http server time-out policy parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf idle {
          tailf:info "Idle time-out of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-600>;;Connection idle time-out value in seconds";
            range "1..600";
          }
        }
        leaf life {
          tailf:info "Life time of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-86400>;;Connection life time value in seconds";
            range "1..86400";
          }
        }
        leaf requests {
          tailf:info "Maximum number of requests allowed on a http server "+
            "connection";
          type uint32 {
            tailf:info "<1-86400>;;Maximum number of requests allowed on a "+
              "http server connection";
            range "1..86400";
          }
        }
      }
      container client {
        tailf:info "Set http client parameters";
        tailf:cli-incomplete-command;
        leaf source-interface {
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:info "Specify interface for source address in all "
          +"HTTP(S) client connections";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }

    // ip bgp-community new-format
    container bgp-community {
      tailf:info "format for BGP community";
      leaf new-format {
        tailf:info "select aa:nn format for BGP community";
        type empty;
      }
    }

    // ip community-list *
    container community-list {
      tailf:info "Add a community list entry";
      // FIXME: in the GW case we need special treatment of 'no'
      // For example, no ip community-list 1 deny internet will
      // actually delete the community-list 1 instance.
      list number-standard {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key no;
        leaf no {
          type uint16 {
            tailf:info "<1-99>;;Community list number (standard)";
            range "1..99";
          }
        }
        uses ip-community-list-standard-grouping;
      }
      list number-expanded {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key no;
        leaf no {
          type uint16 {
            tailf:info "<100-500>;;Community list number (expanded)";
            range "100..500";
          }
        }
        uses ip-community-list-expanded-grouping;
      }
      list expanded {
        tailf:info "Add an expanded community-list entry";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-expanded-grouping;
      }
      list standard {
        tailf:info "Add a standard community-list entry";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-standard-grouping;
      }
    }

    // ip as-path
    container as-path {
      tailf:info "BGP autonomous system path filter";
      // ip as-path access-list *
      list access-list {
        tailf:info "Specify an access list number";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type uint16 {
            range "1..500";
            tailf:info "<1-500>;;AS path access list number";
          }
        }
        list as-path-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "operation rule";
          leaf operation {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum deny {
                tailf:code-name "operation_deny";
                tailf:info "Specify packets to reject";
              }
              enum permit {
                tailf:code-name "operation_permit";
                tailf:info "Specify packets to forward";
              }
            }
          }
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;A regular-expression to match"+
                " BGP AS paths.";
            }
          }
        }
      }
    }

    // ip flow-cache
    container flow-cache {
      tailf:info "Configure netflow cache parameters";
      // ip flow-cache entries
      leaf entries {
        tailf:info "Specify the number of entries in the flow cache";
        type uint32 {
          tailf:info "<1024-524288>;;Entries";
          range "1024..524288";
        }
      }
      // ip flow-cache timeout
      container timeout {
        tailf:info "Specify flow cache timeout parameters";
        leaf inactive {
          tailf:info "Specify the inactive flow timeout";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<10-600>;;Timeout in seconds";
            range "10..600";
          }
        }
        leaf active {
          tailf:info "Specify the active flow timeout";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-60>;;Timeout in minutes";
            range "1..60";
          }
        }
      }
    }

    // ip flow-export
    container flow-export {
      tailf:info "Specify host/port to send flow statistics";

      // ip flow-export source
      container source {
        tailf:info "Specify the interface for source address";
        uses interface-name-grouping;
      }

      // ip flow-export version
      leaf version {
        tailf:info "Specify the version number";
        type enumeration {
          enum 1;
          enum 5;
          enum 9;
        }
      }

      // ip flow-export template
      container template {
        tailf:info "Specify the template specific configurations";
        tailf:cli-diff-dependency "../version";
        container options {
          tailf:info "Specify the template option";
          leaf export-stats {
            tailf:info "Specify the template option export statistics";
            tailf:cli-full-command;
            type empty;
          }
        }
        // ip flow-export template timeout-rate
        leaf timeout-rate {
          tailf:info "Specify the time before template is resent";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-3600>;;Timeout in minutes (default 30 minutes)";
            range "1..3600";
          }
          default 30;
        }
        leaf refresh-rate {
          tailf:info "Specify the number of export packets before "+
            "template is resent";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-600>;;refresh rate in export packets "+
              "(default 20 packets)";
            range "1..600";
          }
          default 20;
        }
      }

      // ip flow-export destination
      container destination  {
        tailf:info "Specify the Destination IP address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf ip {
          tailf:cli-drop-node-name;
          type host-type {
            tailf:info "Hostname or A.B.C.D  Destination IP address";
          }
        }
        leaf port {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }

    }

    // ip flow-aggregation
    container flow-aggregation {
      tailf:info "Configure flow aggregation";
      // ip flow-aggregation cache *
      list cache {
        tailf:info "Create flow aggregation cache or "+
          "enter flow-cache command mode";
        tailf:cli-mode-name "config-flow-cache";
        key name;
        leaf name {
          type string;
        }
        // ip flow-aggregation cache * / cache
        container cache {
          tailf:info "Configure netflow cache parameters";
          container timeout {
            tailf:info "Specify flow cache timeout parameters";
            leaf active {
              tailf:info "Specify the active flow timeout";
              type uint8 {
                tailf:info "<1-60>;;Timeout in minutes";
                range "1..60";
              }
            }
          }
        }
        // ip flow-aggregation cache * / export
        container export {
          tailf:info "Specify host/port to send flow statistics";
          list destination {
            tailf:info "Specify the Destination IP address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key address;
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D Destination IP addres";
              }
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;UDP/SCTP port number";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // ip dns server
    container dns {
      tailf:info "Configure DNS server for a zone";
      container server {
        tailf:info "Enable DNS server";
        presence true;
      }
    }

    // ip mobile
    container mobile {
      tailf:info "Enable Mobile IP services";

      // ip mobile secure
      container secure {
        tailf:info "Security association";

        // ip mobile secure home-agent *
        list home-agent {
          tailf:info "Home agent security association";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-diff-dependency "/ios:router/mobile";
          key lower-address;
          leaf lower-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address (lower range)";
            }
          }
          leaf upper-address {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Upper range IP address for security";
            }
          }
          choice spi-choice {
            // ip mobile secure home-agent * spi
            case single-spi {
              container spi {
                tailf:info "Security parameter index - bidirectional";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
            }
            // ip mobile secure home-agent * lower-spi
            case range-spi {
              container inbound-spi {
                tailf:info "Security parameter index - inbound";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
              container outbound-spi {
                tailf:info "Security parameter index - outbound";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
            }
          }
          // ip mobile secure home-agent * key
          container "key" {
            tailf:info "Security key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice key-choice {
              leaf ascii {
                tailf:info "Key entered in ASCII string";
                type string {
                  tailf:info "WORD;;Key entered in ASCII";
                }
              }
              leaf hex {
                tailf:info "Key entered in hex string";
                type string {
                  tailf:info "Hex-string;;Hex string";
                }
              }
            }
          }
          // ip mobile secure home-agent * algorithm
          container algorithm {
            tailf:cli-break-sequence-commands;
            tailf:info "Authentication algorithm";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice algorithm-choice {
              leaf hmac-md5 {
                tailf:info "HMAC MD5 authentication";
                type empty;
              }
              container md5 {
                tailf:info "Keyed MD5 authentication";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                container mode {
                  tailf:info "Authentication mode";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf prefix-suffix {
                    tailf:info "Prefix-suffix mode";
                    type empty;
                  }
                }
              }
            }
          }
          // ip mobile secure home-agent * ignore-spi
          leaf ignore-spi {
            tailf:info "Ignore SPI for Authentication";
            type empty;
          }
        }
      }

      // ip mobile router
      container router {
        tailf:info "Mobile Router commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "mobile-router";
        tailf:cli-diff-dependency "../../../router/mobile";
        //when "../../../router/mobile";
        presence true;

        // ip mobile router / address
        container address {
          tailf:info "Mobile router's home address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf ipv4-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "/ios:router/mobile";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf ipv4-mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Home network mask";
            }
          }
        }

        // ip mobile router / collocated single-tunnel
        container collocated {
          tailf:info "Collocated CoA parameters";
          leaf single-tunnel {
            tailf:info "Optimized tunneling between MR and HA";
            tailf:cli-diff-dependency "/ios:router/mobile";
            type empty;
          }
        }

        // ip mobile router / home-agent *
        list home-agent {
          tailf:info "Mobile router's home agent";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "/ios:router/mobile";
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          // ip mobile router / home-agent * priority
          leaf priority {
            tailf:info "Priority level";
            type uint8 {
              tailf:info "<0-255>;;Priority value (default is 100)";
            }
            default 100;
          }
        }

        // ip mobile router / mobile-network *
        list mobile-network {
          tailf:info "Mobile router's mobile network";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "/ios:interface";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          // ip mobile router / mobile-network * policy mobile-map
          container policy {
            tailf:info "Enable MIP policy routing";
            leaf mobile-map {
              tailf:info "Apply mobile-map dyn route-map";
              type string {
                tailf:info "WORD;;mobile-map tag";
              }
            }
          }
        }

        // ip mobile router / register
        container register {
          tailf:info "Registration settings";

          // ip mobile router / register extend
          container extend {
            tailf:info "Extend registration lifetime";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf expire {
              tailf:info "Reregister before expiration";
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "/ios:router/mobile";
              type uint16 {
                tailf:info "<1-3600>;;Number of seconds before expiration";
              }
            }
            leaf retry {
              tailf:info "Number of attempts to extend registration";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-10>;;Stop after number of retries attempted";
                range "0..10";
              }
            }
            leaf interval {
              tailf:info "Interval between retries";
              type uint16 {
                tailf:info "<1-3600>;;Number of seconds between attempts";
                range "1..3600";
              }
            }
            leaf reverse-tunnel {
              type empty;
            }
          }
        }

        // ip mobile router / reverse-tunnel
        leaf reverse-tunnel {
          tailf:info "Reverse Tunnel requested";
          type empty;
        }

        // ip mobile router / tunnel mode gre
        container tunnel {
          tailf:info "Tunnel parameters";
          container mode {
            tailf:info "Tunnel mode";
            leaf gre {
              tailf:info "GRE encapsulation";
              type empty;
            }
          }
        }

        // ip mobile router / template tunnel
        container template {
          tailf:info "Configure a tunnel template for tunnels to the "+
            "Home Agent";
          leaf Tunnel {
            tailf:info "Tunnel interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Tunnel interface number";
            }
          }
        }
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "/ios:interface";
      uses ip-pim-grouping;
      // ip pim vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-pim-grouping;
      }
    }

    // ip rsvp
    container rsvp {
      tailf:info "Configure static RSVP information";
      container signalling {
        tailf:info "RSVP Signalling";

        // ip rsvp signalling hello
        container hello {
          tailf:info "Enable neighbor-down detection";
          tailf:cli-delete-when-empty;
          presence true;
          container graceful-restart {
            tailf:info "Configure RSVP Graceful Restart";
            leaf mode {
              tailf:info "Select Graceful Restart capabilities";
              type enumeration {
                enum full {
                  tailf:info "Capable of recovering self, and helping "+
                    "neighbor recover";
                }
                enum help-neighbor {
                  tailf:info "Capable of helping neighbor recover";
                }
              }
            }
          }
        }
      }
    }

    // ip nat
    container nat {
      tailf:info "NAT configuration commands";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";

      // ip nat pool *
      list pool {
        tailf:info "Define pool of addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }
        leaf start-address {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Start IP address";
          }
        }
        leaf end-address {
          tailf:cli-drop-node-name;
          when "../start-address" {
            tailf:dependency "../start-address";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;End IP address";
          }
        }
        choice prefix-choice {
          leaf netmask {
            tailf:info "Specify the network mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
          leaf prefix-length {
            tailf:info "Specify the prefix length";
            type uint8 {
              tailf:info "<1-32>;;Prefix length";
              range "1..32";
            }
          }
        }
        leaf accounting {
          tailf:cli-optional-in-sequence;
          tailf:info "Specify the accounting";
          type string {
            tailf:info "WORD;;Accounting method-list name";
          }
        }
        choice nat-choice {
          leaf arp-ping {
            tailf:info "WLAN ARP Ping";
            type empty;
          }
          leaf "type" {
            tailf:info "Specify the pool type";
            type enumeration {
              enum match-host {
                tailf:info "Keep host numbers the same after translation";
              }
              enum rotary {
                tailf:info "Rotary address pool";
              }
            }
          }
          leaf add-route {
            tailf:info "Add special route to Virtual Interface";
            type empty;
          }
        }
      }

      // ip nat inside
      container inside {
        tailf:info "Inside address translation";

        // ip nat inside source
        container source {
          tailf:info "Source address translation";

          // ip nat inside source list *
          list "list" {
            tailf:info "Specify access list describing local addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            uses ip-nat-inside-grouping;
          }

          // ip nat inside source static
          container static {
            tailf:info "Specify static local->global mapping";
            list nat-static-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "local-ip global-ip";
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              uses ip-nat-inside-souce-static-grouping;
            }
            list nat-static-transport-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto local-ip local-port global-ip global-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              uses ip-nat-inside-souce-static-grouping;
            }
            list nat-static-transport-interface-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "proto local-ip local-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              container interface {
                tailf:info "Specify interface for global address";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
              leaf global-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
            }
          }

          // ip nat inside source route-map *
          list route-map {
            tailf:info "Specify route-map";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Route-map name";
              }
            }
            uses ip-nat-inside-grouping;
          }
        }

        // ip nat inside destination
        container destination {
          tailf:info "Destination address translation";
          // ip nat inside destination list *
          list "list" {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            // ip nat inside destination list * pool *
            leaf pool {
              tailf:info "Name pool of local addresses";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ip/nat/pool/id";
              }
            }
            // [ redundancy redundancy-id ]
            leaf redundancy {
              tailf:info "NAT redundancy operation";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;IP redundancy ID";
                range "1..2";
              }
            }
            // [ mapping-id map-id ]
            leaf mapping-id {
              tailf:info "Associate a mapping id to this mapping";
              type uint32 {
                tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                range "1..2147483647";
              }
            }
          }
        }
      }

      // ip nat outside
      container outside {
        tailf:info "Outside address translation";

        // ip nat outside source
        container source {
          tailf:info "Source address translation";

          // ip nat outside source list *
          list "list" {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            leaf pool {
              tailf:info "Name pool of local addresses";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ip/nat/pool/id";
              }
            }
            leaf mapping-id {
              tailf:info "Associate a mapping id to this mapping";
              tailf:cli-optional-in-sequence;
              type uint32 {
                tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                range "1..2147483647";
              }
            }
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-optional-in-sequence;
              tailf:cli-diff-dependency "/ios:ip/vrf";
              tailf:cli-diff-dependency "/ios:vrf/definition";
              type string {
                tailf:info "WORD;;vrf name";
              }
            }
            leaf add-route {
              tailf:info "Add a static route for outside local address";
              type empty;
            }
          }

          // ip nat outside source route-map *
          list route-map {
            tailf:info "Specify route-map";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Route-map name";
              }
            }
            leaf pool {
              tailf:info "Name pool of local addresses";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ip/nat/pool/id";
              }
            }
            leaf mapping-id {
              tailf:info "Associate a mapping id to this mapping";
              tailf:cli-optional-in-sequence;
              type uint32 {
                tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                range "1..2147483647";
              }
            }
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-optional-in-sequence;
              tailf:cli-diff-dependency "/ios:ip/vrf";
              tailf:cli-diff-dependency "/ios:vrf/definition";
              type string {
                tailf:info "WORD;;vrf name";
              }
            }
            leaf add-route {
              tailf:info "Add a static route for outside local address";
              type empty;
            }
          }
        }
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "/ios:interface";

      // ip route static
      container static {
        tailf:info "Allow static routes";

        // ip route static adjust-time
        leaf adjust-time {
          tailf:info "Time period for adjusting static routes";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-60>;;Adjustment time in seconds";
            range "1..60";
          }
        }

        // no ip route static inter-vrf
        leaf inter-vrf {
          tailf:info "Across VRF interfaces";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // ip route static bfd *
        container bfd {
          tailf:info "BFD tracked";
          list ip-route-bfd-forwarding-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "interface ip-address";
            leaf interface {
              //tailf:cli-diff-dependency "/ios:interface";
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
            leaf ip-address {
             type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Gateway IP address";
              }
              type enumeration {
                enum multicast {
                  tailf:info "multicast route";
                }
              }
             }
            }
            leaf group {
              tailf:info "assign a bfd group";
              type string {
                tailf:info "WORD;;bfd group name";
              }
            }
          }
        }
      }

      // ip route profile
      leaf profile {
        tailf:info "Enable IP routing table profile";
        tailf:cli-full-command;
        type empty;
      }

      // ip route ?
      uses ip-route-grouping;

      // ip route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding "+
          "instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-route-grouping;
      }
    }

    // ip explicit-path
    container explicit-path {
      tailf:info "Configure explicit-path";

      // ip explicit-path identifier *
      list identifier {
        tailf:info "Specify explicit path by number";
        tailf:cli-mode-name "cfg-ip-expl-path";
        key number;
        leaf number {
          type uint16 {
            tailf:info "<1-65535>;;Enter number";
            range "1..65535";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum enable {
              tailf:info "enable the explicit path";
            }
            enum disable {
              tailf:info "disable the explicit path";
            }
          }
        }
        // ip explicit-path identifier * / index *
        list index {
          tailf:info "Specify entry index ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Entry index number";
            }
          }
          choice address-choice {
            // ip explicit-path name * / index * next-address
            leaf next-address {
              tailf:info "Specify the next address in the path";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:ipv4-address {
                tailf:info "WORD;;Enter IP address (A.B.C.D)";
              }
            }
            // ip explicit-path name * / index * exclude-address
            leaf exclude-address {
              tailf:info "Exclude an address from subsequent partial "+
                "path segments";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:ipv4-address {
                tailf:info "WORD;;Enter IP address (A.B.C.D)";
              }
            }
          }
        }
      }

      // ip explicit-path name *
      list name {
        tailf:info "Specify explicit path by name";
        tailf:cli-mode-name "cfg-ip-expl-path";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter name";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum enable {
              tailf:info "enable the explicit path";
            }
            enum disable {
              tailf:info "disable the explicit path";
            }
          }
        }
        // ip explicit-path name * / index *
        list index {
          tailf:info "Specify entry index ";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Entry index number";
            }
          }
          choice address-choice {
            // ip explicit-path name * / index * next-address
            leaf next-address {
              tailf:info "Specify the next address in the path";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:ipv4-address {
                tailf:info "WORD;;Enter IP address (A.B.C.D)";
              }
            }
            // ip explicit-path name * / index * exclude-address
            leaf exclude-address {
              tailf:info "Exclude an address from subsequent partial "+
                "path segments";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:ipv4-address {
                tailf:info "WORD;;Enter IP address (A.B.C.D)";
              }
            }
          }
        }
      }
    }

    // ip tacacs
    container tacacs {
      tailf:info "TACACS configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in "+
        "TACACS packets";
        uses interface-name-grouping;
      }
    }

    // ip access-list
    container access-list {
      tailf:info "Named access list";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;

      // ip access-list standard *
      container standard {
        tailf:info "Standard Access List";
        tailf:cli-incomplete-command;
        list std-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name "config-std-nacl";
          key name;
          leaf name {
            type std-ip-acl-type;
          }
          list std-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-drop-node-name;
              tailf:cli-multi-word-key;
              type string {
                tailf:info "deny;;Specify packets to reject\n"+
                  "permit;;Specify packets to forwards\n"+
                  "remark;;Access list entry comment";
                pattern "(permit .*)|(deny .*)|(remark .*)|([0-9]+.*)"+
                  "|(dynamic .*)|(evaluate .*)";
              }
            }
          }
        }
      }

      // ip access-list extended *
      container extended {
        tailf:info "Extended Access List";
        tailf:cli-incomplete-command;
        list ext-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-mode-name "config-ext-nacl";
          tailf:cli-explicit-exit;
          key name;
          leaf name {
            type ext-acl-type;
          }
          list ext-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-drop-node-name;
              tailf:cli-multi-word-key;
              type string {
                tailf:info "deny;;Specify packets to reject\n"+
                  "permit;;Specify packets to forwards\n"+
                  "remark;;Access list entry comment";
                pattern "(permit .*)|(deny .*)|(remark .*)|([0-9]+.*)"+
                  "|(dynamic .*)|(evaluate .*)";
              }
            }
          }
        }
      }
    }

    // ip prefix-list
    container prefix-list {
      tailf:info "Build a prefix list";

      // ip prefix-list *
      list prefixes {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of a prefix list";
            pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
            +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
            +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
            +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
            +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
            +'num[^b].*)|(sequence\-numb[^e].*)|'
            +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
          }
        }

        // ip prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ip prefix-list * permit
        leaf permit {
          tailf:info "Specify packets to forward";
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D  IP prefix <network>/<length>, "+
              "e.g., 35.0.0.0/8";
          }
        }

        // ip prefix-list * seq *
        list seq {
          // NOTE: the seq element is not actually mandatory
          // in the Cisco CLI. If it isn't give
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key no;
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
            tailf:key-default "10";
          }

          // ip prefix-list * seq * deny
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint8 {
                range "1..32";
                tailf:info "<1-32>;;Minimum prefix length";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint8 {
                range "1..32";
                tailf:info "<1-32>;;Maximum prefix length";
              }
            }
          }

          // ip prefix-list * seq * permit
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/"
                  +"<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint8 {
                tailf:info "<1-32>;;Minimum prefix length";
                range "1..32";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-32>;;Maximum prefix length";
                range "1..32";
              }
            }
          }
        }
      }

      // ip prefix-list sequence-number
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip radius source-interface
    container radius {
      tailf:info "RADIUS configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in RADIUS packets";
        uses interface-name-grouping;
      }
    }

    // ip sla
    container sla {
      tailf:info "IP Service Level Agreement";

      // ip sla auto discovery
      container auto {
        tailf:info "IP SLAs Auto Configuration";
        leaf discovery {
          tailf:info "Enable auto-discovery";
          type empty;
        }
      }

      // ip sla responder
      container responder {
        tailf:info "Enable IP SLAs Responder";
        presence true;
      }

      // ip sla logging traps
      container logging {
        tailf:info "Enable Syslog";
        leaf traps {
          tailf:info "Enable syslog traps";
          type empty;
        }
      }

      // ip sla *
      list ip-sla-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-ip-sla";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
            range "1..2147483647";
          }
        }

        // ip sla * / udp-jitter *
        list udp-jitter {
          tailf:info "UDP Jitter Operation";
          tailf:cli-mode-name "config-ip-sla-jitter";
          key "destination destination-port";
          leaf destination {
            type union {
              type inet:host {
                tailf:info "WORD;;Hostname or A.B.C.D IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
            }
          }
          leaf destination-port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number.";
            }
          }

          // ip sla * / udp-jitter * source-ip
          leaf source-ip {
            tailf:info "Source address";
            tailf:cli-hide-in-submode;
            type union {
              type inet:host {
                tailf:info "Hostname or A.B.C.D IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
            }
          }

          // ip sla * / udp-jitter * source-port
          leaf source-port {
            tailf:info "Source Port";
            tailf:cli-hide-in-submode;
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }

          // ip sla * / udp-jitter * codec
          leaf codec {
            tailf:info "codec type to be configured";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum g711alaw {
                tailf:info "G.711 A Law 64000 bps";
              }
              enum g711ulaw {
                tailf:info "G.711 U Law 64000 bps";
              }
              enum g729a {
                tailf:info "G.729 8000 bps";
              }
            }
          }

          // ip sla * / udp-jitter * codec-numpackets
          leaf codec-numpackets {
            tailf:info "Number of Packets to be transmitted";
            tailf:cli-hide-in-submode;
            when "../codec";
            type uint32 {
              tailf:info "<1-60000>;;Number of Packets";
              range "1..60000";
            }
          }

          // ip sla * / udp-jitter * interval
          leaf interval {
            tailf:info "Inter Packet Interval";
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<4-60000>;;Delay (default 20)";
            }
            default 20;
          }

          // ip sla * / udp-jitter * control
          leaf control {
            tailf:info "Enable or disable control packets";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
            default enable;
          }
          uses ip-sla-proto-grouping;
        }

        // ip sla * / icmp-echo *
        list icmp-echo {
          tailf:info "ICMP Echo Operation";
          tailf:cli-mode-name "config-ip-sla-echo";
          key host;
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D  Destination IP address "+
                "or hostname, broadcast disallowed";
            }
          }
          choice source-choice {
            // ip sla * / icmp-echo * source-interface
            container source-interface {
              tailf:info "Source Interface (ingress icmp packet interface)";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              uses interface-name-grouping;
            }
            // ip sla * / icmp-echo * source-ip
            leaf source-ip {
              tailf:info "Source Address";
              tailf:cli-hide-in-submode;
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;"+
                  "IP address or hostname, broadcast disallowed";
              }
            }
          }
          uses ip-sla-proto-grouping;
        }

        // ip sla * / udp-echo *
        list udp-echo {
          tailf:info "UDP Echo Operation";
          tailf:cli-mode-name "config-ip-sla-udp";
          key "host port";
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address "+
                "or hostname, broadcast disallowed";
            }
          }
          leaf port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number";
            }
          }
          // ip sla * / udp-echo * control
          leaf control {
            tailf:info "Enable or disable control packets";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
          }
          // ip sla * / udp-echo * source-ip
          leaf source-ip {
            tailf:info "Source Address";
            tailf:cli-hide-in-submode;
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;"+
                "IP address or hostname, broadcast disallowed";
            }
          }
          // ip sla * / udp-echo * source-port
          leaf source-port {
            tailf:info "source-port;;Source Port";
            tailf:cli-hide-in-submode;
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }
          uses ip-sla-proto-grouping;
        }

        // ip sla * / ethernet
        container ethernet {
          tailf:info "Ethernet Operations";
          container y1731 {
            tailf:info "Y1731 Ethernet OAM Performance Measurement Operations";

            // ip sla * / ethernet y1731 delay *
            list delay {
              tailf:info "Y1731 Delay and Delay Variation Operation";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-mode-name "config-sla-y1731-delay";
              key name;
              leaf name {
                type enumeration {
                  enum "1DM" {
                    tailf:info "1DM frames";
                  }
                  enum DMM {
                    tailf:info "DMM/DMR frames";
                  }
                  enum DMMv1 {
                    tailf:info "DMMv1 frames";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * burst
              leaf burst {
                tailf:info "enable bursting of delay frames";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // ip sla * / ethernet y1731 delay * domain
              leaf domain {
                tailf:info "Specify Domain name";
                type string {
                  tailf:info "WORD;;Specify the Ethernet OAM domain";
                }
              }
              choice evc-or-vlan {
                // ip sla * / ethernet y1731 delay * evc
                leaf evc {
                  tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                  type string {
                    tailf:info "WORD  Specify the EVC Identifier value";
                  }
                }
                // ip sla * / ethernet y1731 delay * vlan
                leaf vlan {
                  tailf:info "Specify the VLAN";
                  type uint16 {
                    tailf:info "<1-4096>;;Specify Vlan value";
                    range "1..4096";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * mac-address
              // ip sla * / ethernet y1731 delay * mpid
              choice mpid-or-mac {
                leaf mac-address {
                  tailf:info "Specify the remote mac-address";
                  type string {
                    tailf:info "H.H.H;;Destination mac-address value";
                  }
                }
                leaf mpid {
                  tailf:info "Specify the remote MPID";
                  type uint16 {
                    tailf:info "<1-8191>;;Specify MPID value";
                    range "1..8191";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * cos
              leaf cos {
                tailf:info "Specify the Class of Service";
                type uint8 {
                  tailf:info "<0-7>;;Specify CoS value";
                  range "0..7";
                }
              }
              // ip sla * / ethernet y1731 delay * source
              container source {
                tailf:info "Specify the local MPID or MAC-Address";
                tailf:cli-flatten-container;
                choice mpid-or-mac {
                  // ip sla * / ethernet y1731 delay * source mac-address
                  leaf mac-address {
                    tailf:info "Specify the remote mac-address";
                    type string {
                      tailf:info "H.H.H;;Destination mac-address value";
                    }
                  }
                  // ip sla * / ethernet y1731 delay * source mpid
                  leaf mpid {
                    tailf:info "Specify the remote MPID";
                    type uint16 {
                      tailf:info "<1-8191>;;Specify MPID value";
                      range "1..8191";
                    }
                  }
                }
              }
            }

            // ip sla * / ethernet y1731 delay receive *
            container delay-receive {
              tailf:cli-drop-node-name;
              container delay {
                tailf:info "Y1731 Delay and Delay Variation Operation";
                list receive {
                  tailf:info "Receive only operation";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  tailf:cli-mode-name "config-sla-y1731-delay";
                  key name;
                  leaf name {
                    type enumeration {
                      enum "1DM" {
                        tailf:info "1DM frames";
                      }
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * domain
                  leaf domain {
                    tailf:info "Specify Domain name";
                    type string {
                      tailf:info "WORD;;Specify the Ethernet OAM domain";
                    }
                  }
                  choice evc-or-vlan {
                    // ip sla * / ethernet y1731 delay receive * evc
                    leaf evc {
                      tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                      type string {
                        tailf:info "WORD  Specify the EVC Identifier value";
                      }
                    }
                    // ip sla * / ethernet y1731 delay receive * vlan
                    leaf vlan {
                      tailf:info "Specify the VLAN";
                      type uint16 {
                        tailf:info "<1-4096>;;Specify Vlan value";
                        range "1..4096";
                      }
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * cos
                  leaf cos {
                    tailf:info "Specify the Class of Service";
                    type uint8 {
                      tailf:info "<0-7>;;Specify CoS value";
                      range "0..7";
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * mac-address
                  // ip sla * / ethernet y1731 delay receive * mpid
                  choice mpid-or-mac {
                    leaf mac-address {
                      tailf:info "Specify the remote mac-address";
                      type string {
                        tailf:info "H.H.H;;Destination mac-address value";
                      }
                    }
                    leaf mpid {
                      tailf:info "Specify the remote MPID";
                      type uint16 {
                        tailf:info "<1-8191>;;Specify MPID value";
                        range "1..8191";
                      }
                    }
                  }
                }
              }
            }

            // ip sla * / ethernet y1731 loss *
            list loss {
              tailf:info "Y1731 Loss Operation";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-mode-name "config-sla-y1731-loss";
              key name;
              leaf name {
                type enumeration {
                  enum LMM {
                    tailf:info "LMM/LMR frames";
                  }
                  enum SLM {
                    tailf:info "SLM/SLR frames";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * burst
              leaf burst {
                tailf:info "enable bursting of SLM frames";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // ip sla * / ethernet y1731 loss * domain
              leaf domain {
                tailf:info "Specify Domain name";
                tailf:cli-hide-in-submode;
                type string {
                  tailf:info "WORD;;Specify the Ethernet OAM domain";
                }
              }
              // ip sla * / ethernet y1731 loss * evc
              // ip sla * / ethernet y1731 loss * vlan
              choice evc-or-vlan {
                leaf evc {
                  tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                  tailf:cli-hide-in-submode;
                  type string {
                    tailf:info "WORD  Specify the EVC Identifier value";
                  }
                }
                leaf vlan {
                  tailf:info "Specify the VLAN";
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-4096>;;Specify Vlan value";
                    range "1..4096";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * mac-address
              // ip sla * / ethernet y1731 loss * mpid
              choice mpid-or-mac {
                leaf mac-address {
                  tailf:info "Specify the remote mac-address";
                  tailf:cli-hide-in-submode;
                  type string {
                    tailf:info "H.H.H;;Destination mac-address value";
                  }
                }
                leaf mpid {
                  tailf:info "Specify the remote MPID";
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-8191>;;Specify MPID value";
                    range "1..8191";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * cos
              leaf cos {
                tailf:info "Specify the Class of Service";
                tailf:cli-hide-in-submode;
                type uint8 {
                  tailf:info "<0-7>;;Specify CoS value";
                  range "0..7";
                }
              }
              // ip sla * / ethernet y1731 loss * source
              container source {
                tailf:info "Specify the local MPID or MAC-Address";
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                choice mpid-or-mac {
                  // ip sla * / ethernet y1731 loss * source mac-address
                  leaf mac-address {
                    tailf:info "Specify the remote mac-address";
                    type string {
                      tailf:info "H.H.H;;Destination mac-address value";
                    }
                  }
                  // ip sla * / ethernet y1731 loss * source mpid
                  leaf mpid {
                    tailf:info "Specify the remote MPID";
                    type uint16 {
                      tailf:info "<1-8191>;;Specify MPID value";
                      range "1..8191";
                    }
                  }
                }
              }

              // ip sla * / ethernet y1731 loss * / availability
              container availability {
                tailf:info "Specify the availability parameters";
                leaf algorithm {
                  tailf:info "Specify the algorithm to use";
                  type enumeration {
                    enum sliding-window {
                      tailf:info "Use a sliding window";
                    }
                    enum static-window {
                      tailf:info "Use a static window";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // ip sla schedule *
      list schedule {
        tailf:info "IP SLAs Entry Scheduling";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key operation-number;
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }

        // ip sla schedule * life
        leaf life {
          tailf:info "Length of time to execute in seconds";
          type union {
            type enumeration {
              enum forever {
                tailf:info "continue running forever";
              }
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Life seconds";
            }
          }
        }

        // ip sla schedule * start-time
        container start-time {
          tailf:info "When to start this entry";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice start-time-choice {
            leaf after {
              tailf:info "Start after a certain amount of time from now";
              type string {
                tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
              }
            }
            leaf now {
              tailf:info "Start now";
              type empty;
            }
            leaf pending {
              tailf:info "Start pending";
              type empty;
            }
            leaf time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
              }
            }
          }
        }

        // ip sla schedule * ageout
        leaf ageout {
          tailf:info "How long to keep this Entry when inactive";
          type uint32 {
            tailf:info "<0-2073600>;;Ageout Seconds";
          }
        }

        // ip sla schedule * recurring
        leaf recurring {
          tailf:info "Probe to be scheduled automatically every day";
          type empty;
        }
      }

      // ip sla reaction-configuration *
      list reaction-configuration {
        tailf:info "IP SLAs Reaction-Configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key operation-number;
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }

        // ip sla reaction-configuration * react
        leaf react {
          tailf:info "Reaction variable to be configured";
          type string {
            tailf:info "monitored-element";
          }
        }

        // ip sla reaction-configuration * action-type
        leaf action-type {
          tailf:info "IP SLAs Reaction Action Type";
          tailf:cli-break-sequence-commands;
          type enumeration {
            enum none {
              tailf:info "No action";
            }
            enum trapAndTrigger {
              tailf:info "Trap and Trigger action";
            }
            enum trapOnly {
              tailf:info "Trap Only action";
            }
            enum triggerOnly {
              tailf:info "Trigger Only action";
            }
          }
        }

        // ip sla reaction-configuration * threshold-value
        container threshold-value {
          tailf:info "Threshold value";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf upper-threshold {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-60000>;;Upper limit for Threshold";
            }
          }
          leaf lower-threshold {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-60000>;;Lower limit for Threshold";
            }
          }
        }

        // ip sla reaction-configuration * threshold-type
        container threshold-type {
          tailf:info "Threshold Type";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice threshold-type-choice {
            leaf average {
              tailf:info "Average over N attempts";
              type uint8 {
                tailf:info "<1-16>;;N Value";
                range "1..16";
              }
            }
            leaf consecutive {
              tailf:info "Consecutive occurrences";
              type uint8 {
                tailf:info "<1-16>;;Number of occurrences";
                range "1..16";
              }
            }
            leaf immediate {
              tailf:info "React immediately";
              type empty;
            }
            leaf never {
              tailf:info "Never react";
              type empty;
            }
            leaf xOfy {
              tailf:info "X out of Y occurrences";
              type uint8 {
                tailf:info "<1-16>;;X Value";
                range "1..16";
              }
            }
          }
        }
      }

      // ip sla enable reaction-alerts
      container enable {
        tailf:info "Enable Event Notifications";
        leaf reaction-alerts {
          tailf:info "Enable Reaction Alert Notifications";
          type empty;
        }
      }
    }

  }


  /// ========================================================================
  /// isdn
  /// ========================================================================

  container isdn {
    tailf:info "ISDN configuration commands";
    leaf switch-type {
      tailf:info "Select the ISDN switch type";
      tailf:cli-full-command;
      type string {
        pattern "primary.*";
      }
    }
  }


  /// ========================================================================
  /// vmps
  /// ========================================================================

  container vmps {
    tailf:info "VMPS settings";

    // vmps reconfirm
    leaf reconfirm {
      tailf:info "Set VMPS reconfirm interval";
      type uint8 {
        tailf:info "Number of minutes between reconfirmations";
        range "0..120";
      }
    }

    // vmps retry
    leaf retry {
      tailf:info "Set VMPS retry count";
      type uint8 {
        tailf:info "<1-10>;;Retry count per server";
        range "1..10";
      }
    }

    // vmps server *
    list server {
      tailf:info "Configure server IP address";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type host-type {
          tailf:info "Hostname or A.B.C.D;;IP address";
        }
      }
      // vmps server * primary
      leaf primary {
        tailf:info "Specify primary server";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 source-route
    // no ipv6 source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-show-no;
      type empty;
    }

    // ipv6 cef
    container cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-display-separated;
      tailf:cli-show-no;
      presence true;

      // ipv6 cef accounting
      container accounting {
        tailf:info "Enable CEF accounting";
        tailf:cli-compact-syntax;
        leaf per-prefix {
          tailf:info "Enable per prefix accounting";
          type empty;
        }
        leaf prefix-length {
          tailf:info "Enable prefix length accounting";
          type empty;
        }
      }

      // ipv6 cef distributed
      leaf distributed {
        tailf:info "Distributed Cisco Express Forwarding";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ipv6 multicast-routing
    leaf multicast-routing {
      tailf:info "Enable IPv6 multicast";
      type empty;
    }

    // ipv6 multicast rpf backoff
    container multicast {
      tailf:info "Configure multicast related commands";
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff delay in "
                +"milliseconds";
              range "200..65535";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff delay in "
                +"milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }
      }
    }

    // ipv6 route
    container route {
      tailf:info "Configure static routes";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "/ios:interface";

      // ipv6 route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding "+
          "instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        //tailf:cli-diff-dependency "/ios:vrf/definition";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ipv6-route-grouping;
      }

      // ipv6 route *
      uses ipv6-route-grouping;
    }

    // ipv6 prefix-list *
    container prefix-list {
      tailf:info "Build a prefix list";
      list prefixes {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of a prefix list";
            pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
              +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
              +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
              +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
              +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
              +'num[^b].*)|(sequence\-numb[^e].*)|'
              +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
          }
        }
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }
        leaf permit {
          tailf:info "Specify packets to forward";
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix <network>/<length>";
          }
        }
        list seq {
          // NOTE: the seq element is not actually mandatory
          // in the Cisco CLI. If it isn't give
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key no;
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
            tailf:key-default "10";
          }
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                tailf:info "<1-128>;;Minimum prefix length";
                range "1..128";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-128>;;Maximum prefix length";
                range "1..128";
              }
            }
          }
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                tailf:info "<1-128>;;Minimum prefix length";
                range "1..128";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-128>;;Maximum prefix length";
                range "1..128";
              }
            }
          }
        }
      }
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ipv6 access-list *
    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          type string {
            tailf:info "User selected string identifying this access list";
          }
        }
        list access-list-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          tailf:cli-case-sensitive;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forwards\n"+
                "remark;;Access list entry comment\n"+
                "sequence;;Sequence number for this entry";
              pattern "(deny .*)|(permit .*)|(remark .*)|(sequence .*)"+
                "|(evaluate .*)";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// subscriber
  /// ========================================================================

  container subscriber {
    tailf:info "Subscriber configuration";

    // subscriber templating
    leaf templating {
      tailf:info "Configure subscriber templating";
      type empty;
    }
  }


  /// ========================================================================
  /// multilink
  /// ========================================================================

  container multilink {
    tailf:info "PPP multilink global configuration";

    // multilink virtual-template
    leaf virtual-template {
      tailf:info "virtual-template interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-4095>;;virtual template number";
        range "1..4095";
      }
    }

    // multilink bundle-name
    leaf bundle-name {
      tailf:info "Select method for naming multilink bundles";
      tailf:cli-full-command;
      type enumeration {
        enum authenticated {
          tailf:info "Use peer's authenticated name";
        }
        enum both {
          tailf:info "Use peer's authenticated name and endpoint "+
            "discriminator";
        }
        enum endpoint {
          tailf:info "Use peer's endpoint discriminator";
        }
        enum rfc {
          tailf:info "Use peer and local authenticated name and endpoint "+
            "discriminator";
        }
      }
    }

  }


  /// ========================================================================
  /// archive
  /// ========================================================================

  container archive {
    tailf:info "Archive the configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-archive";

    // archive / log config
    container log {
      tailf:info "Logging commands";
      container "config" {
        tailf:info "Logging changes to the running configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-archive-log-cfg";
        tailf:cli-full-command;
        tailf:cli-incomplete-no;

        // archive / log config / logging
        container logging {
          tailf:info "Modify config logging parameters";

          // archive / log config / logging enable
          leaf enable {
            tailf:info "Enable the config logger";
            tailf:cli-full-command;
            type empty;
          }

          // archive / log config / logging size
          leaf size {
            tailf:info "Maximum number of logged commands that will be kept "+
              "by the config log";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-1000>;;Queue length (default 100)";
              range "1..1000";
            }
            default 100;
          }
        }

        // archive / log config / hidekeys
        leaf hidekeys {
          tailf:info "suppress output (e.g. passwords) when "+
            "displaying logged commands";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // archive / path
    leaf "path" {
      tailf:info "path for backups";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Write archive path";
      }
    }

    // archive / maximum
    leaf maximum {
      tailf:info "maximum number of backup copies";
      type uint8 {
        tailf:info "<1-14>;;maximum number of backup copies";
        range "1..14";
      }
    }

    // archive / write-memory
    leaf write-memory {
      tailf:info "Enable automatic backup generation during write memory";
      type empty;
    }

  }


  /// ========================================================================
  /// key
  /// ========================================================================

  container "key" {
    tailf:info "Key management";

    // key chain *
    list chain {
      tailf:info "Key-chain management";
      tailf:cli-mode-name "config-keychain";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Key-chain name";
        }
      }

      // key chain * / key *
      list "key" {
        tailf:info "Configure a key";
        tailf:cli-mode-name "config-keychain-key";
        tailf:cli-full-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-2147483647>;;Key identifier";
            range "0..2147483647";
          }
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "Set key string";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf encryption {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum 7 {
                tailf:info "Specifies HIDDEN password will follow";
              }
            }
          }
          leaf "key" {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
            }
          }
        }
      }
    }

  }


  /// ========================================================================
  /// username
  /// ========================================================================

  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    // username * password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf "password" {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }

    // username * privilege
    leaf privilege {
      tailf:info "Set user privilege level";
      type uint8 {
        tailf:info "<0-15>;;User privilege level";
        range "0..15";
      }
    }

    // username * secret
    container secret {
      tailf:info "Specify the secret for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf "encryption" {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED secret will follow";
          }
          enum "4" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
        }
      }
      leaf "secret" {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;The HIDDEN user secret string";
        }
      }
    }
  }


  /// ========================================================================
  /// table-map
  /// ========================================================================
  // Note: Must come before policer aggregate

  list table-map {
    tailf:info "Configure Table Map";
    tailf:cli-mode-name "config-tablemap";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;table-map name";
      }
    }

    // table-map * / map from * to *
    list map {
      tailf:info "map to_value from from_value";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "from to";
      leaf from {
        tailf:info "map from value";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<0-63>;;tablemap from value";
          range "0..63";
        }
      }
      leaf to {
        tailf:info "map to value";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<0-63>;;tablemap to value";
          range "0..63";
        }
      }
    }

    // table-map * / default
    leaf "default" {
      tailf:info "the default behavior for setting value not found in the "+
        "table map";
      type union {
        type uint8 {
          tailf:info "<0-99>;;tablemap default value";
          range "0..99";
        }
        type enumeration {
          enum copy {
            tailf:info "set the default behavior for value not found in "+
              "the table map to copy";
          }
          enum ignore {
            tailf:info "set the default behavior for value not found in "+
              "the table map to ignore";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// sdm
  /// ========================================================================

  container sdm {
    tailf:info "Switch database management";
    container prefer {
      tailf:info "Config TCAM and ASIC RAM size. "+
        "Warning: need to reset switch for configuration to take effect";
      tailf:cli-delete-when-empty;
      presence true;
      choice sdm-prefer-choice {
        leaf "default" {
          type empty;
        }
        leaf qos {
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// mls
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container mls {
    tailf:info "mls global commands";
    tailf:cli-incomplete-no;

    // mls acl
    container acl {
      tailf:info "MLS ACL operation";

      // mls acl tcam
      container tcam {
        tailf:info "ACL TCAM";
        leaf default-result {
          tailf:info "Default result to be used during tcam programming";
          type enumeration {
            enum bridge {
              tailf:info "Bridge result";
            }
            enum deny {
              tailf:info "Deny result";
            }
            enum permit {
              tailf:info "Permit result";
            }
          }
        }

        container log-update {
          tailf:info "Log TCAM updates";
          presence true;
          leaf rate-limit-msg {
            tailf:info "Enable/Disable syslog ratelimiting";
            type enumeration {
              enum disable {
                tailf:info "Disable ratelimiting syslog";
              }
              enum enable {
                tailf:info "Enable syslog ratelimiting at 1 per second";
              }
            }
          }
        }

        // no mls acl tcam share-global
        leaf share-global {
          tailf:info "share global deny or permit any entries";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // mls cef
    container cef {
      tailf:info "cef keyword";
      container error {
        leaf action {
          type enumeration {
            enum reset;
            enum freeze;
          }
        }
      }
    }

    // mls ip
    container ip {
      tailf:info "ip keyword";

      // mls ip multicast
      container multicast {
        tailf:info "multicast keyword";
        tailf:cli-display-separated;
        presence true;

        // mls ip multicast consistency-check
        container consistency-check {
          tailf:info "Set consistency checking characteristics";
          presence true;
          container "type" {
            tailf:info "Set consistency checker type";
            // mls ip multicast consistency-check type rp-sp
            container rp-sp {
              tailf:info "Scan mlsm for Route, Switch Processor consistency";
              presence true;
            }
          }
          leaf settle-time {
            tailf:info "Settle time for entry/oif for consistancy-checker";
            type uint16 {
              tailf:info "<2-3600>;;Settle time for entry/oif in seconds";
              range "2..3600";
            }
          }
        }
        leaf flow-stat-timer {
          tailf:info "timer for flow statistic used by mls-msc and mlsm";
          type uint8 {
            tailf:info "<1-100>;;#seconds between one batch and another";
            range "1..100";
          }
        }
      }
    }

    // mls aging
    container aging {
      tailf:info "L3 aging";

      // mls aging fast
      container fast {
        tailf:info "L3 fast aging";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf time {
          tailf:info "fast aging timeout value";
          type uint8 {
            tailf:info "<1-128>;;L3 fast aging time in seconds";
            range "1..128";
          }
        }
        leaf threshold {
          tailf:info "fast aging threshold";
          type uint8 {
            tailf:info "<1-128>;;L3 fast aging theshold packet count";
            range "1..128";
          }
        }
      }

      // mls aging normal
      container normal {
        tailf:info "normal aging keyword";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<32-4092>;;L3 aging timeout in second";
            range "32..4092";
          }
        }
      }
    }

    // mls netflow
    container netflow {
      tailf:info "netflow keyword";
      tailf:cli-delete-when-empty;
      presence true;

      // mls netflow interface
      leaf interface {
        type empty;
      }

      // mls netflow usage notify
      container usage {
        container notify {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<20-100>;;threshold percentage";
              range "20..100";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<120-1000000>;;time interval in seconds";
              range "120..1000000";
            }
          }
        }
      }
    }

    // mls flow
    container flow {
      tailf:info "flowmask keyword";
      leaf ip {
        tailf:info "flowmask ip keyword";
        type enumeration {
          enum interface-destination {
            tailf:info "interface-destination flow keyword";
          }
          enum interface-destination-source {
            tailf:info "interface-destination-source flow keyword";
          }
          enum interface-full {
            tailf:info "interface-full flow keyword";
          }
          enum interface-source {
            tailf:info "interface-source only flow keyword";
          }
        }
      }
    }

    // mls qos
    container mls-qos-conf {
      tailf:cli-drop-node-name;
      leaf qos {
        type empty;
      }
    }

    // mls qos
    container qos {
      tailf:info "QoS parameters";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // mls qos aggregate-policer *
      list aggregate-policer {
        tailf:info "Assign aggregate policer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;aggregate policer name";
          }
        }
        leaf target-bit-rate {
          tailf:cli-drop-node-name;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        leaf burst-normal {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint32 {
            tailf:info "<1000-31250000>;;Normal burst bytes";
            range "1000..31250000";
          }
        }
        leaf burst-max {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          when "../burst-normal" {
            tailf:dependency "../burst-normal";
          }
          type uint32 {
            tailf:info "<1000-31250000>;;Maximum burst bytes";
            range "1000..31250000";
          }
        }
        leaf pir {
          tailf:info "PIR";
          tailf:cli-optional-in-sequence;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        container conform-action {
          tailf:info "action when rate is not exceeded";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice action-choice {
            leaf drop {
              tailf:info "drop packet";
              type empty;
            }
            leaf set-dscp-transmit {
              tailf:info "set dscp and send it";
              type dscp-type;
            }
            leaf set-mpls-exp-imposition-transmit {
              tailf:info "set exp at tag imposition and send it";
              type uint8 {
                tailf:info "<0-7>;;new exp";
                range "0..7";
              }
            }
            leaf set-prec-transmit {
              tailf:info "rewrite packet precedence and send it";
              type uint8 {
                tailf:info "<0-7>;;new precedence";
                range "0..7";
              }
            }
            leaf transmit {
              tailf:info "transmit packet";
              type empty;
            }
          }
        }
        leaf exceed-action {
          tailf:info "action when rate is exceeded";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
        leaf violate-action {
          tailf:info "action when rate violated";
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
      }

      // mls qos rewrite
      container rewrite {
        tailf:info "packet qos rewrite enable/disable";
        container ip {
          tailf:info "ip packet qos rewrite enable/disable";
          container dscp {
            tailf:info "packet ip dscp rewrite enable/disable";
            presence true;
            leaf slot {
              tailf:info "slot number";
              type string {
                tailf:info "WORD;;Slots seperated by commas. Valid slots: 1,2,"
                  +"3,4,5,6,7,8,9";
              }
            }
          }
        }
      }

      // mls qos map
      container map {
        tailf:info "Define QoS mapping";

        // mls qos map cos-dscp *
        leaf-list cos-dscp {
          tailf:info "cos-dscp map: eight dscp values for cos 0-7";
          tailf:cli-flat-list-syntax;
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "<0-63>;;8 dscp values separated by spaces";
            range "0..63";
          }
        }

        // mls qos map ip-prec-dscp *
        leaf-list ip-prec-dscp {
          tailf:info "dscp values for ip precedences 0 - 7";
          tailf:cli-flat-list-syntax;
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "<0-63>;;8 dscp values separated by spaces";
            range "0..63";
          }
        }

        // mls qos map exp-mutation *
        list exp-mutation {
          tailf:info "exp-mutation map keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;exp-mutation map name";
            }
          }
          leaf mutated-exp1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp4 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp5 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp6 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp7 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp8 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
        }
      }

      // mls qos srr-queue
      container srr-queue {
        // mls qos srr-queue *
        list cos-dscp-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "direction maptype queue threshold";
          leaf direction {
            type enumeration {
              enum "input" {}
              enum "output" {}
            }
          }
          leaf maptype {
            type enumeration {
              enum cos-map {}
              enum dscp-map {}
            }
          }
          leaf queue {
            tailf:cli-expose-key-name;
            type uint8 {
            }
          }
          leaf threshold {
            tailf:cli-expose-key-name;
            type uint8 {
            }
          }
          list values {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key "value";
            leaf "value" {
              tailf:cli-multi-word-key;
              type string;
            }
          }
        }

        // mls qos srr-queue input
        container "input" {

          // mls qos srr-queue input priority-queue *
          list priority-queue {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
              }
            }
            leaf bandwidth {
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type uint8;
            }
          }

          // mls qos srr-queue input bandwidth
          container bandwidth {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf weight1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {}
            }
            leaf weight2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {}
            }
          }

          // mls qos srr-queue input threshold *
          list threshold {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
              }
            }
            leaf threshold-percentage1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {}
            }
            leaf threshold-percentage2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {}
            }
          }

          // mls qos srr-queue input buffers
          container buffers {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf percentage1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {}
            }
            leaf percentage2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {}
            }
          }
        }
      }

      // mls qos queue-set
      container queue-set {
        container "output" {

          // mls qos queue-set output threshold
          list threshold-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "queue threshold";
            leaf queue {
              type uint8 {
              }
            }
            leaf threshold {
              tailf:cli-expose-key-name;
              type uint8 {}
            }
            leaf drop-threshold1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {}
            }
            leaf drop-threshold2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {}
            }
            leaf reserved-threshold {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {}
            }
            leaf maximum-threshold {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {}
            }
          }

          // mls qos queue-set output buffers
          list buffers-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
              }
            }
            container buffers {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf allocation1 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {}
              }
              leaf allocation2 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {}
              }
              leaf allocation3 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {}
              }
              leaf allocation4 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {}
              }
            }
          }
        }
      }
    }

    // mls rate-limit
    container rate-limit {
      tailf:info "Rate limit different behaviors";

      // mls rate-limit multicast ipv4 igmp
      container multicast {
        tailf:info "Rate limiting for Multicast packets";
        container ipv4 {
          tailf:info "Rate limiters for IPv4 traffic";
          container igmp {
            tailf:info "Rate limiting of the IGMP protocol packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf pps {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<10-1000000>;;packets per second";
                range "10..1000000";
              }
            }
            leaf packets-in-burst {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;packets in burst";
                range "1..255";
              }
            }
          }
        }
      }

      // mls rate-limit all
      container all {
        tailf:info "Rate Limiting for both Unicast and Multicast packets";
        container ttl-failure {
          tailf:info "TTL failure cases";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf pps {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
      }

      // mls rate-limit layer2
      container layer2 {
        tailf:info "layer2 protocol cases";

        // mls rate-limit layer2 l2pt
        container l2pt {
          tailf:info "layer2 protocol tunnelling packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }

        // mls rate-limit layer2 pdu
        container pdu {
          tailf:info "layer2 protocol data unit packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }

          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
      }

    }

    // mls verify
    container verify {
      tailf:info "enable hardware packet parsing error checks";
      container ip {
        tailf:info "check on IP packets";

        // no mls verify ip checksum
        leaf checksum {
          tailf:info "check for packet checksum errors";
            tailf:cli-boolean-no;
            type boolean;
            default true;
        }

        container "length" {
          tailf:info "check for packet length errors";

          // no mls verify ip length consistent
          leaf consistent {
            tailf:info "check length in header against physical frame length";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
          // no mls verify ip length minimum
          leaf minimum {
            tailf:info "check for minimum packet length";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
        leaf same-address {
          tailf:info "check for packet having equal source and destination IP "
            +"addresses";
          type empty;
        }
        leaf syslog {
          tailf:info "syslog packet parse errors";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// policer
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container policer {
    tailf:info "Switch policer";

    // policer aggregate *
    list aggregate {
      tailf:info "Named aggregate policer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;aggregate policer Name";
        }
      }
      // cir <cir-bps>
      leaf cir {
        tailf:info "Committed information rate";
        type uint32 {
          tailf:info "<8000-1000000000>;;Bits per second";
          range "8000..1000000000";
        }
      }
      // bc <burst>
      leaf bc {
        tailf:info "Conform burst";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<8000-1000000000>;;Burst bytes";
          range "8000..1000000000";
        }
      }
      // conform-action
      leaf conform-action {
        tailf:info "action when rate is within conform and conform + "+
          "exceed burst";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf set-qos-transmit {
        tailf:info "set qos-group and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-99>;;new qos-group";
          range "0..99";
        }
      }
      leaf set-dot1ad-dei-transmit {
        tailf:info "set dei and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-1>;;new dei value";
          range "0..1";
        }
      }
      leaf set-prec-transmit {
        tailf:info "rewrite packet precedence and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type prec_value-type;
      }
      container set-prec-transmit-table {
        when "../set-prec-transmit";
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
      leaf set-dscp-transmit {
        tailf:info "set dscp and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type dscp-type;
      }
      container set-dscp-transmit-table {
        when "../set-dscp-transmit";
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
      leaf set-cos-transmit {
        tailf:info "set cos and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type cos_value-type;
      }
      container set-cos-transmit-table {
        when "../set-cos-transmit";
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;table-map name";
          }
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
      leaf transmit {
        tailf:info "transmit packet";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      // exceed-action
      leaf exceed-action {
        tailf:info "action when rate is within conform and conform + "+
          "exceed burst";
        type empty;
      }
      leaf drop {
        tailf:info "drop packet";
        when "../exceed-action";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      container exceed-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf transmit {
          tailf:info "transmit packet";
          when "../../exceed-action";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Enter redundancy mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-red";
    presence true;

    // redundancy / maintenance-mode
    leaf maintenance-mode {
      tailf:info "Enable/Disable maintenance mode ";
      //FIXME: conform hook
      type empty;
    }

    // redundancy / linecard-group *
    list linecard-group {
      tailf:info "Enter linecard redundancy submode";
      tailf:cli-mode-name "config-red-lc";
      tailf:cli-incomplete-command;
      tailf:cli-recursive-delete;
      key id;
      leaf id {
        type uint32 {
          tailf:info "ID;;linecard-group identifier";
        }
      }
      leaf cable {
        tailf:info "CMTS LC Redundancy type";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // redundancy / linecard-group * / description
      leaf "description" {
        tailf:info "Assign linecard group description";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Linecard group description";
        }
      }

      // redundancy / linecard-group * / rf-switch
      container rf-switch {
        tailf:info "Specify/Change RF-switch parameters (Optional Command)";
        // redundancy / linecard-group * / rf-switch snmp-community
        leaf snmp-community {
          tailf:info "SNMP community name";
          type string {
            tailf:info "WORD;;snmp community name";
          }
        }
      }

      // redundancy / linecard-group * / member subslot *
      container member {
        tailf:info "Add or remove a member from this LC redundancy";
        list subslot {
          tailf:info "subslot number to be added or removed from this "+
            "linecard group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          tailf:cli-suppress-list-no;
          key id;
          leaf id {
            type string {
              tailf:info "<5-8>/<0-1>";
            }
          }
          // redundancy / linecard-group * / member subslot * working
          leaf working {
            tailf:info "working slot in this linecard group";
            type empty;
          }

          // redundancy / linecard-group * / member subslot * protect
          container protect {
            tailf:info "protect slot of this linecard group";
            tailf:cli-display-separated;
            presence true;
            choice config-choice {

              // .. member subslot * protect config ?
              leaf "config" {
                tailf:info "Specifiy the subslot for cable upstream config";
                tailf:cli-incomplete-no;
                type string {
                  tailf:info "<5-8>/<0-1>;;Slot/Subslot";
                }
              }

              // .. no member subslot * protect config
              container no-config {
                tailf:cli-drop-node-name;
                leaf "config" {
                  tailf:cli-incomplete-command;
                  tailf:cli-boolean-no;
                  tailf:cli-full-command;
                  type boolean;
                  default true;
                }
              }
            }
          }
        }
      }

      // redundancy / linecard-group * / no revertive
      container conf {
        tailf:cli-drop-node-name;
        leaf revertive {
          tailf:info "Make redundancy relationship revertive";
          type empty;
        }
      }
    }

    // redundancy / mode
    leaf mode {
      tailf:info "redundancy mode for this chassis";
      type enumeration {
        enum rpr {
          tailf:info "Route Processor Redundancy";
        }
        enum rpr-plus {
          tailf:info "Route Processor Redundancy Plus";
        }
        enum sso {
          tailf:info "Stateful Switchover";
        }
        enum none {
          tailf:info "None";
        }
      }
    }

    // redundancy / main-cpu
    container main-cpu {
      tailf:info "Enter main-cpu mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-r-mc";

      // redundancy / main-cpu / auto-sync
      container auto-sync {
        leaf running-config {
          type empty;
        }
        leaf config-register {
          type empty;
        }
        leaf bootvar {
          type empty;
        }
      }

      // redundancy / main-cpu / switchover
      container switchover {
        tailf:info "Configuration of switchover";

        // redundancy / main-cpu / switchover pxf restart
        container pxf {
          tailf:info "PXF switchover options";
          container restart {
            tailf:info "PXF restarts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf number-of-crashes {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-25>;;Number of PXF restarts before a switchover";
                range "1..25";
              }
            }
            leaf time-period {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-120>;;Interval (in hours) over which restart "+
                  "count is accumulated";
                range "0..120";
              }
            }
          }
        }
      }
    }

    // redundancy / interchassis group *
    container interchassis {
      tailf:info "Enter interchassis mode";
      list group {
        tailf:info "Enter the redundancy group number";
        tailf:cli-mode-name "conppfig-r-ic";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;The redundancy group number";
            range "1..4294967295";
          }
        }

        // redundancy / interchassis group * / member ip
        container member {
          tailf:info "specify a redundancy group member";
          leaf ip {
            tailf:info "specify the redundancy group member using an ip "+
              "address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;the ip address of the remote redundancy "+
                "group member";
            }
          }
        }

        // redundancy / interchassis group * / mlacp
        container mlacp {
          tailf:info "mLACP interchassis redundancy group subcommands";
          // redundancy / interchassis group * / mlacp system-mac
          leaf system-mac {
            tailf:info "mLACP redundancy group mac address";
            type string {
              tailf:info "H.H.H;;mLACP redundancy group mac address";
            }
          }
          // redundancy / interchassis group * / mlacp system-priority
          leaf system-priority {
            tailf:info "mLACP system priority";
            type uint16 {
              tailf:info "<0-65535>;;Priority value";
            }
          }
          // redundancy / interchassis group * / mlacp node-id
          leaf node-id {
            tailf:info "mLACP node-id, appended to LACP port ids";
            type uint8 {
              tailf:info "<0-7>;;mLACP node-id";
              range "0..7";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================
  // Note: must come before policy-map.

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-suppress-list-no;
    tailf:cli-delete-when-empty;
    tailf:cli-no-key-completion;
    tailf:cli-sequence-commands;
    tailf:cli-full-command;

    // class-map *
    key name;
    leaf name {
      tailf:cli-disallow-value "type|match-any|match-all";
      type string {
        tailf:info "WORD;;class-map name";
      }
    }

    // class-map type
    leaf "type" {
      tailf:info "type of the class-map";
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type enumeration {
        enum access-control {
          tailf:info "access-control specific class-map";
        }
        enum inspect {
          tailf:info "Configure Firewall Class Map";
        }
        enum logging {
          tailf:info "Class map for control-plane packet logging";
        }
        enum port-filter {
          tailf:info "Class map for port filter";
        }
        enum queue-threshold {
          tailf:info "Class map for queue threshold";
        }
        enum stack {
          tailf:info "class-map for protocol header stack specification";
        }
      }
    }

    // class-map <protocol>
    leaf protocol {
      when "../type = 'inspect'";
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum aol {
          tailf:info "Configure CBAC class-map for IM-AOL protocol";
        }
        enum edonkey {
          tailf:info "eDonkey";
        }
        enum fasttrack {
          tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster...";
        }
        enum gnutella {
          tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, "
            +"Morpheus ...";
        }
        enum http {
          tailf:info "Configure CBAC class-map for HTTP protocol";
        }
        enum imap {
          tailf:info "Configure CBAC class-map for IMAP protocol";
        }
        enum kazaa2 {
          tailf:info "Kazaa Version 2";
        }
        enum msnmsgr {
          tailf:info "Configure CBAC class-map for IM-MSN protocol";
        }
        enum pop3 {
          tailf:info "Configure CBAC class-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC class-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC class-map for RPC protocol";
        }
        enum ymsgr {
          tailf:info "Configure CBAC class-map for IM-YAHOO protocol";
        }
      }
    }

    // class-map * <match-any|match-all>
    leaf prematch {
      tailf:cli-drop-node-name;
      tailf:cli-no-keyword;
      tailf:cli-prefix-key;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under "+
            "this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this "+
            "classmap";
        }
      }
      mandatory true;
    }

    // class-map * / description
    leaf "description" {
      tailf:info "Class-Map description";
      tailf:cli-break-sequence-commands;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 "+
          "characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate this match result";
        uses class-map-match-grouping;
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure QoS Policy Map";
    tailf:cli-mode-name "config-pmap";
    // When deleting policy-map, delete before following config:
    tailf:cli-diff-dependency "../class-map";
    tailf:cli-diff-dependency "../mls/qos/aggregate-policer";
    tailf:cli-diff-dependency "../policer/aggregate";
    tailf:cli-diff-dependency "../tailfned/police";

    key name;
    leaf name {
      tailf:cli-disallow-value "(type)|(http)|(im)|(imap)|(p2p)"+
        "|(pop3)|(smtp)|(sunrpc)";
      type string {
        tailf:info "WORD;;policy-map name";
      }
    }

    leaf "type" {
      tailf:info "type of the policy-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum inspect;
      }
    }

    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum http {
          tailf:info "Configure CBAC policy-map for HTTP protocol";
        }
        enum im {
          tailf:info "Configure CBAC policy-map for IM protocol";
        }
        enum imap {
          tailf:info "Configure CBAC policy-map for IMAP protocol";
        }
        enum p2p {
          tailf:info "Configure CBAC policy-map for P2P protocols";
        }
        enum pop3 {
          tailf:info "Configure CBAC policy-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC policy-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC policy-map for RPC protocol";
        }
      }
    }

    // policy-map * / description
    leaf "description" {
      tailf:info "Policy-Map description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this policy-map "+
          "(up to 200 characters)";
        length "1..200";
      }
    }

    // policy-map * / class *
    list class {
      tailf:info "policy criteria";
      tailf:cli-mode-name "config-pmap-c";
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        type union {
          type string {
            tailf:info "WORD;;class-map name";
          }
          type enumeration {
            enum class-default {
              tailf:info "System default class matching otherwise "+
                "unclassified packet";
            }
          }
        }
      }
      // policy-map * / class * / type
      leaf "type" {
        tailf:info "type of the class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum inspect {
            tailf:info "Configure CBAC Class Map";
          }
        }
      }
      // policy-map * / class * / policy
      container policy {
        when "../../type = 'inspect'";
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf action {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type enumeration {
            enum drop {
              tailf:info "Drop the packet";
            }
            enum inspect {
              tailf:info "Context-based Access Control Engine";
            }
            enum pass {
              tailf:info "Pass the packet";
            }
          }
        }
        leaf log {
          tailf:info "Send logging message for drop";
          when "../action = 'drop'";
          type empty;
        }
        leaf parameter-map {
          tailf:cli-drop-node-name;
          when "../action = 'inspect'";
          type string;
          tailf:non-strict-leafref {
            path "/ios:parameter-map/type/inspect/name";
          }
        }
      }
      // policy-map * / class * / inspect-police
      container inspect-police {
        when "../policy/action = 'inspect'";
        tailf:cli-drop-node-name;
        container police {
          tailf:info "Police";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf rate {
            tailf:info "Specify police rate";
            type uint32 {
              tailf:info "<8000-2000000000>;;Rate value in bps";
              range "8000..2000000000";
            }
          }
          leaf burst {
            tailf:info "Specify 'burst' parameter";
            type uint32 {
              tailf:info "<1000-512000000>;;Burst value in bytes";
              range "1000..512000000";
            }
          }
        }
      }
      // policy-map * / class * / bandwidth
      container bandwidth {
        tailf:info "Bandwidth";
        leaf bits {
          tailf:cli-drop-node-name;
          type uint32 {
            range "8..2000000";
            tailf:info "<8-2000000>;;Kilo Bits per second";
          }
        }
        // policy-map * / class * / bandwidth percent
        leaf percent {
          tailf:info "% of total Bandwidth";
          tailf:cli-remove-before-change;
          type percentage-type;
        }
        container remaining {
          tailf:info "% of the remaining bandwidth";
          leaf percent {
            tailf:info "% of the remaining bandwidth";
            type percentage-type;
          }
        }
      }
      // policy-map * / class * / compression
      container compression {
        tailf:info "Activate Compression";
        presence "Activate Compression";
        container header {
          tailf:info "configure header compression";
          presence "configure header compression";
          leaf ip {
            tailf:info "configure ip header compression";
            type enumeration {
              enum rtp {
                tailf:code-name "header_rtp";
                tailf:info "configure rtp header compression";
              }
              enum tcp {
                tailf:info "configure tcp header compression";
              }
            }
          }
        }
      }
      // policy-map * / class * / drop
      leaf drop {
        tailf:info "Drop all packets";
        tailf:cli-full-command;
        type empty;
      }
      // policy-map * / class * / estimate
      container estimate {
        tailf:info "estimate resources required for this class";
        container bandwidth {
          presence "bandwidth required to service this class";
          tailf:info "bandwidth required to service this class";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          container delay-one-in {
            tailf:info "specify QoS target delay";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf doi {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                range "50..1000000";
                tailf:info "<50-1000000>;;delay one packet "+
                  "of N";
              }
            }

            leaf milliseconds {
              type uint32 {
                range "8..1000" {
                  tailf:info "<8-1000>;;worst-case "+
                    "milliseconds of delay";
                }
              }
            }
          }
          leaf drop-one-in {
            tailf:info "specify QoS target loss rate";
            type uint32 {
              tailf:info "<50-1000000>;;drop one packet of N";
            }
          }
        }
      }
      // policy-map * / class * / fair-queue
      // class-default: fair-queue [number-of-dynamic-queues]
      // DWFQ: fair-queue
      // policy-map: fair-queue [queue-limit queue-value]
      // NOT SUPPORTED:
      // air-queue [congestive-discard-threshold [dynamic-q [reservable-q]]]
      container fair-queue {
        tailf:info "Enable Flow-based Fair Queuing in this Class";
        tailf:cli-reset-container;
        presence true;
        leaf dynamic-queues {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            range "16|32|64|128|256|512|1024|2048|4096" {
              tailf:info "<16-4096>;;Number Dynamic Conversation "+
                "Queues";
            }
          }
        }
        leaf queue-limit {
          tailf:info "per flow queue limit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-32768>;;packets";
            range "1..32768";
          }
        }
      }
      // policy-map * / class * / netflow-sampler
      leaf netflow-sampler {
        tailf:info "NetFlow action";
        tailf:cli-full-command;
        // should be leafref to sampler
        type string {
          tailf:info "WORD;;Name of the flow sampler";
        }
      }

      // policy-map * / class * / police aggregate
      container police-aggregate {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        container police {
          tailf:info "Police";
          leaf aggregate {
            tailf:info "Choose aggregate policer for current class";
            tailf:cli-diff-dependency "../../../police-policy-map/police/cir" {
              tailf:cli-trigger-on-set;
            }
            type string {
              tailf:info "WORD;;enter aggregate-policer name";
            }
          }
        }
      }

      // policy-map * / class * / police ?
      choice police-choice {

        // police "cirmode" - (policy map)
        // police cir <bps> [[bc <burst-normal>] [be <burst-max>]]
        //        [pir <bps> [be <burst-bytes>]] ACTIONS
        // NOTE: cir, bc & be keywords are mandatory in this model.
        //       Java code will add missing cir,bc and be in show().
        case police-cirmode-case {
          container police-policy-map {  //NEW: police-cirmode
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              when "contains(../../../../tailfned/police, 'cirmode')" {
                tailf:dependency "../../../../tailfned/police";
              }
              // cir <bps>
              leaf cir {
                tailf:info "Committed information rate";
                tailf:cli-hide-in-submode;
                tailf:cli-diff-dependency
                  "../../../police-aggregate/police/aggregate" {
                  tailf:cli-trigger-on-set;
                }
                type police-bps-type;
              }
              // [bc <burst-normal>]
              leaf bc {
                tailf:info "Conform burst";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-type;
              }
              // [be <burst-max>]
              leaf be {
                when "../bc";
                tailf:info "Excess burst";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-type;
              }
              // [pir <bps> [be <burst-bytes>]]
              leaf pir {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-bps-type;
              }
              container pir-be {
                when "../pir";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-flatten-container;
                tailf:cli-hide-in-submode;
                leaf be {
                  tailf:info "Excess burst";
                  type police-burst-type;
                }
              }
              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }

        // police cir percent (combo of percent & policy-map versions)
        // police cir percent <percentage>
        //    [bc] <burst> ms] [be [<burst> ms]
        //    [pir percent <percentage> [be <burst> ms]] ACTIONS
        case police-cir-percent-case {
          container police-cir-percent {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container cir {
                tailf:info "Committed information rate";
                container percent {
                  tailf:info "% of interface bandwidth for Committed "+
                    "information rate";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pmap-c-police";
                  tailf:cli-incomplete-command;
                  tailf:cli-flatten-container;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  // percent <percentage>
                  leaf percentage {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type percentage-type;
                  }
                  // [bc <burst> ms]
                  leaf bc {
                    tailf:info "Conform burst";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                  container bc-ms {
                    when "../bc";
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // [be [<burst> ms]
                  leaf be {
                    when "../bc-ms/ms" {
                      tailf:dependency "../bc-ms/ms";
                    }
                    tailf:info "Excess burst";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                  container be-ms {
                    when "../be";
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // [pir percent <percentage> [be <burst> ms]]
                  container pir {
                    tailf:info "Peak Information Rate";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    leaf percent {
                      tailf:info "% of interface bandwidth for Peak "+
                        "Information Rate";
                      type percentage-type;
                    }
                  }
                  container pir-be {
                    when "../pir";
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-flatten-container;
                    tailf:cli-hide-in-submode;
                    leaf be {
                      tailf:info "Excess burst";
                      type uint16 {
                        tailf:info "<1-2000>;;Burst ms";
                      }
                    }
                  }
                  container pir-be-ms {
                    when "../pir-be/be" {
                      tailf:dependency "../pir-be/be";
                    }
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    tailf:cli-flatten-container;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // conform-action | exceed-action | violate-action
                  uses police-action-grouping;
                }
              }
            }
          }
        }

        // police rate (control-plane)
        // police rate <units> <pps|bps> [burst <burst-in-x> <packets|bytes>]
        //   [peak-rate <peak-rate-in-xps> <pps|bps>]
        //   [peak-burst <peak-burst-in-x> <packets|bytes>]
        //   [conform-action <action>]
        case police-rate-unit-case {
          container police-rate-unit {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container rate {
                tailf:info "Specify police rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // <units>
                leaf "units" {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type uint64 {
                    tailf:info "<1-2000000000>;;Rate value in the range "+
                      "8000-2,000,000,000 bps or 1-2,000,000 pps";
                  }
                }
                // <pps|bps>
                leaf xps {
                  tailf:cli-no-keyword;
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type police-pps-bps-type;
                }
                // [burst <burst-in-x> <packets|bytes>]
                container burst {
                  tailf:info "Specify 'burst' parameter";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  leaf burst-value {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<1-512000000>;;Burst value in "+
                        "packets/bytes";
                    }
                  }
                  leaf burst-type {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-packets-bytes-type;
                  }
                }
                // [peak-rate <peak-rate-in-xps> <pps|bps>]
                container peak-rate {
                  tailf:info "Specify peak rate";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  tailf:cli-hide-in-submode;
                  leaf peak-rate-value {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<1-512000000>;;Peak-rate value in "+
                        "packets or bytes per second";
                      range "1..512000000";
                    }
                  }
                  leaf xps {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    type police-pps-bps-type;
                  }
                }
                // [peak-burst <peak-burst-in-x> <packets|bytes>]
                container peak-burst {
                  tailf:info "Specify 'peak-burst' parameter for peak-rate";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  tailf:cli-hide-in-submode;
                  leaf burst-value {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<1-512000000>;;Burst value in "+
                        "packets/bytes";
                    }
                  }
                  leaf burst-type {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    type police-packets-bytes-type;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }


        // police rate percent (control-plane)
        // police rate percent <percentage> [burst <ms> ms]
        //    [peak-rate percent <percentage>] [peak-burst <ms> ms]
        case police-rate-percent-case {
          container police-rate-percent {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container rate {
                tailf:info "Specify police rate";
                container percent {
                  tailf:info "% of interface bandwidth for rate";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pmap-c-police";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  // <percentage>
                  leaf percentage {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type percentage-type;
                  }
                  // [burst <ms> ms]
                  leaf burst {
                    tailf:info "Specify 'burst' parameter";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    type uint16 {
                      tailf:info "<1-2000>;;Burst value in milliseconds";
                    }
                  }
                  leaf ms {
                    when "../burst";
                    tailf:info "Treat 'burst' value in milliseconds";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                  // [peak-rate percent <percentage>]
                  container peak-rate {
                    tailf:info "Specify peak rate";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-flatten-container;
                    leaf percent {
                      tailf:info "% of interface bandwidth for peak-rate";
                      type percentage-type;
                    }
                  }
                  // [peak-burst <ms> ms]
                  leaf peak-burst {
                    tailf:info "Specify 'peak-burst' parameter for "+
                      "'peak-rate'";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-2000>;;Peak burst value in "+
                        "milliseconds";
                    }
                  }
                  container peak-burst-ms {
                    when "../peak-burst";
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    tailf:cli-flatten-container;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // conform-action | exceed-action | violate-action
                  uses police-action-grouping;
                }
              }
            }
          }
        }

        // police rate pdp
        // police rate pdp [burst <bytes>]
        //    [peak-rate pdp [peak-burst <bytes>]] ACTIONS
        case police-rate-pdp-case {
          container police-rate-pdp {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container rate {
                tailf:info "Specify police rate";
                container pdp {
                  tailf:info "% of interface bandwidth for rate";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pmap-c-police";
                  tailf:cli-flatten-container;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  // [burst <bytes>]
                  leaf burst {
                    tailf:info "Conform burst";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type police-burst-type;
                  }
                  // [peak-rate pdp [peak-burst <bytes>]]
                  leaf peak-rate {
                    tailf:info "Specify peak rate";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type enumeration {
                      enum "pdp" {
                      }
                    }
                  }
                  leaf peak-burst {
                    when "../peak-rate";
                    tailf:info "Specify 'peak-burst' parameter for "+
                      "'peak-rate'";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type police-burst-type;
                  }
                  // conform-action | exceed-action | violate-action
                  uses police-action-grouping;
                }
              }
            }
          }
        }

        // police flow (policy-map)
        // police flow [mask {dest-only | full-flow | src-only}]
        //    <bps> [<burst-normal>] ACTIONS
        case police-flow-case {
          container police-flow {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container flow {
                tailf:info "police each flow";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // [mask {dest-only | full-flow | src-only}]
                leaf mask {
                  tailf:info "flow mask to be used for policing";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type enumeration {
                    enum dest-only {
                      tailf:info "destination-address only flow mask";
                    }
                    enum full-flow {
                      tailf:info "full flow mask";
                    }
                    enum src-only {
                      tailf:info "source-address only flow mask";
                    }
                  }
                }
                // <bps>
                leaf bps {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type police-bps-type;
                }
                // [<burst-normal>]
                leaf burst-normal {
                  when "../bps";
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type police-burst-type;
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }

        // police "bpsflat" - (Catalyst 4500)
        // police <bps> bps <byte> byte ACTIONS
        case police-bpsflat-case {
          container police-catalyst { // NEW: police-bpsflat
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              when "contains(../../../../tailfned/police, 'bpsflat')" {
                tailf:dependency "../../../../tailfned/police";
              }
              // <bps> bps
              leaf bps-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "<32000-32000000000>;;Rate in bits per second "+
                    "(postfix k, m, g optional; decimal point allowed)";
                }
              }
              leaf bps {
                when "../bps-value" {
                  tailf:dependency "../bps-value";
                }
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type empty;
              }
              // <byte> byte
              leaf byte-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "<32000-32000000000>;;(postfix k, m, g "+
                    "optional; decimal point allowed)";
                }
              }
              leaf byte {
                when "../byte-value" {
                  tailf:dependency "../byte-value";
                }
                tailf:cli-hide-in-submode;
                type empty;
              }
              // conform-action | exceed-action | violate-action
              container actions {
                tailf:cli-no-keyword;
                tailf:cli-break-sequence-commands;
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-hide-in-submode;
                // policy-map * / class * / police ? / conform-action
                uses police-conform-action-grouping;
                // policy-map * / class * / police ? / exceed-action
                uses police-exceed-action-grouping;
                // policy-map * / class * / police ? / violate-action
                uses police-violate-action-grouping;
              }
            }
          }
        }

        // police switch "numflat" - (Catalyst c3550)
        // police <bps> <burst> exceed-action {drop | policed-dscp-transmit}]
        case police-switch-case {
          container police-switch {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              when "contains(../../../../tailfned/police, 'numflat')" {
                tailf:dependency "../../../../tailfned/police";
              }
              // <bps = cir>
              leaf cir {
                tailf:cli-incomplete-command;
                tailf:cli-drop-node-name;
                tailf:cli-diff-dependency
                  "../../../police-aggregate/police/aggregate" {
                  tailf:cli-trigger-on-set;
                }
                type uint32 {
                  tailf:info "<8000-1000000000>;;Bits per second";
                  range "8000..1000000000";
                }
              }
              // <burst = bc>
              leaf bc {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<8000-2000000>;;Normal burst bytes";
                  range "8000..2000000";
                }
              }
              // exceed-action
              leaf exceed-action {
                tailf:info "action when rate is exceeded";
                type enumeration {
                  enum drop {
                    tailf:info "drop packet";
                  }
                  enum policed-dscp-transmit {
                    tailf:info "change dscp per policed-dscp map and send it";
                  }
                }
              }
            }
          }
        }

        // police "numflat"
        // police <bps> <burst-normal> <burst-max> ACTIONS
        case police-numflat-case {
          container police-numflat {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              when "contains(../../../../tailfned/police, 'numflat')" {
                tailf:dependency "../../../../tailfned/police";
              }
              // <bps> (cir)
              leaf cir {
                tailf:cli-drop-node-name;
                tailf:cli-diff-dependency
                  "../../../police-aggregate/police/aggregate" {
                  tailf:cli-trigger-on-set;
                }
                type police-bps-type;
              }
              // <bc> (burst-normal)
              leaf bc {
                tailf:cli-drop-node-name;
                type police-burst-type;
              }
              // <be> (burst-max)
              leaf be {
                tailf:cli-drop-node-name;
                type police-burst-type;
              }
              // conform-action | exceed-action | violate-action
              container actions {
                tailf:cli-break-sequence-commands;
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                // policy-map * / class * / police ? / conform-action
                uses police-conform-action-grouping;
                // policy-map * / class * / police ? / exceed-action
                uses police-exceed-action-grouping;
                // policy-map * / class * / police ? / violate-action
                uses police-violate-action-grouping;
              }
            }
          }
        }

        // police "cirflat" - (Catalyst c3750)
        // police cir <bps> bc <burst-normal> ACTIONS
        case police-cirflat-case {
          container police-cirflat {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              when "contains(../../../../tailfned/police, 'cirflat')" {
                tailf:dependency "../../../../tailfned/police";
              }
              // cir <bps>
              leaf cir {
                tailf:info "Committed information rate";
                tailf:cli-diff-dependency
                  "../../../police-aggregate/police/aggregate" {
                  tailf:cli-trigger-on-set;
                }
                type police-bps-type;
              }
              // bc <burst-normal>
              leaf bc {
                tailf:info "Conform burst";
                type police-burst-type;
              }
              // conform-action | exceed-action | violate-action
              container actions {
                tailf:cli-break-sequence-commands;
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                // policy-map * / class * / police ? / conform-action
                uses police-conform-action-grouping;
                // policy-map * / class * / police ? / exceed-action
                uses police-exceed-action-grouping;
                // policy-map * / class * / police ? / violate-action
                uses police-violate-action-grouping;
              }
            }
          }
        }
      }

      // policy-map * / class * / priority
      container priority {
        tailf:info "Strict Scheduling Priority for this Class";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        leaf level {
          tailf:info "Multi-Level Priority Queue";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-2>;;Multi-Level Priority Queue";
            range "1..2";
          }
        }
        choice priority-type {
          leaf kilo-bits {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<8-2000000>;;Kilo Bits per second";
              range "8..2000000";
            }
          }
          // policy-map * / class * / priority percent
          leaf percent {
            tailf:info "% of total bandwidth";
            tailf:cli-remove-before-change;
            type uint16 {
              tailf:info "<1-100>;;percentage";
              range "1..100";
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-64000000>;;Burst in bytes";
            range "32..64000000";
          }
        }
      }

      // policy-map * / class * / queue-limit
      container queue-limit {
        tailf:info "Queue Max Threshold for Tail Drop";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf queue-limit-value {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-8192000>;;in bytes, <1-3400> in ms, "+
              "<1-32768> in packets by default";
            range "1..8192000";
          }
        }
        leaf queue-limit-type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum bytes {
              tailf:info "in bytes";
            }
            enum ms {
              tailf:info "in milliseconds";
            }
            enum us {
              tailf:info "in microseconds";
            }
            enum packets {
              tailf:info "in packets";
            }
          }
        }
      }

      // policy-map * / class * / random-detect
      container random-detect {
        tailf:info "Enable Random Early Detection as drop policy";
        tailf:cli-display-separated;
        presence true;

        // policy-map * / class * / random-detect aggregate
        container aggregate {
          tailf:info "aggregate subclasses";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          leaf minimum-thresh {
            tailf:info "minimum threshold for red aggregate";
            type uint32 {
              tailf:info "<0-1000000>;;minimum threshold (number of packets)";
              range "0..1000000";
            }
          }
          leaf maximum-thresh {
            tailf:info "maximum threshold for red aggregate";
            type uint32 {
              tailf:info "<0-1000000>;;maximum threshold (number of packets)";
              range "0..1000000";
            }
          }
          leaf mark-probability {
            tailf:info "mark-probability for red aggregate";
            type empty;
          }
          leaf denominator {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-65535>;;mark probability denominator";
              range "0..65535";
            }
          }
        }

        // policy-map * / class * / random-detect cos-based
        leaf cos-based {
          tailf:cli-reset-container;
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../precedence-based" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../precedence" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../discard-class-based" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../discard-class" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../dscp-based" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../dscp" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }

        // policy-map */ class * / random-detect
        // policy-map */ class * / random-detect precedence-based  <= hidden!
        leaf precedence-based  {
          tailf:info "Enable precedence-based WRED as drop policy";
          tailf:cli-reset-container;
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../discard-class-based" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../discard-class" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../dscp-based" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../dscp" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }

        // policy-map * / class * / random-detect discard-class-based
        leaf discard-class-based {
          tailf:info "Enable discard-class-based WRED as drop policy";
          tailf:cli-reset-container;
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../dscp-based" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../dscp" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }

        // policy-map * / class * / random-detect dscp-based
        leaf dscp-based {
          tailf:info "Enable dscp-based WRED as drop policy";
          tailf:cli-reset-container;
          tailf:cli-full-command;
          type empty;
        }

        // policy-map */ class * / random-detect exponential-weighting-constant
        leaf exponential-weighting-constant {
          tailf:info "weight for mean queue depth calculation";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-16>;;integer in 1..16 used in weighted "+
              "average to mean 2^number";
            range "1..16";
          }
        }
        // policy-map * / class * / random-detect ecn
        leaf ecn {
          tailf:info "explicit congestion notification";
          tailf:cli-full-command;
          type empty;
        }

        // policy-map * / class * / random-detect cos *
        list cos {
          tailf:info "parameters for each cos value";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../cos-based";
          key cos;
          leaf cos {
            type uint8 {
              tailf:info "<0-7>;;cos value";
              range "0..7";
            }
          }
          uses random-detect-grouping;
        }

        // policy-map * / class * / random-detect precedence *
        list precedence {
          tailf:info "parameters for each precedence value";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../precedence-based";
          key prec;
          leaf prec {
            type union {
              type uint8 {
                tailf:info "<0-7>;;IP precedence";
                range "0..7";
              }
              type enumeration {
                enum rsvp {
                  tailf:info "rsvp traffic";
                }
              }
            }
          }
          uses random-detect-grouping;
        }

        // policy-map * / class * / random-detect discard-class *
        list discard-class {
          tailf:info "parameters for each discard-class value";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../discard-class-based";
          key dclass;
          leaf dclass {
            type uint16 {
              tailf:info "<0-7>;;discard-class value";
              range "0..7";
            }
          }
          uses random-detect-grouping;
        }

        // policy-map * / class * / random-detect dscp *
        list dscp {
          tailf:info "parameters for each dscp value";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../dscp-based";
          key dscpvalue;
          leaf dscpvalue {
            type dscp-type;
          }
          uses random-detect-grouping;
        }
      }

      // policy-map * / class * / set
      container set {
        tailf:info "Set QoS values";
        // policy-map * / class * / set atm-clp
        leaf atm-clp {
          tailf:info "Set ATM CLP bit to 1";
          tailf:cli-full-command;
          type empty;
        }
        // policy-map * / class * / set cos
        container cos {
          tailf:info "Set IEEE 802.1Q/ISL class of service/user "+
            "priority";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice cos-type {
            case a {
              leaf val {
                tailf:cli-drop-node-name;
                type uint16 {
                  range "0..7";
                  tailf:info "<0-7>;;cos value";
                }
              }
            }
            case b {
              leaf pack {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum dscp {
                    tailf:code-name "pack_dscp";
                    tailf:info "Set value from packet dscp";
                  }
                  enum precedence {
                    tailf:code-name "pack_precedence";
                    tailf:info "Set value from packet "+
                      "precedence.";
                  }
                }
              }
              leaf table {
                tailf:info "Set codepoint value based on tablemap.";
                type string {
                  tailf:info "WORD;;table-map name";
                }
                tailf:non-strict-leafref {
                  path "/ios:table-map/name";
                }
              }
            }
          }
        }
        // policy-map * / class * / set discard-class
        leaf discard-class {
          tailf:info "Discard behavior identifier";
          tailf:cli-full-command;
          type uint16 {
            range "0..7";
            tailf:info "<0-7>;;Discard Class value";
          }
        }
        // policy-map * / class * / set dscp
        leaf dscp {
          tailf:info "Set DSCP in IP(v4) and IPv6 packets";
          tailf:cli-full-command;
          type dscp-type;
        }
        // policy-map * / class * / set fr-de
        leaf fr-de {
          tailf:info "Set FR DE bit to 1";
          tailf:cli-full-command;
          type empty;
        }
        // policy-map * / class * / set ip
        container ip {
          tailf:info "Set IP specific values";
          choice ip-choice {
            leaf dscp {
              tailf:info "Set IP DSCP (DiffServ CodePointint)";
              type dscp-type;
            }
            container precedence {
              tailf:info "Set IP precedence";
              presence "Set IP precedence";
              leaf precedence-val {
                tailf:cli-drop-node-name;
                type precedence-type;
              }
            }
          }
        }
        // policy-map * / class * / set mpls
        container mpls {
          tailf:info "Set MPLS specific values";
          container experimental {
            tailf:info "Set Experimental value";
            // 0-7
            container imposition {
              tailf:info "Set Experimental value at tag imposition";
              leaf exp-value {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type uint8 {
                  tailf:info "<0-7>;;Experimental value";
                  range "0..7";
                }
              }
              // dscp
              // precedence
            }
              // topmost
          }
        }
        // policy-map * / class * / set qos-group
        container qos-group {
          tailf:info "Set QoS Group";
          leaf qos-group-value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint8 {
              range "0..99";
            }
          }
          // dscp
          // mpls
          // precedence
        }
        // policy-map * / class * / set precedence
        container precedence {
          tailf:info "Set precedence in IP(v4) and IPv6 packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          choice precedence-choice {
            case precedence-value {
              leaf precedence-value {
                tailf:cli-drop-node-name;
                tailf:cli-no-keyword;
                type precedence-type;
              }
            }
            case precedence-from-field {
              leaf from-field {
                tailf:cli-drop-node-name;
                tailf:cli-no-keyword;
                type enumeration {
                  enum cos {
                    tailf:info "Set packet precedence from L2 COS";
                  }
                  enum qos-group {
                    tailf:info "Set packet precedence from QoS Group.";
                  }
                }
              }
              leaf table {
                tailf:info "Set packet precedence based on table map.";
                type string {
                  tailf:info "WORD;;table-map name";
                }
                tailf:non-strict-leafref {
                  path "/ios:table-map/name";
                }
              }
            }
          }
        }
      }

      // policy-map * / class * / shape
      container shape {
        tailf:info "Traffic Shaping";
        // policy-map * / class * / shape adaptive
        leaf adaptive {
          tailf:info "Enable Traffic Shaping adaptation to BECN";
          tailf:cli-full-command;
          type uint32 {
            range "8000..154400000";
            tailf:info "<8000-154400000>;;Lower Bound Target Bit "+
              "Rate (bits per second)";
          }
        }
        // policy-map * / class * / shape average
        container average {
          tailf:info "configure token bucket: CIR (bps) [Bc (bits) "+
            "[Be (bits)]], send out Bc only per interval";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          choice average-choice {
            case a {
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint32 {
                  //range "8000..154400000";
                  //FIXME: what is range max?
                  tailf:info "<8000-max>;;Target Bit "+
                    "Rate (bits per second), the value "+
                    "needs to be a multiple of 8000";
                }
              }
              leaf bits-per-interval-sustained {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "256..154400000";
                  tailf:info "<256-154400000>;;bits per "+
                    "interval, sustained. Needs to be "+
                    "multiple of 128. Recommend not to "+
                    "configure it, the algorithm will "+
                    "find out the best value";
                }
              }
              leaf bits-per-interval-excess {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "0..154400000";
                  tailf:info "<0-154400000>;;bits per "+
                    "interval, excess. Needs to be "+
                    "multiple of 128. Bc will be used if "+
                    "you don't configure it.";
                }
              }
            }
            case b {
              leaf percent {
                tailf:info "% of interface bandwidth for "+
                  "Committed information rate";
                type percentage-type;
              }
              leaf burst-size-sustained {
                tailf:cli-incomplete-command;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<10-2000>;;Sustained burst size in msec";
                  range "10..2000";
                }
              }
              leaf ms {
                tailf:info "milliseconds";
                type empty;
              }
              container bse {
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf burst-size-excess {
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<10-2000>;;Excess burst size in msec";
                    range "10..2000";
                  }
                }
                leaf ms {
                  tailf:info "milliseconds";
                  type empty;
                }
              }
            }
          }
        }
        // policy-map * / class * / shape fecn-adapt
        leaf fecn-adapt {
          tailf:info "Enable Traffic Shaping reflection of FECN as BECN";
          tailf:cli-full-command;
          type empty;
        }
        // policy-map * / class * / shape fr-voice-adapt
        container fr-voice-adapt {
          tailf:info "Enable rate adjustment depending on voice presence";
          presence true;
          leaf deactivation {
            type uint16 {
              range "1..10000";
              tailf:info "<1-10000>;;de-activation delay in seconds";
            }
          }
        }
        // policy-map * / class * / shape max-buffers
        leaf max-buffers {
          tailf:cli-full-command;
          tailf:info "Set Maximum Buffer Limit";
          type uint16 {
            tailf:info "<1-4096>;;Maximum Buffer Limit";
            range "1..4096";
          }
        }
      }

      // policy-map * / class * / service-policy
      leaf service-policy {
        tailf:info "Configure Flow Next";
        tailf:cli-full-command;
        type string;
        tailf:non-strict-leafref {
          path "/ios:policy-map/name";
        }
      }

      // policy-map * / class * / trust
      leaf trust {
        tailf:info "Set trust value for the class";
        type enumeration {
          enum cos {
            tailf:info "trust value for the class";
          }
          enum dscp {
            tailf:info "trust value for the class";
          }
          enum ip-precedence {
            tailf:info "trust value for the class";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// bridge-domain
  /// ========================================================================

  container bridge-domain {
    tailf:info "Bridge-domain global configuration commands";

    // bridge-domain *
    list bridge-domain-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-bdomain";
      tailf:cli-full-command;
      //ME3X00 ONLY: tailf:callpoint bridge-domain-create { tailf:set-hook node; }
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-8000>;;bridge-domain ID";
          range "1..8000";
        }
      }

      // bridge-domain * / member *
      container member {
        tailf:info "bridge-domain member";
        // bridge-domain * / member vfi
        leaf vfi {
          tailf:info "Configure the Virtual Forwarding Instance (VFI) member";
          type string {
            tailf:info "WORD;;Enter VFI name (Max Size 31)";
          }
          tailf:non-strict-leafref {
            path "/ios:l2vpn-vfi/l2vpn/vfi/context/name";
          }
        }
        // bridge-domain * / member * service-instance
        list interface-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-disallow-value "vfi";
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf service-instance {
            tailf:info "ethernt service instance";
            type uint16 {
              tailf:info "<1-8000>;;Service Instance Identifier";
              range "1..8000";
            }
          }
        }
      }

      // bridge-domain * / mac
      container mac {
        tailf:info "MAC Address related commands";
        // bridge-domain * / mac aging-time
        leaf aging-time {
          tailf:info "Set age time of mac addresses per bridge domain";
          type uint16 {
            tailf:info "<10-600>;;Aging time in seconds, default 300 seconds "+
              "(or 1800 seconds for overlay bridge domains)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// service-group
  /// ========================================================================

  list service-group {
    key id;
    leaf id {
      type uint32;
    }

    // service-group * / description
    leaf "description" {
      tailf:cli-multi-value;
      type string;
    }

    // service-group * / service-policy
    container service-policy {
      tailf:info "Configure Service Policy";
      uses service-policy-grouping;
    }
  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "VLAN commands";

    choice vlan-accounting-choice {
      // no vlan accounting
      leaf accounting {
        tailf:info "VLAN accounting configuration";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
      }
      // no vlan accounting input
      container accounting-input {
        tailf:cli-drop-node-name;
        container accounting {
          leaf "input" {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }
      // no vlan accounting output
      container accounting-output {
        tailf:cli-drop-node-name;
        container accounting {
          leaf "output" {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }
    }

    // vlan internal
    container internal {
      tailf:info "internal VLAN";
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          type enumeration {
            enum ascending {
              tailf:info "Allocates internal VLANs from 1006 to 4094";
            }
            enum descending {
              tailf:info "Allocates internal VLANs from 4094 to 1006.";
            }
          }
        }
      }
    }

    // vlan dot1q
    container dot1q {
      tailf:info "dot1q parameters";
      container tag {
        tailf:info "tag parameters";
        leaf native {
          tailf:info "tag native vlan";
          type empty;
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter";
        type uint16 {
          tailf:info "<10-5000>;;Maximum number of packets logged per second";
          range "10..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan <id>
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      key id;
      leaf id {
        type uint16 {
          range "1..4094";
          tailf:info "<1-3967,4048-4094>;;VLAN ID 1-4094 or "
            +"range(s): 1-5, 10 or 2-5,7-19";
        }
      }
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "The ascii name for the VLAN (Max Size 32)";
          length "1..32";
        }
      }
      leaf remote-span {
        tailf:info "Configure as Remote SPAN VLAN";
        tailf:cli-full-command;
        type empty;
      }
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:info "Global LLDP configuration subcommands";

    // lldp run
    leaf run {
      tailf:info "Enable LLDP";
      type empty;
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // default
    tailf:action "default" {
      tailf:info "Set a command to its defaults";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "default argument(s)";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }

    // crypto key
    container crypto-key {
      tailf:cli-drop-node-name;
      tailf:action "crypto" {
        tailf:info "Encryption module";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf-list "key" {
            tailf:info "Long term key operations";
            tailf:cli-flat-list-syntax;
            type string {
              tailf:info "crypto key argument(s)";
            }
          }
        }
        output {
          leaf result {
            type string;
          }
        }
      }
    }

    // crypto pki
    container crypto-pki {
      tailf:cli-drop-node-name;
      container crypto {
        container pki {
          tailf:info "Public Key components";

          // crypto pki server
          tailf:action "server" {
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            input {
              leaf-list arguments {
                tailf:cli-drop-node-name;
                tailf:cli-flat-list-syntax;
                type string {
                  tailf:info "ACTION:;;crypto pki server <cs-label> "+
                    "[rollover [cancel]]";
                }
              }
            }
            output {
              leaf result {
                type string;
              }
            }
          }

          // crypto pki enroll
          tailf:action "enroll" {
            tailf:info "Request a certificate from a CA";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            input {
              leaf-list arguments {
                tailf:cli-drop-node-name;
                tailf:cli-flat-list-syntax;
                type string {
                  tailf:info "ACTION:;;crypto pki enroll <name>";
                }
              }
            }
            output {
              leaf result {
                type string;
              }
            }
          }

        }
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Encryption module";

    // crypto keyring *
    list keyring {
      tailf:info "Key ring commands";
      tailf:cli-mode-name "conf-keyring";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;name of the key ring";
        }
      }
      leaf vrf {
        tailf:info "Mention a vrf it belongs to";
        tailf:cli-hide-in-submode;
        type string {
          tailf:info "WORD;;the VRF name";
        }
      }
    }

    // crypto logging
    container logging {
      tailf:info "logging messages";

      // crypto logging session
      leaf session {
        tailf:info "logging up/down session";
        type empty;
      }

      // crypto logging ikev2
      leaf ikev2 {
        tailf:info "logging IKEv2 sessions";
        type empty;
      }
    }

    // crypto ikev2
    container ikev2 {
      tailf:info "Configure IKEv2 Options";

      // crypto ikev2 name-mangler *
      list name-mangler {
        tailf:info "Name mangler";
        tailf:cli-mode-name "config-ikev2-name-mangler";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the mangler";
          }
        }
        // crypto ikev2 name-mangler * / fqdn
        leaf fqdn {
          tailf:info "Derive name from FQDN identity";
          type enumeration {
            enum all {
              tailf:info "entire portion of fqdn identity";
            }
            enum domain {
              tailf:info "domain portion of fqdn identity";
            }
            enum hostname {
              tailf:info "hostname portion of fqdn identity";
            }
          }
        }
      }

      // crypto ikev2 authorization policy *
      container authorization {
        tailf:info "IKEv2 authorization";
        list policy {
          tailf:info "IKEv2 authorization policy";
          tailf:cli-mode-name "config-ikev2-author-policy";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }

          // crypto ikev2 authorization policy * / aaa
          container aaa {
            tailf:info "Specify aaa attribute list";
            container attribute {
              tailf:info "AAA attribute list";
              leaf "list" {
                tailf:info "AAA attribute list";
                type string {
                  tailf:info "WORD;;AAA attribute list name";
                }
              }
            }
          }

          // crypto ikev2 authorization policy * / route
          container route {
            tailf:info "specify route parameters";

            // crypto ikev2 authorization policy * / route set
            container set {
              tailf:info "Specify route set parameters";
              // crypto ikev2 authorization policy * / route set access-list
              container access-list {
                tailf:info "Specify the route access-list";
                leaf ipv4 {
                  tailf:cli-drop-node-name;
                  type std-ip-acl-type;
                }
                leaf ipv6 {
                  tailf:info "ipv6 access-list";
                  type string {
                    tailf:info "WORD;;access-list name";
                  }
                }
              }
              // crypto ikev2 authorization policy * / route set interface
              // crypto ikev2 authorization policy * / route set interface *
              container interface {
                tailf:info "Specify the route interface [interface-name]";
                tailf:cli-display-separated;
                presence true;
                list interface-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Interface name";
                    }
                  }
                }
              }
            }

            // crypto ikev2 authorization policy * / route accept any
            container accept {
              tailf:info "Route accept parameters";
              container any {
                tailf:info "Accept all subnets from peer";
                choice any-choice {
                  leaf distance {
                    tailf:info "Specify distance for routes to remote subnets";
                    type uint8 {
                      tailf:info "<1-255>;;Routing distance";
                      range "1..255";
                    }
                    default 1;
                  }
                  leaf tag {
                    tailf:info "Specify tag for routes to remote subnets";
                    type uint32 {
                      tailf:info "<1-497777>;;Routing tag ID";
                      range "1..497777";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // crypto ikev2 keyring *
      list keyring {
        tailf:info "Define IKEv2 Keyring";
        tailf:cli-mode-name "config-ikev2-keyring";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 Keyring";
          }
        }
        // crypto ikev2 keyring * / peer *
        list peer {
          tailf:info "Configure a Peer and associated keys";
          tailf:cli-mode-name "config-ikev2-keyring-peer";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the peer block";
            }
          }

          // crypto ikev2 keyring * / peer * / description
          leaf "description" {
            tailf:info "Specify a description of this peer";
            tailf:cli-multi-value;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;description of the peer";
            }
          }

          // crypto ikev2 keyring * / peer * / address
          container address {
            tailf:info "Specify IPv4/IPv6 address of peer";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice address-choice {
              case ipv4 {
                leaf ipv4-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 Address";
                  }
                }
                leaf ipv4-mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;specify mask";
                  }
                }
              }
              case ipv6 {
                leaf ipv6-address {
                  tailf:cli-drop-node-name;
                  type ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix";
                  }
                }
              }
            }
          }

          // crypto ikev2 keyring * / peer * / identity
          container "identity" {
            tailf:info "Specify IKE identity to use";
            container fqdn {
              tailf:info "Use FQDN";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf domain {
                tailf:info "email Domain Name";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Specify the name string";
                }
              }
            }
          }

          // crypto ikev2 keyring * / peer * / pre-shared-key
          container pre-shared-key {
            tailf:info "specify the pre-shared key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses crypto-key-grouping;
          }

          // crypto ikev2 keyring * / peer * / pre-shared-key local
          container pre-shared-key-local {
            tailf:cli-drop-node-name;
            container pre-shared-key {
              container local {
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses crypto-key-grouping;
              }
            }
          }

          // crypto ikev2 keyring * / peer * / pre-shared-key remote
          container pre-shared-key-remote {
            tailf:cli-drop-node-name;
            container pre-shared-key {
              container remote {
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses crypto-key-grouping;
              }
            }
          }
        }
      }

      // crypto ikev2 profile *
      list profile {
        tailf:info "Define IKEv2 Profiles";
        tailf:cli-mode-name "config-ikev2-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 Profile";
          }
        }

        // crypto ikev2 profile * / description
        leaf "description" {
          tailf:info " Specify a description of this profile";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;a 1 line description of the profile";
          }
        }

        // crypto ikev2 profile * / match
        container match {
          tailf:info "Match values of peer";

          // crypto ikev2 profile * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto ikev2 profile * / match identify remote
          container "identity" {
            tailf:info "IKE identity";
            container remote {
              tailf:info "Remote identity";

              // crypto ikev2 profile * / match identity remote fqdn
              container fqdn {
                tailf:info "Fully qualified domain name string";
                // crypto ikev2 profile * / match identity remote fqdn *
                list fqdn-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }
                // crypto ikev2 profile * / match identity remote fqdn domain *
                list domain {
                  tailf:info "match domain instead of exact";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }
              }

              // crypto ikev2 profile * / match identity remote address *
              list address {
                tailf:info "match address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key name;
                leaf name {
                  type union {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IP address";
                    }
                    type ipv6-prefix {
                      tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                    }
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP mask";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / identify
        container "identity" {
          tailf:info "Specify IKE identity to use";
          container local {
            tailf:info "Specify the local IKE identity to use "+
              "for the negotiation";
            choice local-choice {
              leaf email {
                tailf:info "Fully qualified email string";
                type string {
                  tailf:info "WORD;;email <user@domain>";
                }
              }
              leaf fqdn {
                tailf:info "Fully qualified domain name string";
                type string {
                  tailf:info "WORD;;FQDN <host.domain>";
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / authentication
        container authentication {
          tailf:info "Set authentication method";
          // crypto ikev2 profile * / authentication local
          container local {
            tailf:info "Set local authentication method";
            choice method-choice {
              container eap {
                tailf:info "Extended Authentication Protocol";
                presence true;
              }
              leaf ecdsa-sig {
                tailf:info "ECDSA Signature";
                type empty;
              }
              container pre-share {
                tailf:info "Pre-Shared Key";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-delete-when-empty;
                presence true;
                container "key" {
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  uses crypto-key-grouping;
                }
              }
              leaf rsa-sig {
                tailf:info "Rivest-Shamir-Adleman Signature";
                type empty;
              }
            }
          }
          // crypto ikev2 profile * / authentication remote
          container remote {
            tailf:info "Set remote authentication method";
            tailf:cli-delete-when-empty;
            presence true;
            choice method-choice {
              container eap {
                tailf:info "Extended Authentication Protocol";
                presence true;
              }
              leaf ecdsa-sig {
                tailf:info "ECDSA Signature";
                type empty;
              }
              container pre-share {
                tailf:info "Pre-Shared Key";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-delete-when-empty;
                presence true;
                container "key" {
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  uses crypto-key-grouping;
                }
              }
              leaf rsa-sig {
                tailf:info "Rivest-Shamir-Adleman Signature";
                type empty;
              }
            }
          }
        }

        // crypto ikev2 profile * / keyring
        container keyring {
          tailf:info "Specify keyring to use";
          choice keyring-choice {
            container aaa {
              tailf:info "AAA based keyring";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;AAA list name";
                }
              }
              leaf name-mangler {
                tailf:info "Specify the name-mangler to derive username";
                type string {
                  tailf:info "WORD;;mangler name";
                }
                tailf:non-strict-leafref {
                  path "/ios:crypto/ikev2/name-mangler/name";
                }
              }
            }
            leaf local {
              tailf:info "Local keyring";
              type string {
                tailf:info "WORD;;Keyring name";
              }
              tailf:non-strict-leafref {
                path "/ios:crypto/ikev2/keyring/name";
              }
            }
          }
        }

        // crypto ikev2 profile * / nat keepalive
        container nat {
          tailf:info "NAT-transparency";
          leaf keepalive {
            tailf:info "NAT keepalive interval";
            type uint16 {
              tailf:info "<5-3600>;;NAT keepalive interval in seconds";
              range "5..3600";
            }
          }
        }

        // crypto ikev2 profile * / aaa
        container aaa {
          tailf:info "Specify AAA related configs";
          container authorization {
            tailf:info "AAA authorization";

            // crypto ikev2 profile * / aaa authorization group
            container group {
              tailf:info "AAA group authorization";
              container psk {
                tailf:info "AAA list to use when IKEv2 remote auth method is PSK";
                container "list" {
                  tailf:info "AAA method list";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf list-name {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;;AAA list name";
                    }
                  }
                  leaf aaa-username {
                    tailf:cli-break-sequence-commands;
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;;AAA username";
                    }
                  }
                  leaf name-mangler {
                    tailf:info "Specify the name-mangler to derive AAA username";
                    type string {
                      tailf:info "WORD;;mangler name";
                    }
                    tailf:non-strict-leafref {
                      path "/ios:crypto/ikev2/name-mangler/name";
                    }
                  }
                  container password {
                    tailf:info "Specify the AAA password";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    uses crypto-key-grouping;
                  }
                }
              }
            }

            // crypto ikev2 profile * / aaa authorization user
            container user {
              tailf:info "AAA user authorization";
              container psk {
                tailf:info "AAA list to use when IKEv2 remote auth method "+
                  "is PSK";
                leaf cached {
                  tailf:info "Use cached attributes from EAP authentication "+
                    "or AAA pre-shared key fetch";
                  type empty;
                }
                leaf "list" {
                  tailf:info "AAA method list";
                  type string {
                    tailf:info "WORD;;AAA list name";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / virtual-template
        leaf virtual-template {
          tailf:info "Specify the virtual-template for dynamic "+
            "interface creation";
          type uint16 {
            tailf:info "<1-4095>;;Virtual-template number";
          }
        }

        // crypto ikev2 profile * / dpd
        container dpd {
          tailf:info "Enable IKE liveness check for peers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<10-3600>;;DPD R-U-THERE interval";
              range "10..3600";
            }
          }
          leaf retry-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<2-60>;;DPD Retry Interval";
            }
          }
          leaf queries {
            tailf:cli-drop-node-name;
            type enumeration {
              enum  on-demand {
                tailf:info "Send DPD queries only as needed";
              }
              enum periodic {
                tailf:info "Send DPD queries at regular intervals";
              }
            }
          }
        }
      }

      // crypto ikev2 dpd
      container dpd {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf retry-interval {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum on-demand { }
            enum periodic { }
          }
        }
      }
    }

    // crypto pki
    container pki {
      tailf:info "Public Key components";

      // crypto pki server *
      list server {
        // NOTE: See ///EXEC for rollover [cancel] sub command.
        tailf:info "Enable IOS Certificate server";
        tailf:cli-mode-name "cs-server";
        tailf:cli-compact-syntax;
        tailf:cli-full-command;
        max-elements 1;
        key cs-label;
        leaf cs-label {
          type string {
            tailf:info "WORD;;Certificate Server Name";
          }
        }

        // crypto pki server * / shutdown
        leaf shutdown {
          tailf:info "Shutdown the Certificate Server";
          type empty;
        }

        // crypto pki server * / database archive
        container database {
          tailf:info "Certificate Server database config parameters";
          container archive {
            tailf:info "Backup Certificate Server Signing Certificate and Keys";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf format {
              tailf:cli-drop-node-name;
              type enumeration {
                enum pem {
                  tailf:info "PEM format";
                }
                enum pkcs12 {
                  tailf:info "PKCS12 format";
                }
              }
            }
            container password {
              tailf:info "Passphrase to protect the private key archive";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf "type" {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<0-9>;;Encryption type";
                  range "0..9";
                }
              }
              leaf secret {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "LINE;;Password";
                }
              }
            }
          }
        }

        // crypto pki server * / grant
        leaf grant {
          tailf:info "Certificate granting options";
          type enumeration {
            enum auto {
              tailf:info "Automatically grant incoming SCEP enrollment "+
                "requests";
            }
            enum none {
              tailf:info "Automatically reject any incoming SCEP enrollment "+
                "request";
            }
            enum ra-auto {
              tailf:info "Automatically grant RA-authorized incoming SCEP "+
                "enrollment request";
            }
          }
        }

        // crypto pki server * / hash
        leaf hash {
          tailf:info "Hash algorithm";
          type enumeration {
            enum md5 {
              tailf:info "use md5 hash algorithm";
            }
            enum sha1 {
              tailf:info "use sha1 hash algorithm";
            }
            enum sha256 {
              tailf:info "use sha256 hash algorithm";
            }
            enum sha384 {
              tailf:info "use sha384 hash algorithm";
            }
            enum sha512 {
              tailf:info "use sha512 hash algorithm";
            }
          }
        }
      }

      // crypto pki trustpoint *
      list trustpoint {
        tailf:info "Define a CA trustpoint";
        tailf:cli-mode-name "ca-trustpoint";
        tailf:callpoint crypto-pki-trustpoint-hook { tailf:set-hook node; }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;CA Server Name";
          }
        }

        // crypto pki trustpoint * / serial-number
        container serial-number {
          tailf:info "include serial number";
          tailf:cli-reset-container;
          presence true;
          leaf none {
            tailf:info "do not include serial number";
            type empty;
          }
        }

        // crypto pki trustpoint * / ip-address
        leaf ip-address {
          tailf:info "include ip address";
          tailf:cli-diff-dependency "/ios:interface";
          type union {
            type string {
              tailf:info "LINE;;interface name or ip address";
            }
            type enumeration {
              enum none {
                tailf:info "do not include ip address";
              }
            }
          }
        }

        // crypto pki trustpoint * / enrollment
        container enrollment {
          tailf:info "Enrollment parameters";
          leaf http-proxy {
            tailf:info "HTTP proxy server for enrollment";
            type string {
              tailf:info "WORD;;host-name";
            }
          }
          container mode {
            tailf:info "Mode supported by the Certificate Authority";
            leaf ra {
              tailf:info "Registration Authority mode";
              type empty;
            }
          }
          leaf profile {
            tailf:info "Specify an profile for enrollment";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          container retry {
            tailf:info "Polling parameters";
            leaf count {
              tailf:info "How many times to poll CA for our certificate";
              type uint8 {
                tailf:info "<1-100>;;Number of times to poll a CA for a "
                  +"certificate";
                range "1..100";
              }
            }
            leaf period {
              tailf:info "How long to wait between requests to CA for our "
                +"certificate";
              type uint8 {
                tailf:info "<1-60>;;Period in minutes between attempts to "
                  +"contact a CA";
                range "1..60";
              }
            }
          }
          leaf selfsigned {
            tailf:info "Generate a Self Signed Certificate";
            type empty;
          }
          container terminal {
            tailf:info "Enroll via the terminal (cut-and-paste)";

            leaf pem {
              tailf:info "Include PEM encapsulation boundaries";
              type empty;
            }
          }
          leaf url {
            tailf:info "CA server enrollment URL";
            type string {
              tailf:info "WORD;;HTTP URL";
            }
          }
        }

        // crypto pki trustpoint * / subject-name
        leaf subject-name {
          tailf:info "Subject Name";
          type string {
            tailf:info "LINE;;Subject Name";
          }
        }

        // crypto pki trustpoint * / revocation-check
        leaf revocation-check {
          tailf:info "Revocation checking options";
          type enumeration {
            enum crl { // Note: DO NOT reorder, Enum(0) used in java code.
              tailf:info "Revocation check by CRL";
            }
            enum none {
              tailf:info "Ignore revocation check";
            }
            enum ocsp {
              tailf:info "Revocation check by OCSP";
            }
          }
        }

        // crypto pki trustpoint * / rsakeypair
        leaf rsakeypair {
          tailf:info "Specify rsakeypair for this identity";
          type string {
            tailf:info "WORD;;RSA keypair label";
          }
        }

      }

      // crypto pki certificate
      container certificate {
        tailf:info "Actions on certificates";

        // crypto pki certificate chain *
        list chain {
          tailf:info "Identify certificates";
          tailf:cli-mode-name "config-cert-chain";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;CA Server Name";
            }
          }

          // crypto pki certificate chain * / certificate *
          list certificate {
            tailf:info "Certificate issued by the CA";
            tailf:cli-mode-name "config-pki-hexmode-quotedstring";
            tailf:cli-delete-when-empty;
            tailf:cli-exit-command "quit";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-full-command;
            tailf:cli-reset-container;
            key serial;
            leaf serial {
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general"+
                "|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;Certificate serial number";
              }
            }
            leaf cert-type {
              tailf:cli-optional-in-sequence;
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ca {
                  tailf:info "A certificate";
                }
                enum ra-encrypt {
                  tailf:info "A encryption certificate";
                }
                enum ra-general {
                  tailf:info "A general purpose certificate";
                }
                enum ra-sign {
                  tailf:info "A signing certificate";
                }
                enum rollover {
                  tailf:info "Shadow rollover certificate";
                }
                enum self-signed {
                  tailf:info "Self-signed certificate";
                }
              }
            }
            leaf rollover {
              tailf:info "Shadow rollover certificate";
              tailf:cli-optional-in-sequence;
              tailf:cli-prefix-key;
              type empty;
            }
            leaf cert {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general"+
                "|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;file specification";
              }
            }
          }
        }
      }

      // crypto pki token *
      container token {
        tailf:info "Configure cryptographic token";
        list token-name {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;token name";
            }
          }
          uses crypto-pki-token-grouping;
        }
      }

      // crypto pki default
      container "default" {
        tailf:info "set default values for tokens";
        uses crypto-pki-token-grouping;
      }
    }

    // crypto isakmp
    container isakmp {
      tailf:info "Configure ISAKMP policy";

      // no crypto isakmp enable
      leaf enable {
        tailf:info "Enable ISAKMP";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // crypto isakmp profile *
      list profile {
        tailf:info "Define ISAKMP Profiles";
        tailf:cli-mode-name "conf-isa-prof";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ISAKMP Profile";
          }
        }

        // crypto isakmp profile * / vrf
        leaf vrf {
          tailf:info "Specify the VRF it is related to";
          type string {
            tailf:info "WORD;;VRF Name";
          }
        }

        // crypto isakmp profile * / keyring *
        list keyring {
          tailf:info "Specify keyring to use";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type union {
              type enumeration {
                enum "default" {
                  tailf:info "Use global keyring";
                }
              }
              type string {
                tailf:info "WORD;;Name of the keyring to use";
              }
            }
          }
        }

        // crypto isakmp profile * / match identity address
        container match {
          tailf:info "Match values of peer";

          // crypto isakmp profile * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto isakmp profile * / match identity
          container "identity" {
            tailf:info "Peer identity";
            container address {
              tailf:info "IP Address(es)";
              container ipv4 {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address prefix";
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;specify mask";
                  }
                }
              }
              //TODO: ipv6     IPv6 Address(es)
            }
          }
        }
      }

      // crypto isakmp policy *
      list policy {
        tailf:info "Set policy for an ISAKMP protection suite";
        tailf:cli-mode-name "config-isakmp";
        key priority;
        leaf priority {
          type uint16 {
            tailf:info "<1-10000>;;Priority of protection suite";
          }
        }

        // crypto isakmp policy * / encryption
        container encryption {
          tailf:info "Set encryption algorithm for protection suite";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf algorithm {
            tailf:cli-drop-node-name;
            type enumeration {
              enum des {
                tailf:info "DES - Data Encryption Standard (56 bit keys).";
              }
              enum "3des" {
                tailf:info "Three key triple DES";
              }
              enum aes {
                tailf:info "AES - Advanced Encryption Standard.";
              }
            }
            default des;
          }
          leaf bits {
            when "../algorithm = 'aes'";
            tailf:cli-drop-node-name;
            type enumeration {
              enum "128" {
                tailf:info "128 bit keys.";
              }
              enum "192" {
                tailf:info "192 bit keys.";
              }
              enum "256" {
                tailf:info "256 bit keys.";
              }
            }
            default 128;
          }
        }

        // crypto isakmp policy * / hash
        leaf hash {
          tailf:info "Set hash algorithm for protection suite";
          type enumeration {
            enum md5 {
              tailf:info "Message Digest 5";
            }
            enum sha {
              tailf:info "Secure Hash Standard";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard";
            }
          }
          default sha;
        }

        // crypto isakmp policy * / authentication
        leaf authentication {
          tailf:info "Set authentication method for protection suite";
          type enumeration {
            enum pre-share {
              tailf:info "Pre-Shared Key";
            }
            enum rsa-encr {
              tailf:info "Rivest-Shamir-Adleman Encryption";
            }
            enum rsa-sig {
              tailf:info "Rivest-Shamir-Adleman Signature";
            }
          }
        }

        // crypto isakmp policy * / group
        leaf group {
          tailf:info "Set the Diffie-Hellman group";
          type enumeration {
            enum "1" {
              tailf:info "Diffie-Hellman group 1 (768 bit)";
            }
            enum "2" {
              tailf:info "Diffie-Hellman group 2 (1024 bit)";
            }
            enum "5" {
              tailf:info "Diffie-Hellman group 5 (1536 bit)";
            }
            enum "14" {
              tailf:info "Diffie-Hellman group 14 (2048 bit)";
            }
            enum "15" {
              tailf:info "Diffie-Hellman group 15 (3072 bit)";
            }
            enum "16" {
              tailf:info "Diffie-Hellman group 16 (4096 bit)";
            }
            enum "19" {
              tailf:info "Diffie-Hellman group 19 (256 bit ecp)";
            }
            enum "20" {
              tailf:info "Diffie-Hellman group 20 (384 bit ecp)";
            }
            enum "21" {
              tailf:info "Diffie-Hellman group 21 (521 bit ecp)";
            }
            enum "24" {
              tailf:info "Diffie-Hellman group 24 (2048 bit, 256 bit subgroup)";
            }
          }
        }

        // crypto isakmp policy * / lifetime
        leaf lifetime {
          tailf:info "Set lifetime for ISAKMP security association";
          type uint32 {
            tailf:info "<60-86400>;;lifetime in seconds";
            range "60..86400";
          }
          default 86400;
        }
      }

      // crypto isakmp keepalive
      container keepalive {
        tailf:info "Set a keepalive interval for use with IOS peers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<10-3600>;;Number of seconds between keep alives";
            range "10..3600";
          }
        }
        leaf periodic {
          tailf:info "When using Dead Peer Detection (DPD), "+
            "send periodic DPD messages";
          type empty;
        }
      }

      // crypto isakmp nat
      container nat {
        tailf:info "Set a nat  keepalive interval for use with IOS peers";
        container keepalive {
          tailf:info "Set a keepalive interval for use with IOS peers";
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<5-3600>;;Number of seconds between keep alives";
              range "5..3600";
            }
          }
        }
      }

      // crypto isakmp key *
      list "key" {
        tailf:info "Set pre-shared key for remote peer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key keystring;
        leaf keystring {
          type string {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
          }
        }

        // crypto isakmp key 6 *
        leaf encrypted {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "6" {
              tailf:info "Specifies an ENCRYPTED password will follow";
            }
          }
        }

        choice peer-choice {
          // crypto isakmp key * / address
          container address {
            tailf:info "define shared key with IP address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            choice address-choice {
              case a {
                leaf ipv4 {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Peer IP address";
                  }
                }
              }
              case b {
                leaf ipv4-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Peer IP address";
                  }
                }
                leaf ipv4-mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Peer IP subnet mask";
                  }
                }
              }
              case c {
                leaf ipv6 {
                  tailf:info "define shared key with IPv6 address";
                  type ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;Peer IPv6 prefix";
                  }
                }
              }
            }
          }
          // crypto isakmp key * / hostname
          leaf hostname {
            tailf:info "define shared key with hostname";
            type string {
              tailf:info "WORD;;hostname of peer with whom the key is shared";
            }
          }
        }
        // crypto isakmp key * / no-xauth
        leaf no-xauth {
          tailf:info "Bypasses XAuth for this peer";
          type empty;
        }
      }
    }

    // crypto ipsec
    container ipsec {
      tailf:info "Configure IPSEC policy";

      // crypto ipsec optional
      container optional {
        tailf:info "Enable optional encryption for IPSec";
        tailf:cli-delete-when-empty;
        presence true;
        leaf retry {
          tailf:info "Configure length of IPSec retry interval";
          type uint32 {
            tailf:info "<60-86400>;;Number of seconds between IPSec retries";
            range "60..86400";
          }
        }
      }

      // crypto ipsec security-association
      container security-association {
        tailf:info "Security association parameters";
        // crypto ipsec security-association idle-time
        leaf idle-time {
          tailf:info "Automatically delete IPSec SAs after a "+
            "given idle period.";
          type uint32 {
            tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
            range "60..86400";
          }
        }
        // crypto ipsec security-association lifetime
        container lifetime {
          tailf:info "security association lifetime";
          leaf kilobytes {
            tailf:info "Volume-based key duration";
            type union {
              type uint32 {
                tailf:info "<2560-4294967295>;;Security association "+
                  "duration in kilobytes encrypted";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable Volume-based Rekey";
                }
              }
            }
          }
          leaf seconds {
            tailf:info "Time-based key duration";
            type uint32 {
              tailf:info "<120-86400>;;Security association "+
                "duration in seconds";
              range "120..86400";
            }
          }
        }
        // crypto ipsec security-association replay
        container replay {
          tailf:info "Set replay checking.";
          leaf disable {
            tailf:info "Disable replay checking";
            type empty;
          }
          leaf window-size {
            tailf:info "Set replay window size.";
            type ipsec-window-size-type;
          }
        }
      }

      // crypto ipsec transform-set *
      list transform-set {
        tailf:info "Define transform and settings";
        tailf:cli-mode-name "cfg-crypto-trans";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Transform set tag";
          }
        }
        leaf transform1 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-type;
        }
        leaf transform1-bits {
          when "../transform1 = 'esp-aes'";
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-bits-type;
        }
        leaf transform2 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-type;
        }
        leaf transform2-bits {
          when "../transform2 = 'esp-aes'";
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-bits-type;
        }
        leaf transform3 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-type;
        }
        leaf transform3-bits {
          when "../transform3 = 'esp-aes'";
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-bits-type;
        }
        leaf transform4 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-type;
        }
        leaf transform4-bits {
          when "../transform4 = 'esp-aes'";
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type crypto-ipsec-transform-bits-type;
        }

        // crypto ipsec transform-set * / mode
        leaf mode {
          tailf:info "encapsulation mode (transport/tunnel)";
          type enumeration {
            enum transport {
              tailf:info "transport (payload encapsulation) mode";
            }
            enum tunnel {
              tailf:info "tunnel (datagram encapsulation) mode";
            }
          }
          default tunnel;
        }
      }

      // no crypto ipsec default transform-set
      container "default" {
        tailf:info "Default transform-set";
        leaf transform-set {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // crypto ipsec fragmentation
      leaf fragmentation {
        tailf:info "Handling of fragmentation of near-MTU sized packets";
        type enumeration {
          enum after-encryption {
            tailf:info "Perform fragmentation of large packets after "+
              "IPSec encapsulation.";
          }
          enum before-encryption {
            tailf:info "Perform fragmentation of large packets before "+
              "IPSec encapsulation.";
          }
        }
      }

      // crypto ipsec df-bit
      leaf df-bit {
        tailf:info "Handling of encapsulated DF bit.";
        type enumeration {
          enum clear {
            tailf:info "Clear DF bit for encapsulated packets.";
          }
          enum copy {
            tailf:info "Copy DF bit from inner for encapsulated packets.";
          }
          enum set {
            tailf:info "Set DF bit for encapsulated packets.";
          }
        }
      }

      // crypto ipsec nat-transparency
      leaf nat-transparency {
        tailf:info "IPsec NAT transparency model";
        type enumeration {
          enum spi-matching {
            tailf:info "Match inbound SPI to outbound SPI for IPsec aware NAT";
          }
          enum udp-encapsulation {
            tailf:info "UDP encapsulation of IPsec protocols";
          }
        }
      }

      // crypto ipsec profile *
      list profile {
        tailf:info "Configure an ipsec policy profile";
        tailf:cli-mode-name "ipsec-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        // crypto ipsec profile * / set
        container set {
          tailf:info "Set values for encryption/decryption";
          // crypto ipsec profile * / set security-association
          container security-association {
            tailf:info "Security association parameters";
            container lifetime {
              tailf:info "security association lifetime";
              leaf kilobytes {
                tailf:info "Volume-based key duration";
                type union {
                  type uint32 {
                    tailf:info "<2560-4294967295>;;Security association "+
                      "duration in kilobytes encrypted";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable Volume-based Rekey";
                    }
                  }
                }
              }
              leaf seconds {
                tailf:info "Time-based key duration";
                type uint32 {
                  tailf:info "<120-86400>;;Security association "+
                    "duration in seconds";
                  range "120..86400";
                }
              }
            }
          }
          // crypto ipsec profile * / set transform-set
          leaf transform-set {
            tailf:info "Specify list of transform sets in priority order";
            type string {
              tailf:info "WORD;;Proposal tag";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/ipsec/transform-set/name";
            }
          }
          // crypto ipsec profile * / set ikev2-profile
          leaf ikev2-profile {
            type string {
              tailf:info "WORD;;Profile name";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/ikev2/profile/name";
            }
          }
        }
      }
    }

    // crypto gdoi
    container gdoi {
      tailf:info "Configure GDOI policy";

      // crypto gdoi group *
      list group {
        tailf:info "Define a GDOI group";
        tailf:cli-mode-name "config-gdoi-group";
        key name;
        leaf name {
          tailf:cli-disallow-value "ipv6";
          type string {
            tailf:info "WORD;;Group Name";
          }
        }
        leaf ipv6 {
          tailf:cli-prefix-key;
          type empty;
        }

        // crypto gdoi group * / identify
        container "identity" {
          tailf:info "Set the identity of the group";
          choice identify-choice {
            leaf number {
              tailf:info "Set the identity of the group as a number";
              type uint32 {
                tailf:info "<0-2147483647>;;Set the group number";
              }
            }
            container address {
              tailf:info "Set the identity of the group as an address";
              leaf ipv4 {
                tailf:info "Set the identity of the group as an IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group IPv4 address";
                }
              }
            }
          }
        }

        // crypto gdoi group * / server
        container server {
          tailf:info "Set the group server for of the group";

          // crypto gdoi group * / server local
          container local {
            tailf:info "Identify a group server defined locally";
            tailf:cli-add-mode;
            tailf:cli-mode-name "gdoi-local-server";
            tailf:cli-delete-when-empty;
            presence true;
            must "not(../address/ipv4/name)" {
              error-message "Cannot Configure the key server as local.";
              tailf:dependency "../address/ipv4/name";
            }
            tailf:cli-diff-dependency "../address/ipv4/name" {
              tailf:cli-trigger-on-set;
            }

            // crypto gdoi group * / server local / rekey
            container rekey {
              tailf:info "Configure rekey policy for the group";

              // crypto gdoi group * / server local / rekey lifetime
              container lifetime {
                tailf:info "Define the rekey lifetime";
                choice lifetime-choice {
                  // crypto gdoi group * / server local / rekey lifetime seconds
                  leaf seconds {
                    tailf:info "Time-based key duration";
                    type uint32 {
                      tailf:info "<300-86400>;;Lifetime in seconds";
                    }
                    default 86400;
                  }
                  leaf days {
                    type uint32 {
                      tailf:info "Lifetime in days";
                    }
                  }
                  default seconds;
                }
              }

              // crypto gdoi group * / server local / rekey retransmit
              container retransmit {
                tailf:info "Define the rekey retransmission parameters";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf number-of-seconds {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<10-60>;;Retransmit after this many seconds";
                    range "10..60";
                  }
                }
                choice retransmit-choice {
                  leaf number {
                    tailf:info "Retransmit this many times";
                    type uint8 {
                      tailf:info "<1-10>;;Number of retransmissions";
                      range "1..10";
                    }
                  }
                  leaf periodic {
                    type empty;
                  }
                }
              }

              // crypto gdoi group * / server local / rekey authentication
              container authentication {
                tailf:info "Identify the rekey authentication keypair";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                choice authentication-choice {
                  leaf mypubkey {
                    tailf:info "Identify a keypair associated with this device";
                    type empty;
                  }
                  leaf pubkey {
                    type empty;
                  }
                }
                leaf rsa {
                  tailf:info "Identify an RSA keypair";
                  type string {
                    tailf:info "WORD;;Key name";
                  }
                }
              }

              // crypto gdoi group * / server local / rekey transport unicast
              container transport {
                tailf:info "Specify the rekey distribution method";
                leaf unicast {
                  tailf:info "specify unicast rekey distribution";
                  type empty;
                }
              }
            }

            // crypto gdoi group * / server local / replay
            container replay {
              container time {
                leaf window-size {
                  type uint32 {
                  }
                }
              }
            }

            // crypto gdoi group * / server local / sa
            container sa {
              tailf:info "Configure a security association";

              // crypto gdoi group * / server local / sa ipsec *
              list ipsec {
                tailf:info "Configure an IPsec SA";
                tailf:cli-mode-name "gdoi-sa-ipsec";
                key id;
                leaf id {
                  type uint32 {
                    tailf:info "<1-65535>;;Sequence to insert into SA list";
                    range "1..65535";
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / profile
                leaf profile {
                  tailf:info "Configure an ipsec profile for the SA";
                  type string {
                    tailf:info "WORD;;Profile name";
                  }
                  tailf:non-strict-leafref {
                    path "/ios:crypto/ipsec/profile/name";
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / match
                container match {
                  tailf:info "Match characteristics of packets to encrypt";
                  container address {
                    tailf:info "Match addresses of packets to encrypt";
                    choice address-choice {
                      leaf ipv4 {
                        tailf:info "Match ipv4 packets";
                        type ext-ip-acl-type;
                        //FIXME: dependency?
                      }
                      leaf ipv6 {
                        tailf:info "Match ipv6 packets";
                        type string {
                          tailf:info "WORD;;IPv6 access list";
                        }
                        tailf:non-strict-leafref {
                          path "/ios:ipv6/access-list/named-acl/name";
                        }
                      }
                    }
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / replay
                container replay {
                  tailf:info "Set replay method";
                  container counter {
                    tailf:info "Enable anti-replay check for single source "+
                      "traffic by using sequence number";
                    leaf window-size {
                      tailf:info "Set replay window size.";
                      type ipsec-window-size-type;
                    }
                  }
                }
              }
            }

            // crypto gdoi group * / server local / address ipv4
            container address {
              tailf:info "Configure server source address";
              leaf ipv4 {
                tailf:info "Set ipv4 address of local server";
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 local address";
                  }
                  type string {
                    tailf:info "WORD;;Interface name";
                  }
                }
              }
            }

            // crypto gdoi group * / server local / redundancy
            container redundancy {
              tailf:info "Enter cooperative key server configuration mode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "gdoi-coop-ks-config";
              tailf:cli-full-command;
              // crypto gdoi group * / server local / redundancy local
              container local {
                tailf:info "Local key server configurations";
                tailf:cli-delete-when-empty;
                presence true;
                leaf priority {
                  tailf:info "Set local server priority";
                  type uint8 {
                    tailf:info "<1-255>;;Local server priority";
                  }
                }
              }
              // crypto gdoi group * / server local / redundancy peer
              container peer {
                tailf:info "Peer server configurations";
                container address {
                  tailf:info "Peer server address";
                  leaf ipv4 {
                    tailf:info "Set peer server ipv4 address";
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Peer server ipv4 address";
                    }
                  }
                }
              }
            }
          }

          // crypto gdoi group * / server address ipv4
          container address {
            tailf:info "Identify the group server by address";
            list ipv4 {
              tailf:info "Set the IPv4 address of the group server";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              must "not(../../local)" {
                error-message "Key server is already configured as local";
                tailf:dependency "../../local";
              }
              tailf:cli-diff-dependency "../../local" {
                tailf:cli-trigger-on-set;
              }
              key name;
              leaf name {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group server IPv4 address";
                }
              }
            }
          }
        }

        // crypto gdoi group * / client registration interface
        container client {
          tailf:info "Set the group client management/register interface";
          container registration {
            tailf:info "Set the group client management/register interface";
            container interface {
              tailf:info "Set the group client management/register interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }

    // crypto dynamic-map *
    list dynamic-map {
      tailf:info "Specify a dynamic crypto map template";
      tailf:cli-mode-name "config-crypto-map";
      key "name map-entry";
      leaf name {
        type string {
          tailf:info "WORD;;Dynamic crypto map template tag";
        }
      }
      leaf map-entry {
        type uint32 {
          tailf:info "<1-65535>;;Sequence to insert into dynamic-map entry";
        }
      }

      // crypto dynamic-map * / set
      container set {
        tailf:info "Set values for encryption/decryption";

        // crypto dynamic-map * / set isakmp-profile
        leaf isakmp-profile {
          tailf:info " Specify isakmp Profile";
          type string {
            tailf:info "WORD;;Name the isakmp profile";
          }
          tailf:non-strict-leafref {
            path "/ios:crypto/isakmp/profile/name";
          }
        }

        // crypto dynamic-map * / set  transform-set
        leaf-list transform-set {
          tailf:info "Specify list of transform sets in priority order";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "WORD;;Proposal tag";
          }
          tailf:non-strict-leafref {
            path "/ios:crypto/ipsec/transform-set/name";
          }
        }
      }

      // crypto dynamic-map * / match address
      container match {
        tailf:info "Match values.";
        leaf address {
          tailf:info "Match address of packets to encrypt";
          type ext-acl-type;
        }
      }
    }


    // crypto map *
    list map {
      tailf:info "Enter a crypto map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "ipv6";
        type string {
          tailf:info "WORD;;Crypto map tag";
        }
      }
      leaf ipv6 {
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }

      // crypto map * local-address
      container local-address {
        tailf:info "Interface to use for local address for this crypto map";
        tailf:cli-optional-in-sequence;
        uses interface-name-grouping;
      }

      list seq-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-crypto-map";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Sequence to insert into crypto map entry";
          }
        }

        // crypto map * ? gdoi
        // crypto map * ? ipsec-manual
        // crypto map * ? ipsec-isakmp
        leaf policy {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum ipsec-isakmp {
              tailf:info "IPSEC w/ISAKMP";
            }
            enum ipsec-manual {
              tailf:info "IPSEC w/manual keying";
            }
            enum gdoi {
              tailf:info "GDOI";
            }
          }
        }

        leaf dynamic {
          tailf:info "Enable dynamic crypto map support";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          when "../policy = 'ipsec-isakmp'" {
            tailf:dependency "../policy";
          }
          type string {
            tailf:info "WORD;;Name of dynamic-map template";
          }
          tailf:non-strict-leafref {
            path "/ios:crypto/dynamic-map/name";
          }
        }

        leaf profile {
          tailf:info "Enable crypto map as a crypto-profile";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          when "../policy = 'ipsec-isakmp'" {
            tailf:dependency "../policy";
          }
          type string {
            tailf:info "WORD;;Name for this crypto profile";
          }
          tailf:non-strict-leafref {
            path "/ios:crypto/isakmp/profile/name";
          }
        }

        // crypto map * ? ipsec-isakmp / set
        // crypto map * ? ipsec-manual / set
        container set {
          tailf:cli-break-sequence-commands;
          tailf:info "Set values for encryption/decryption";
          when "../policy != 'gdoi'" {
            tailf:dependency "../policy";
          }
          // crypto map * ? ipsec-isakmp / set transform-set
          leaf transform-set {
            tailf:info "Specify list of transform sets in priority order";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;; Proposal tag";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/ipsec/transform-set/name";
            }
          }
          // crypto map * ? ipsec-isakmp / set isakmp-profile
          leaf isakmp-profile {
            tailf:info "Specify isakmp Profile";
            type string {
              tailf:info "WORD;;Name the isakmp profile";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/isakmp/profile/name";
            }
          }
          // crypto map * ? ipsec-isakmp / set peer
          leaf peer {
            tailf:info " Allowed Encryption/Decryption peer";
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of peer";
              }
              type string {
                tailf:info "WORD;;Host name of the peer";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address of peer";
              }
            }
          }
        }

        // crypto map * ? gdoi / set
        container gdoi-set {
          tailf:cli-break-sequence-commands;
          tailf:cli-drop-node-name;
          when "../policy = 'gdoi'" {
            tailf:dependency "../policy";
          }
          container set {
            tailf:info "Set values for encryption/decryption";
            leaf group {
              tailf:info "Set the secure group parameters";
              type string {
                tailf:info "WORD;;Set the group name";
              }
              tailf:non-strict-leafref {
                path "/ios:crypto/gdoi/group/name";
              }
            }
          }
        }

        // crypto map * ? gdoi / match
        container match {
          tailf:info "Match values.";
          leaf address {
            tailf:info "Match address of packets to encrypt";
            type ext-ip-acl-type;
          }
        }
      }
    }

    // crypto ssl
    container ssl {
      tailf:info "Configure Crypto SSL Options";

      // crypto ssl proposal *
      list proposal {
        tailf:info "Define ssl Proposal";
        tailf:cli-mode-name "config-crypto-ssl-proposal";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl Proposal";
          }
        }

        // crypto ssl proposal * / protection
        leaf-list protection {
          tailf:info "Specify the protection algorithms";
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum rsa-3des-ede-sha1 {
              tailf:info "RSA, 3DES and SHA1";
            }
            enum rsa-rc4128-md5 {
              tailf:info "RSA, RC4 and MD5";
            }
            enum rsa-aes128-sha1 {
              tailf:info "RSA, AES128 and SHA1";
            }
            enum rsa-aes256-sha1 {
              tailf:info "RSA, AES256 and SHA1";
            }
          }
        }
      }

      // crypto ssl authorization policy *
      container authorization {
        tailf:info "ssl authorization";
        list policy {
          tailf:info "Crypto SSL authorization policy";
          tailf:cli-mode-name "config-crypto-ssl-auth-policy";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }

          // crypto ssl authorization policy * / pool
          leaf pool {
            tailf:info "Specify pool";
            type string {
              tailf:info "WORD;;pool";  // ip local pool mypool
            }
          }

          // crypto ssl authorization policy * / dns
          container dns {
            tailf:info "Specify DNS Addresses";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf primary-server {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Primary DNS IP address";
              }
            }
            leaf secondary-server {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Secondary DNS IP address";
              }
            }
          }

          // crypto ssl authorization policy * / banner
          leaf banner {
            tailf:info "Specify banner";
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;banner string";
            }
          }

          // crypto ssl authorization policy * / def-domain
          leaf def-domain {
            tailf:info "Specify def_domain";
            type string {
              tailf:info "WORD;;def_domain string";
            }
          }
        }
      }

      // crypto ssl policy *
      list policy {
        tailf:info "Define SSL policies";
        tailf:cli-mode-name "config-crypto-ssl-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl policy";
          }
        }

        // crypto ssl policy * / ssl proposal
        container ssl {
          tailf:info "Specify ssl proposal";
          leaf proposal {
            tailf:info "Specify Proposal";
            type string {
              tailf:info "WORD;;Specify the name of proposal to be attached";
            }
          }
        }

        // crypto ssl policy * / pki
        container pki {
          tailf:info "Trustpoint options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf trustpoint {
            tailf:info "Certificate Trustpoint to authenticate clients";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Trustpoint name";
            }
          }
          leaf sign {
            tailf:info "Sign";
            type empty;
          }
        }

        // crypto ssl policy * / ip address
        container ip {
          tailf:info "ip options";
          container address {
            tailf:info "ip address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf local {
              tailf:info "ip address local";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf port {
              tailf:info "port configuration";
              type union {
                type uint16 {
                  tailf:info "443;;Default secure port";
                  range "443";
                }
                type uint16 {
                  tailf:info "<1025-65535>;;Port number";
                  range "1025..65535";
                }
              }
            }
          }
        }

        // crypto ssl policy * / shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }

      // crypto ssl profile *
      list profile {
        tailf:info "Define ssl Profiles";
        tailf:cli-mode-name "config-crypto-ssl-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl profile";
          }
        }

        // crypto ssl profile * / match
        container match {
          tailf:info "Specify the type to match";

          // crypto ssl profile * / match policy
          leaf policy {
            tailf:info "Specify Policy";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;Specify the name of policy to be attached";
            }
            tailf:non-strict-leafref {
              path "/ios:crypto/ssl/policy/name";
            }
          }

          // crypto ssl profile * / match url
          leaf url {
            tailf:info "Specify url";
            type string {
              tailf:info "WORD;;gateway[:port]/domain (specify port if not 443)";
            }
          }
        }

        // crypto ssl profile * / aaa
        container aaa {
          tailf:info "aaa";

          // crypto ssl profile * / aaa authentication
          container authentication {
            tailf:info "aaa authentication";
            leaf "list" {
              tailf:info "aaa authentication list";
              type string {
                tailf:info "WORD;;Specify the list name";
              }
            }
          }

          // crypto ssl profile * / aaa authorization
          container authorization {
            tailf:info "aaa authorization";
            container user {
              tailf:info "AAA user authorization";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf "list" {
                tailf:info "AAA method list";
                type string {
                  tailf:info "WORD;;AAA list name";
                }
              }
              leaf aaa-username {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;AAA username";
                }
              }
            }
          }
        }

        // crypto ssl profile * / authentication remote user-credentials
        container authentication {
          tailf:info "Specify authentication mode";
          container remote {
            tailf:info "remote server";
            leaf user-credentials {
              tailf:info "User credential mode";
              type empty;
            }
          }
        }

        // crypto ssl profile * / shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }
    }

  }


  /// ========================================================================
  /// buffers
  /// ========================================================================

  container buffers {
    tailf:info "Adjust system buffer pool parameters";
    container huge {
      tailf:info "Huge buffers";

      // buffers huge size
      leaf "size" {
        tailf:info "Size of huge buffers";
        type uint32 {
          tailf:info "<18024-65535>;;Size of huge buffers";
          range "18024..65535";
        }
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  container track {
    tailf:info "Object tracking configuration commands";

    // track *
    list track-object {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-track";
      tailf:cli-compact-syntax;
      tailf:cli-remove-before-change;
      key object-number;
      leaf object-number {
        type uint16 {
          tailf:info "<1-1000>;;Tracked object";
          range "1..1000";
        }
      }

      // track * list
      container "list" {
        tailf:info "Group objects in a list";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-hide-in-submode;

        // track * list boolean
        leaf boolean {
          tailf:info "List state based on a boolean calculation on objects";
          type enumeration {
            enum and {
              tailf:info "Boolean AND operation on list";
            }
            enum or {
              tailf:info "Boolean OR operation on list";
            }
          }
        }
      }

      // track * interface
      container interface {
        tailf:info "Select an interface to track";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-hide-in-submode;
        uses interface-name-grouping;
        leaf line-protocol {
          tailf:info "Track interface line-protocol";
          tailf:cli-full-command;
          type empty;
        }
      }

      // track * ip
      container ip {
        tailf:info "IP protocol";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-hide-in-submode;

        // track * ip route
        container route {
          tailf:info "IP route";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf "prefix" {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Prefix";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;mask";
            }
          }
          leaf reachability {
            tailf:info "Route reachability state";
            tailf:cli-full-command;
            type empty;
          }
          container metric {
            tailf:info "Route metric";
            tailf:cli-flatten-container;
            leaf threshold {
              tailf:info "Route metric threshold";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }

      // track * / object *
      list object {
        tailf:info "Add a tracked object to list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-1000>;;Tracked object number";
            range "1..1000";
          }
        }
        leaf not {
          tailf:info "Negate the state of object";
          type empty;
        }
      }

      // track * / delay
      container delay {
        tailf:info "Tracking delay";
        tailf:cli-compact-syntax;
        leaf down {
          tailf:info "Delay down change notification";
          type uint8 {
            tailf:info "<0-180>;;Seconds to delay";
            range "0..180";
          }
        }
        leaf up {
          tailf:info "Delay up change notification";
          type uint8 {
            tailf:info "<0-180>;;Seconds to delay";
            range "0..180";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// csdb
  /// ========================================================================

  container csdb {
    tailf:info "Common Session Database";

    // csdb tcp
    container tcp {
      tailf:info "CSDB TCP protocol";

      // csdb tcp finwait-time
      leaf finwait-time {
        tailf:info "CSDB TCP protocol: FIN/RST timeout";
        type uint8 {
          tailf:info "<1-50>;;fin/rst timeout value (sec), default 5 sec";
          range "1..50";
        }
        default 5;
      }

      // csdb tcp idle-time
      leaf idle-time {
        tailf:info "CSDB TCP protocol: idle timeout";
        type uint16 {
          tailf:info "<1-36000>;;idle timeout value (sec), default 3600 sec";
          range "1..36000";
        }
        default 3600;
      }

      // csdb tcp reassembly
      container reassembly {
        tailf:info "CSDB Out-of-Order Module";
        leaf max-memory {
          tailf:info "CSDB Out-of-Order: Queue Memory";
          type uint32 {
            tailf:info "<1-102400>;;OoO memory (KB), default 1024 KB";
            range "1..102400";
          }
          default 1024;
        }
        leaf max-queue-length {
          tailf:info "CSDB Out-of-Order: Queue Length";
          type uint8 {
            tailf:info "<0-128>;;OoO queue length, default 16 packets, "+
              "O means disable OoO";
            range "0..128";
          }
          default 16;
        }
      }

      // csdb tcp synwait-time
      leaf synwait-time {
        tailf:info "CSDB TCP protocol: 3-way handshake timeout";
        type uint16 {
          tailf:info "<0-300>;;syn timeout value (sec), default 30 sec";
          range "0..300";
        }
        default 30;
      }
    }

    // csdb udp idle-time
    container udp {
      tailf:info "CSDB UDP protocol";
      leaf idle-time {
        tailf:info "CSDB UDP Protocol: idle time";
        type uint16 {
          tailf:info "<1-1200>;;idle timeout value (sec), default 30 sec";
          range "1..1200";
        }
        default 30;
      }
    }

    // csdb icmp idle-time
    container icmp {
      tailf:info "CSDB ICMP protocol";
      leaf idle-time {
        tailf:info "CSDB ICMP Protocol: idle time";
        type uint16 {
          tailf:info "<1-1200>;;idle timeout value (sec), default 10 sec";
          range "1..1200";
        }
        default 10;
      }
    }

    // csdb session max-session
    container session {
      tailf:info "CSDB Session Management";
      leaf max-session {
        tailf:info "CSDB Session: maximum session";
        type uint32 {
          tailf:info "<1-655350>;;session, default 65535";
          range "1..655350";
        }
        default 65535;
      }
    }
  }


  /// ========================================================================
  /// ethernet
  /// ========================================================================

  container ethernet {
    tailf:info "Ethernet configuration";

    // ethernet evc *
    list evc {
      tailf:info "define an Ethernet virtual connection (EVC)";
      tailf:cli-mode-name "config-evc";
      tailf:cli-compact-syntax;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;EVC identifier of length <1-100>";
          length "1..100";
        }
      }

      // ethernet evc * / oam protocol cfm domain
      container oam {
        tailf:info "OAM Protocol";
        container protocol {
          tailf:info "Protocol for EVC status reporting";
          container cfm {
            tailf:info "Protocol CFM";
            leaf domain {
              tailf:info "Protocol CFM Domain";
              type string {
                tailf:info "WORD;;domain name";
              }
            }
          }
        }
      }
    }

    // ethernet cfm
    container cfm {
      tailf:info "Connectivity Fault Management";

      // ethernet cfm ieee
      leaf ieee {
        tailf:info "CFM IEEE enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm global
      leaf global {
        tailf:info "CFM global enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm traceroute cache
      container traceroute {
        tailf:info "CFM Traceroute";
        container cache {
          tailf:info "CFM Traceroute Cache";
          tailf:cli-display-separated;
          presence true;
          // ethernet cfm traceroute cache hold-time
          leaf hold-time {
            tailf:info "Hold Time";
            type uint16 {
              tailf:info "<1-65535>;;minutes (default 100)";
              range "1..65535";
            }
            default 100;
          }
        }
      }

      // ethernet cfm mip auto-create *
      container mip {
        tailf:info "CFM MIP commands";

        // ethernet cfm mip auto-create level ? evc *
        list auto-create {
          tailf:info "CFM MIP auto creation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key evc;
          leaf evc {
            tailf:info "auto create for CFM over EVC";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
          leaf level {
            tailf:info "Maintenance Level";
            tailf:cli-prefix-key;
            type uint8 {
              tailf:info "<0-7>;;maintenance level number";
              range "0..7";
            }
          }
        }
      }

      // ethernet cfm domain *
      list domain {
        tailf:info "Configure a domain";
        tailf:cli-mode-name "config-ecfm";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;maintenance domain name";
          }
        }
        // ethernet cfm domain * level
        leaf level {
          tailf:info "Maintenance Level";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<0-7>;;maintenance level number";
          }
        }

        // ethernet cfm domain * level / service *
        list service {
          tailf:info "Maintenance Association within Domain";
          tailf:cli-mode-name "config-ecfm-srv";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key csi-id;
          leaf csi-id {
            type string {
              tailf:info "WORD;;service instance id - short MA name";
            }
          }
          // ethernet cfm domain * level / service * port
          leaf port {
            tailf:info "DOWN service direction with no vlan association";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          // ethernet cfm domain * level / service * efc
          leaf evc {
            tailf:info "Specify EVC";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
          // ethernet cfm domain * level / service * efc vlan
          leaf vlan {
            tailf:info "Specify vlan (range 1-4094)";
            tailf:cli-hide-in-submode;
            type uint16 {
              tailf:info "<1-4094>;;between 1 and 4094";
              range "1..4094";
            }
          }
          // ethernet cfm domain * level / service * efc direction
          leaf direction {
            tailf:info "service direction";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type enumeration {
              enum down {
                tailf:info "direction towards the LAN";
              }
            }
          }

          // ethernet cfm domain * level / service * / continuity-check
          container continuity-check {
            tailf:cli-break-sequence-commands;
            tailf:info "Enable Continuity Check for Maintenance Association";
            tailf:cli-display-separated;
            presence true;
            // ethernet cfm domain * level / service * /
            // .. continuity-check interval
            leaf interval {
              tailf:info "Interval Continuity Check messages transmitted";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;interval string";
              }
            }
          }

          // ethernet cfm domain * level / service * / sender-id
          leaf sender-id {
            tailf:info "Include Sender ID TLV";
            tailf:cli-full-command;
            type enumeration {
              enum chassis {
                tailf:info "Send Chassis ID";
              }
              enum none {
                tailf:info "Info not included in Sender Id";
              }
            }
          }

          // ethernet cfm domain * level / service * / ais
          container ais {
            tailf:info "AIS Maintenance Condition";
            // ethernet cfm domain * level / service * / ais period
            leaf period {
              tailf:info "AIS Transmission period";
              type enumeration {
                enum "1" {
                  tailf:info "Seconds";
                }
                enum "60" {
                  tailf:info "Seconds";
                }
              }
              default "60";
            }
            // ethernet cfm domain * level / service * / ais level
            leaf level {
              tailf:info "Maintenance Level to send AIS";
              type uint8 {
                tailf:info "<0-7>;;Maintenance Level";
                range "0..7";
              }
            }
          }

          // ethernet cfm domain * level / service * / efd notify g8032
          container efd {
            tailf:info "Ethernet Fault Detection";
            container notify {
              tailf:info "EFD Notification Registration";
              leaf g8032 {
                tailf:info "Notify G.8032 Controller of EFD events";
                type empty;
              }
            }
          }
        }
      }
    }

    // ethernet ring g8032
    container ring {
      tailf:info "Ring";
      container g8032 {
        tailf:info "Specify the g.8032 ethernet ring";

        // ethernet ring g8032 profile *
        list profile {
          tailf:info "g.8032 ring profile configuration";
          tailf:cli-mode-name "config-erp-profile";
          key profile-name;
          leaf profile-name {
            type string {
              tailf:info "WORD;;ERP profile name string";
            }
          }
          // ethernet ring g8032 profile * / timer
          container timer {
            tailf:info "g.8032 timer";
            // ethernet ring g8032 profile * / timer wtr
            leaf wtr {
              tailf:info "Wait-to-Restore time";
              type uint8 {
                tailf:info "<1-12>;;minutes";
                range "1..12";
              }
            }
            // ethernet ring g8032 profile * / timer guard
            leaf guard {
              tailf:info "Guard timer";
              type uint16 {
                tailf:info "<10-2000>;;milliseconds";
                range "10..2000";
              }
            }
          }
        }

        // ethernet ring g8032 *
        list g8032-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-erp-ring";
          key ring-name;
          leaf ring-name {
            tailf:cli-disallow-value "profile";
            type string {
              tailf:info "WORD;;Name of the ethernet ring";
            }
          }

          // ethernet ring g8032 * / exclusion-list vlan-ids
          container exclusion-list {
            tailf:info "Specifiy exclusion list not protected by ERP";
            leaf-list vlan-ids {
              tailf:info "Assign list of VLANs to the exclusion list";
              tailf:cli-replace-all;
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
                range "1..4094";
              }
            }
          }

          // ethernet ring g8032 * / port0 interface
          container port0 {
            tailf:info "Port0 of the local node connected to G.8032 ring";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-erp-ring-port";
            tailf:cli-incomplete-command;
            container interface {
              tailf:info "Assign port interface";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-hide-in-submode;
              uses interface-name-grouping;
            }

            // ethernet ring g8032 * / port0 interface / monitor service
            container monitor {
              tailf:info "Assign the Ethernet Service Instance to monitor "+
                "g.8032 ring port";
              container service {
                tailf:info "Specify an Ethernet Service Instance";
                leaf instance {
                  tailf:info "Specify an Ethernet Service Instance";
                  type uint16 {
                    tailf:info "Ethernet Service Instance ID";
                    range "1..8000";
                  }
                }
              }
            }
          }

          // ethernet ring g8032 * / port1
          choice port1-choice {
            // ethernet ring g8032 * / port1 interface
            container port1 {
              tailf:info "Port1 of the local node connected to G.8032 ring";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-erp-ring-port";
              tailf:cli-incomplete-command;
              container interface {
                tailf:info "Assign port interface";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-hide-in-submode;
                uses interface-name-grouping;
              }

              // ethernet ring g8032 * / port1 interface / monitor service
              container monitor {
                tailf:info "Assign the Ethernet Service Instance to monitor "+
                  "g.8032 ring port";
                container service {
                  tailf:info "Specify an Ethernet Service Instance";
                  leaf instance {
                    tailf:info "Specify an Ethernet Service Instance";
                    type uint16 {
                      tailf:info "Ethernet Service Instance ID";
                      range "1..8000";
                    }
                  }
                }
              }
            }
            // ethernet ring g8032 * / port1 none
            container port1-none {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              container port1 {
                leaf none {
                  tailf:info "Assign port1 as none to enable g.8032 open-ring";
                  type empty;
                }
              }
            }
          }

          // ethernet ring g8032 * / instance *
          list instance {
            tailf:info "Configure the g.8032 ethernet ring instance";
            tailf:cli-mode-name "config-erp-inst";
            tailf:cli-full-command;
            key instance-id;
            leaf instance-id {
              type uint8 {
                tailf:info "<1-2>;;Instance number";
                range "1..2";
              }
            }

            // ethernet ring g8032 * / instance * / profile
            leaf profile {
              tailf:info "Specify associated g.8032 ethernet ring profile";
              type string {
                tailf:info "WORD;;Ethernet ring profile name";
              }
            }

            // ethernet ring g8032 * / instance * / rpl
            container rpl {
              tailf:info "Specify RPL owner, neighbor or next-neighbor";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf port {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum port0 {
                    tailf:info "Assign port0 as RPL owner, neighbor or "+
                      "next-neighbor";
                  }
                  enum port1 {
                    tailf:info "Assign port1 as RPL owner, neighbor or "+
                      "next-neighbor";
                  }
                }
              }
              leaf "type" {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum neighbor {
                    tailf:info "RPL neighbor";
                  }
                  enum next-neighbor {
                    tailf:info "RPL next neighbor";
                  }
                  enum owner {
                    tailf:info "RPL owner";
                  }
                }
              }
            }

            // ethernet ring g8032 * / instance * / inclusion-list
            container inclusion-list {
              tailf:info "Specify inclusion list protected by ERP";
              leaf-list vlan-ids {
                tailf:info "Associates a set of VLAN IDs with the current "+
                  "instance";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form a-b,c,d,e-f,g";
                  range "1..4094";
                }
              }
            }
            // ethernet ring g8032 * / instance * / aps-channel
            container aps-channel {
              tailf:info "Configure g.8032 instance aps-channel";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-erp-inst-aps";
              // ethernet ring g8032 * / instance * / aps-channel / port0
              container port0 {
                tailf:info "Configure g.8032 aps-channel info associated to port0";
                container service {
                  tailf:info "Specify an Ethernet Service Instance";
                  leaf instance {
                    tailf:info "Specify an Ethernet Service Instance";
                    type uint16 {
                      tailf:info "<1-8000>;;Ethernet Service Instance ID";
                      range "1..8000";
                    }
                  }
                }
              }
              // ethernet ring g8032 * / instance * / aps-channel / port1
              container port1 {
                tailf:info "Configure g.8032 aps-channel info associated to port1";
                choice port1-choice {
                  // ethernet ring g8032 * / instance * / aps-channel / port1 service
                  container service {
                    tailf:info "Specify an Ethernet Service Instance";
                    leaf instance {
                      tailf:info "Specify an Ethernet Service Instance";
                      type uint16 {
                        tailf:info "<1-8000>;;Ethernet Service Instance ID";
                        range "1..8000";
                      }
                    }
                  }
                  // ethernet ring g8032 * / instance * / aps-channel / port1 none
                  leaf none {
                    tailf:info "Specify port1 APS channel as none";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
    }

    // ethernet tcn-propagation *
    list tcn-propagation {
      tailf:info "Enable TCN propagation";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "source to";
      leaf source {
        type enumeration {
          enum g8032 {
            tailf:info "g.8032 ethernet ring";
          }
          enum rep {
            tailf:info "REP ethernet ring";
          }
        }
      }
      leaf to {
        tailf:info "propagate TCN to";
        tailf:cli-expose-key-name;
        type enumeration {
          enum g8032 {
            tailf:info "g.8032 ethernet ring";
          }
          enum rep {
            tailf:info "REP ethernet ring";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Configure interfaces";
    tailf:cli-diff-dependency "/ios:vrf/definition";
    tailf:cli-explicit-exit;

    // interface Null0
    list Null {
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
      }

      // interface Null0 / ip
      container ip {
        tailf:info "Interface Internet Protocol config commands";
        // no ip unreachables
        leaf unreachables {
          tailf:info "Enable sending ICMP Unreachable messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface Null0 / ipv6
      container ipv6 {
        tailf:info "IPv6 interface subcommands";
        // no ipv6 unreachables
        leaf unreachables {
          tailf:info "Enable sending of ICMP Unreachable messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // interface Loopback *
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern "([0-9\.])+";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Embedded-Service-Engine *
    list Embedded-Service-Engine {
      tailf:info "cisco embedded service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Tunnel *
    list Tunnel {
      tailf:info "Tunnel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<0-2147483647>;;Tunnel interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Tunnel* / qos
      container qos {
        tailf:info "Quality of Service related commands";
        leaf pre-classify {
          tailf:info "Enable QOS classification before packets are tunnel "+
            "encapsulated";
          type empty;
        }
      }

      // interface Tunnel* / tunnel
      uses interface-tunnel-grouping;
    }

    // interface Port-channel *
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:callpoint interface-port-channel-hook { tailf:set-hook node; }
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping {
        refine l2protocol-tunnel {
          tailf:cli-diff-dependency "../switchport";
        }
      }

      // interface Port-channel * / lacp
      container lacp {
        tailf:info "LACP Port Channel interface subcommands";
        // interface Port-channel * / lacp fast-switchover
        leaf fast-switchover {
          tailf:info "Enable LACP fast switchover on this port channel";
          type empty;
        }
        // interface Port-channel * / lacp max-bundle
        leaf max-bundle {
          tailf:info "LACP maximum number of ports to bundle in this "+
            "port channel";
          type uint8 {
            tailf:info "<1-8>;;Max number of ports to bundle in this "+
              "Port Channel";
            range "1..8";
          }
        }
      }

      // interface Port-channel * / mlacp
      container mlacp {
        tailf:info "mLACP Port Channel interface subcommands";
        container interchassis {
          tailf:info "mLACP Interchassis commands";
          leaf group {
            tailf:info "Interchassis Group";
            type uint32 {
              tailf:info "<1-4294967295>;;Group ID";
            }
          }
        }
      }
    }

    // subinterface Port-channel #.#
    container Port-channel-subinterface {
      tailf:cli-drop-node-name;
      list Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
        }
        uses interface-common-pre-grouping;
        uses interface-ethernet-pre-grouping;
        uses interface-switch-grouping; //CATALYST
        uses interface-ethernet-grouping;
        uses interface-common-grouping {
          refine l2protocol-tunnel {
            tailf:cli-diff-dependency "../switchport";
          }
        }
      }
    }

    // interface Multilink
    list Multilink {
      tailf:info "Multilink-group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-65535>;;Multilink interface number";
          range "1..65535";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface MFR *
    list MFR {
      tailf:info "Multilink Frame Relay bundle interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<0-2147483647>;;MFR interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // subinterface MFR #.#
    container MFR-subinterface {
      tailf:cli-drop-node-name;
      list MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum multipoint {
              tailf:info "Treat as a multipoint link";
            }
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;
      }
    }

    // interface BRI *
    list BRI {
      tailf:info "ISDN Basic Rate Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-0>;;BRI interface number";
          range "0";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Ethernet
    list Ethernet {
      tailf:info "Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping {
        refine l2protocol-tunnel {
          tailf:cli-diff-dependency "../switchport";
        }
      }
      uses interface-zone-member-grouping;
    }

    // interface FastEthernet
    list FastEthernet {
      tailf:info "FastEthernet IEEE 802.3";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping {
        refine l2protocol-tunnel {
          tailf:cli-diff-dependency "../switchport";
        }
      }
      uses interface-zone-member-grouping;
    }

    // interface GigabitEthernet *
    list GigabitEthernet {
      tailf:info "GigabitEthernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping {
        refine l2protocol-tunnel {
          tailf:cli-diff-dependency "../switchport";
        }
      }
      uses interface-zone-member-grouping;
    }

    // interface TenGigabitEthernet *
    list TenGigabitEthernet {
      tailf:info "Ten Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping {
        refine l2protocol-tunnel {
          tailf:cli-diff-dependency "../switchport";
        }
      }
      uses interface-zone-member-grouping;
    }

    // interface BDI *
    list BDI {
      tailf:info "Bridge-Domain interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4095>;;BDI interface number";
          range "1..4095";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-common-grouping;
    }

    // interface Cable *
    list Cable {
      tailf:info "CMTS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface * / downstream
      container downstream {
        tailf:info "Associate a Cable/Modular-Cable/Integrated-Cable "+
          "interface with this CGD host";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf Modular-Cable {
          tailf:info "Modular cable";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }

      // interface * / cable
      container cable {

        // interface * / cable tftp-enforce
        container tftp-enforce {
          tailf:info "Only allow modems to register if they attempt tftp first";
          tailf:cli-delete-when-empty;
          presence true;
          leaf mark-only {
            tailf:info "Allow registration but mark violating modems with # symbol";
            type empty;
          }
        }

        // interface * / cable ip-init
        leaf ip-init {
          tailf:info "IP Initialization Parameters";
          type enumeration {
            enum apm {
              tailf:info "Alternate Provisioning mode";
            }
            enum dual-stack {
              tailf:info "Dual-stack Provisioning mode";
            }
            enum ipv4 {
              tailf:info "IPv4 Provisioning mode";
            }
            enum ipv6 {
              tailf:info "IPv6 Provisioning mode";
            }
          }
          default ipv4;
        }

        // interface * / cable mtc-mode
        container mtc-mode {
          tailf:info "Enable/Disable Multiple Transmit Channel Mode";
          presence true;
        }

        // interface * / cable rcc-template *
        list rcc-template {
          tailf:info "Bind RCC template to interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key index;
          leaf index {
            type uint8 {
              tailf:info "<1-255>;;cable rcc-template id";
              range "1..255";
            }
          }
        }

        // interface * / cable rcp-control verbose
        container rcp-control {
          tailf:info "Receive Channel Profile control";
          leaf verbose {
            tailf:info "Enable verbose reporting";
            type empty;
          }
        }

        // interface * / cable shared-secret
        container shared-secret {
          tailf:info "Shared Secret String";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses password-07-grouping;
        }

        // interface * / cable dynamic-secret
        container dynamic-secret {
          tailf:info "Enable dynamic secret for CM config files";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice dynamic-secret-choice {
            case reject {
              leaf reject {
                tailf:info "Reject registration request from modems violating "+
                  "dynamic secret";
                type empty;
              }
            }
            case mark {
              leaf mark {
                tailf:info "Mark modems violating dynamic secret";
                type empty;
              }
            }
            case lock {
              leaf lock {
                tailf:info "Lock modems violating dynamic secret";
                type empty;
              }
              leaf lock-qos {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-1023>;;Profile used to lock";
                  range "1..1023";
                }
              }
            }
          }
          leaf nocrypt {
            tailf:info "Do not encrypt modem config file name";
            type empty;
          }
        }

        // interface * / cable enable-trap
        container enable-trap {
          tailf:info "Enable an SNMP cable trap";
          leaf cmonoff-notification {
            tailf:info "Cable Modem Online/Offline notification";
            type empty;
          }
          leaf cmonoff-interval {
            tailf:info "Interval in Seconds";
            type uint32 {
              tailf:info "<0-86400>;;Interval in secs";
              range "0..86400";
            }
          }
        }

        // interface * / no cable packet-cache
        leaf packet-cache {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / cable default-phy-burst
        leaf default-phy-burst {
          tailf:info "Max phy burst if max long data grant is 0";
          type uint16 {
            tailf:info "<0-4096>;;Maximal number of bytes allowed in a burst";
            range "0..4096";
          }
        }

        // interface * / cable insertion-interval
        container insertion-interval {
          tailf:info "Period between initial ranging opportunities - msec";
          choice interval-choice {
            leaf fixed-intrvl {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<100-2000>;;Fixed period between initial ranging slots - msec";
              }
            }
            container automatic {
              tailf:info "Use automatic adjustment algorithm for initial ranging period";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf min-intrvl {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<20-120>;;Lower bound on period between "+
                    "initial ranging slots - msecs";
                  range "20..120";
                }
                default 60;
              }
              leaf max-intrvl {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<240-1800>;;Upper bound on period between "+
                    "initial ranging slots - msecs";
                  range "240..1800";
                }
                default 480;
              }
            }
          }
        }

        // interface * / cable map-advance
        container map-advance {
          tailf:info "Set algorithm for the look-ahead time in MAPs";
          choice map-advance-choice {
            // interface * / cable map-advance static
            leaf static {
              type uint16 {
                tailf:info "<100-20000>;;max map advance - usecs";
                range "100..20000";
              }
            }
            // interface * / cable map-advance dynamic
            container dynamic {
              tailf:info "Automatically tune the value to the current propagation delay";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf safety {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<300-1500>;;Safety factor - usecs";
                  range "300..1500";
                }
              }
              leaf max-delay {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<100-20000>;;max map advance - usecs";
                  range "100..20000";
                }
              }
            }
          }
        }

        // interface * / cable sync-interval
        leaf sync-interval {
          tailf:info "Interval between CMTS transmission of successive SYNC";
          type uint16 {
            tailf:info "<1-200>;;sync interval - msec";
            range "1..200";
          }
        }

        // interface * / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface * / cable downstream
        container downstream {
          tailf:info "Downstream parameter configuration";
          // interface * / cable downstream dsg
          container dsg {
            tailf:info "Downstream DSG settings";
            // interface * / cable downstream dsg timer
            leaf timer {
              tailf:info "DSG Timer Setting";
              type uint16 {
                tailf:info "<1-65535>;;DSG timer index.";
              }
            }
            // interface * / cable downstream dsg tg *
            list tg {
              tailf:info "DSG Tunnel group";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key tgid;
              leaf tgid {
                type uint16 {
                  tailf:info "<1-65535>;;DSG Tunnel Group ID";
                  range "1..65535";
                }
              }
              // interface * / cable downstream dsg tg * channel *
              list channel {
                tailf:info "DSG Channel";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key channel-id;
                leaf channel-id {
                  type uint16 {
                    tailf:info "<1-65535>;;DSG Channel ID";
                    range "1..65535";
                  }
                }
              }
            }
          }
        }

        // interface * / cable upstream
        container upstream {
          tailf:info "Upstream port configuration";

          // interface * / cable upstream balance-scheduling
          leaf balance-scheduling {
            tailf:info "upstream channel balance scheduling on one mac-domain";
            type empty;
          }

          // interface * / cable upstream max-ports
          leaf max-ports {
            tailf:info "Maximum number of upstream ports for this interface";
            type uint8 {
              tailf:info "<0-8>;;Number of upstreams";
              range "0..8";
            }
          }

          // interface * / cable upstream bonding-group *
          list bonding-group {
            tailf:info "Configure upstream bonding group";
            tailf:cli-mode-name "config-upstream-bonding";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;bonding group id";
                range "1..65535";
              }
            }
            // interface * / cable upstream bonding-group * / upstream *
            list upstream {
              tailf:info "Add an upstream to this bonding group.";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key number;
              leaf number {
                type uint8 {
                  tailf:info "<0-4>;;upstream to add";
                }
              }
            }
            // interface * / cable upstream bonding-group * / attributes
            leaf attributes {
              tailf:info "Configure attributes for this bonding group.";
              type string {
                tailf:info "<0-FFFFFFFF>;;UBG Attribute Value in hex";
              }
            }
          }

          // interface * / cable upstream resiliency
          container resiliency {
            tailf:info "upstream resiliency configuration";
            leaf on-failure {
              tailf:info "ranging retries exceeded error handling";
              type enumeration {
                enum disable-channel {
                  tailf:info "disable channel";
                }
                enum extended-ranging {
                  tailf:info "continue to range";
                }
                enum reset-modem {
                  tailf:info "take modem offline";
                }
              }
              default extended-ranging;
            }
          }

          // interface * / cable upstream *
          list cable-upstream-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type uint8 {
                tailf:info "<0-4>;;Port number";
              }
            }
            // interface * / cable upstream * connector
            leaf connector {
              tailf:info "Physical upstream connector";
              type uint8 {
                tailf:info "<0-19>;;Physical port number";
                range "0..19";
              }
            }
            // interface * / cable upstream * frequency
            leaf frequency {
              tailf:info "Frequency";
              type uint32 {
                tailf:info "<5000000-85000000>;;Upstream Frequency in Hz";
                range "5000000..85000000";
              }
            }
            // interface * / cable upstream * channel-width
            container channel-width {
              tailf:info "Channel width in HZ";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf first-choice-width {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "Channel width Hz";
                }
              }
              leaf last-choice-width {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "Channel width Hz";
                }
              }
            }
            // interface * / cable upstream * description
            leaf "description" {
              tailf:info "Upstream name/description";
              tailf:cli-multi-value;
              tailf:cli-full-command;
              type string {
                tailf:info "LINE;;Up to 80 characters describing this US port";
              }
            }
            // interface * / cable upstream * docsis-mode
            leaf docsis-mode {
              tailf:info "Upstream channel DOCSIS mode";
              type enumeration {
                enum atdma {
                  tailf:info "DOCSIS 2.0 ATDMA-only channel";
                }
                enum scdma {
                  tailf:info "DOCSIS 2.0 SCDMA-only channel";
                }
                enum tdma {
                  tailf:info "DOCSIS 1.x-only channel";
                }
                enum tdma-atdma {
                  tailf:info "DOCSIS 1.x and DOCSIS 2.0 mixed channel";
                }
              }
            }
            // interface * / cable upstream * minislot-size
            leaf minislot-size {
              tailf:info "Minislot size";
              type uint8 {
                tailf:info "Minislot size in time ticks";
                range "2|4|8|16|32|64|128";
              }
            }
            // interface * / cable upstream * power-adjust
            container power-adjust {
              tailf:info "Power adjustment";
              // interface * / cable upstream * power-adjust continue
              leaf "continue" {
                tailf:info "Minimum power adjustment which set CONTINUE ranging status";
                type uint8 {
                  tailf:info "<2-15>;;Power level in dB";
                  range "2..15";
                }
              }
            }
            // interface * / cable upstream * range-backoff
            container range-backoff {
              tailf:info "Change Range Backoff Value";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              choice range-backoff-choice {
                case automatic {
                  leaf automatic {
                    tailf:info "Automatic Change Range Backoff Value";
                    type empty;
                  }
                }
                case numeric {
                  leaf start {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<0-15>;;rangebackoff-start";
                    }
                  }
                  leaf end {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<0-15>;;rangebackoff-end";
                    }
                  }
                }
              }
            }
            // interface * / cable upstream * modulation-profile
            container modulation-profile {
              tailf:info "Modulation Profile Number";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf primary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;modulation number";
                }
              }
              leaf secondary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;secondary modulation number";
                }
              }
              leaf tertiary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;tertiary modulation number";
                }
              }
            }
            // interface * / cable upstream * rate-limit
            // interface * / cable upstream * no rate-limit
            leaf rate-limit {
              tailf:info "Enable DOCSIS rate limiting on current upstream";
              tailf:cli-show-no;
              type empty;
            }
            // interface * / cable upstream * equalization-coefficient
            leaf equalization-coefficient {
              tailf:info "Enable equalization coefficient";
              type empty;
            }
            // interface * / cable upstream * rate-adapt
            container rate-adapt {
              tailf:info "Configure upstream rate-adapt";
              presence true;
            }
            // interface * / cable upstream * attribute-mask
            leaf attribute-mask {
              tailf:info "Upstream Channel Provisioned Attribute Mask";
              type string {
                tailf:info "<0-FFFFFFFF>;;Attribute mask in hex";
              }
            }
            // interface * / cable upstream * chan-class-id
            leaf chan-class-id {
              tailf:info "Channel Class ID";
              type string {
                tailf:info "<0-FFFFFFFF>;;Class ID Extension";
              }
            }
            // interface * / cable upstream * shutdown
            // interface * / cable upstream * no shutdown
            leaf shutdown {
              tailf:info "Shutdown upstream port";
              tailf:cli-show-no;
              type empty;
            }
          }
        }

        // interface * / cable sid-cluster-group
        container sid-cluster-group {
          tailf:info "SID Cluster Group parameters for Upstream Channel Bonding";
          // interface * / cable sid-cluster-group dynamic
          leaf dynamic {
            tailf:info "Dynamic algorithm";
            type empty;
          }
          // interface * / cable sid-cluster-group num-of-cluster
          leaf num-of-cluster {
            tailf:info "Number of SID Cluster Group";
            type uint8 {
              tailf:info "<1-8>;;1, 2, 3, 4, 5, 6, 7, 8";
              range "1..8";
            }
          }
          // interface * / cable sid-cluster-group  req-multiplier
          leaf req-multiplier {
            tailf:info "Request Multiplier";
            type uint8 {
              tailf:info "<1-16>;;1, 2, 4, 8, 16";
              range "1|2|4|8|16";
            }
          }
        }

        // interface * / cable sid-cluster-switching
        container sid-cluster-switching {
          tailf:info "SID Cluster Switching parameters for Upstream Channel "+
            "Bonding";
          // interface * / cable sid-cluster-switching max-request
          leaf max-request {
            tailf:info "Max request";
            type uint8 {
              tailf:info "<0-255>;;0 to 255";
            }
          }
          // interface * / cable sid-cluster-switching max-time
          leaf max-time {
            tailf:info "Max time";
            type uint16 {
              tailf:info "<0-65535>;;0 to 65535";
            }
          }
        }

        // interface * / cable divert-rate-limit
        container divert-rate-limit {
          tailf:info "Set divert-rate-limit parameters";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf rate {
            tailf:info "rate in packets/sec";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;rate in packets/second";
            }
          }
          leaf limit {
            tailf:info "limit in packets";
            type uint16 {
              tailf:info "<4-4194>;;limit in packets";
            }
          }
        }

        // interface * / cable privacy
        container privacy {
          tailf:info "Cable Privacy";

          // interface * / cable privacy mandatory
          leaf "mandatory" {
            tailf:info "force privacy be mandatory";
            type empty;
          }

          // interface * / cable privacy bpi-plus-policy
          leaf bpi-plus-policy {
            tailf:info "Privacy requires BPI+";
            type enumeration {
              enum capable-enforcement {
                tailf:info "BPI+ required for all capable modems with BPI+ "+
                  "enabled (policy 1)";
              }
              enum d11-enabled-enforcement {
                tailf:info "BPI+ required for all D1.1 and later modems with "+
                  "BPI+ enabled (policy 2)";
              }
              enum d11-enforcement {
                tailf:info "BPI+ required for all D1.1 and later modems "+
                  "(policy 3)";
              }
              enum total-enforcement {
                tailf:info "BPI+ required for all modems (policy 4)";
              }
            }
          }
        }
      }
    }

    // interface Modular-Cable *
    list Modular-Cable {
      tailf:info "Modular Cable interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface * / cable
      container cable {
        tailf:info "MC Cable interface subcommands";

        // interface * / cable bundle [READ-ONLY]
        leaf bundle {
          tailf:info "Bundle number for bundling of MC cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface * / cable rf-bandwidth-percent
        container rf-bandwidth-percent {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percent-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-96>;;% bandwidth";
              range "1..96";
            }
          }
          container remaining {
            tailf:info "ratio of the remaining bandwidth";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf ratio {
              tailf:info "ratio for sharing excess bandwidth";
              type uint8 {
                tailf:info "<1-100>;;Ratio";
              }
            }
          }
        }
      }
    }

    // interface Wideband-Cable *
    list Wideband-Cable {
      tailf:info "Wideband CMTS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface * / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface * / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of cable interfaces";
          tailf:cli-remove-before-change;
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface * / cable rf-channel
        container rf-channel {
          tailf:info "RF channel associated with this Wideband interface";
          // interface * / cable rf-channel *
          list rf-channel-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key rf-port;
            leaf rf-port {
              type uint8 {
                tailf:info "<0-23>;;RF channel number";
                range "0..23";
              }
            }
            // interface * / cable rf-channel * bandwidth-percent
            leaf bandwidth-percent {
              tailf:info "% bandwidth of RF channel reserved for this "+
                "Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
            // interface * / cable rf-channel * remaining ratio
            container remaining {
              tailf:info "ratio of the remaining bandwidth";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf ratio {
                tailf:info "ratio for sharing excess bandwidth";
                type uint8 {
                  tailf:info "<1-100>;;Ratio";
                }
              }
            }
          }
        }
      }
    }

    // interface Bundle *
    list Bundle {
      tailf:info "Virtual Bundle";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface * / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface * / no cable nd
        leaf nd {
          tailf:info "Enable IPv6 ND gleaning";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / cable arp
        container arp {
          tailf:info "Enable arp request";
          container filter {
            tailf:info "Filter arp packets";
            container request-send {
              tailf:info "send x arp requests every y seconds or none";
              tailf:cli-show-no;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;number of arp request packets";
                }
              }
              leaf window-size {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds";
                }
              }
            }
            container reply-accept {
              tailf:info "accept x arp replies every y seconds or none";
              tailf:cli-show-no;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;number of arp reply packets";
                }
              }
              leaf window-size {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds";
                }
              }
            }
          }
        }

        // no cable arp
        container conf {
          tailf:cli-drop-node-name;
          leaf arp {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }

        // interface * / cable ipv6
        container ipv6 {
          tailf:info "IPv6 related configuration";

          // interface * / cable ipv6 source-verify
          container source-verify {
            tailf:info "Enable verification of source of IPv6 packets";

            // interface * / cable ipv6 source-verify dhcp
            container dhcp {
              tailf:info "Verify address with the DHCPv6 server";
              presence true;
              leaf server {
                tailf:info "Specify the lease query server where the DHCPv6 "+
                  "lease queries should be sent";
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 Address of the lease query "+
                    "server";
                }
              }
            }

            // interface * / cable ipv6 source-verify leasequery-filter upstream
            container leasequery-filter {
              tailf:info "Filter x IPv6 lease query requests every y "+
                "seconds or none";
              container upstream {
                tailf:info "IPv6 Lease query for upstream pkts";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf threshold {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-20>;;Number of IPv6 lease queries per sid";
                    range "0..20";
                  }
                }
                leaf interval {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-5>;;size of time window in seconds for IPv6";
                    range "1..5";
                  }
                }
              }
            }

            // interface * / cable ipv6 leasetimer
            leaf leasetimer {
              tailf:info "Specify the IPv6 lease timer value";
              type uint8 {
                tailf:info "<1-240>;;IPv6 Time in minutes";
                range "1..240";
              }
            }
          }
        }

        // interface * / source-verify
        container source-verify {
          tailf:info "Enable verification of source of packets";

          // interface * / cable source-verify dhcp
          container dhcp {
            tailf:info "Verify address with the DHCPv4 server";
            presence true;
            leaf server {
              tailf:info "Specify the lease query server where the DHCPv4 "+
                "lease queries should be sent";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 Address of the lease query server";
              }
            }
          }

          // interface * / cable source-verify leasequery-filter upstream
          container leasequery-filter {
            tailf:info "Filter x IPv4 lease query requests every y "+
              "seconds or none";
            container upstream {
              tailf:info "Lease query for upstream pkts";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf threshold {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;Number of IPv4 lease queries per sid";
                  range "0..20";
                }
              }
              leaf interval {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds for IPv4";
                  range "1..5";
                }
              }
            }
          }

          // interface * / cable leasetimer
          leaf leasetimer {
            tailf:info "Specify the IPv4 lease timer value";
            type uint8 {
              tailf:info "<1-240>;;IPv4 Time in minutes";
              range "1..240";
            }
          }
        }

        // interface * / cable dhcp-parse
        container dhcp-parse {
          tailf:info "DHCP parse option";
          leaf option-43 {
            tailf:info "DHCP parse option 43";
            type empty;
          }
          leaf option-60 {
            tailf:info "DHCP parse option 60";
            type empty;
          }
        }

        // interface * / cable dhcp-giaddr
        container dhcp-giaddr {
          tailf:info "Control of giaddr in relayed DHCP requests";
          choice dhcp-giaddr-choice {
            container policy {
              tailf:info "Use primary address for CMs, secondary addresses "+
                "for hosts";
              presence true;
            }
            leaf primary {
              tailf:info "Use primary address for all devices";
              type empty;
            }
          }
        }

        // interface * / cable helper-address *
        list helper-address {
          tailf:info "Specify a destination address for UDP broadcasts";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key IP-address;
          leaf IP-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }
      }
    }

    // interface Cellular *
    list Cellular {
      tailf:info "Cellular WAN interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Vlan
    list Vlan {
      tailf:info "Catalyst Vlans";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
    }

    // interface Async *
    list Async {
      tailf:info "Async interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-9>;;Async interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Group-Async *
    list Group-Async {
      tailf:info "Async Group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-64>;;Group-Async interface number";
          range "0..64";
        }
      }
      leaf physical-layer {
        tailf:info "Configure sync or async physical layer on serial "+
          "interface";
        type enumeration {
          enum async {
            tailf:info "Configure asynchronous physical layer on serial "
              +"interface";
          }
          enum sync {
            tailf:info "Configure synchronous physical layer on serial "+
              "interface";
          }
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Serial
    list Serial {
      tailf:info "Serial interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // subinterface Serial
    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          type string {
            pattern "[0-9]+.*\..*";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum multipoint {
              tailf:info "Treat as a multipoint link";
            }
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }

    // interface Virtual-Template
    list Virtual-Template {
      tailf:info "Virtual Template interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }
      leaf "type" {
        tailf:info "type of the virtual-template";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum ethernet {
            tailf:info "Set VT type as ethernet";
          }
          enum serial {
            tailf:info "Set VT type as serial";
          }
          enum tunnel {
            tailf:info "Set VT type as tunnel";
          }
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping; // CATALYST
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-tunnel-grouping; // XE
    }

    // interface pseudowire
    list pseudowire {
      tailf:info "Pseudowire Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
      }

      // interface pseudowire * / description
      leaf "description" {
        tailf:info "Interface specific description";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          length "0..200";
        }
      }

      // interface pseudowire * / encapsulation
      leaf encapsulation {
        tailf:info "Data encapsulation method";
        type enumeration {
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
          enum mpls {
            tailf:info "Use MPLS encapsulation";
          }
        }
      }

      // interface pseudowire * / neighbor
      container neighbor {
        tailf:info "Neighbor options";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of the peer PE";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Peer VC ID value";
            range "1..4294967295";
          }
        }
      }

      // interface pseudowire * / label
      container label {
        tailf:info "MPLS local and remote pseudowire static labels";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf local-pseudowire-label {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Local pseudowire label";
          }
        }
        leaf remote-pseudowire-label {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-1048575>;;Remote pseudowire label";
            range "16..1048575";
          }
        }
      }

      // interface pseudowire * / signaling protocol
      container signaling {
        tailf:info "Signaling options";
        leaf protocol {
          tailf:info "Signaling protocol to use";
          type enumeration {
            enum ldp {
              tailf:info "Use LDP signaling";
            }
            enum none {
              tailf:info "No signaling, use manually configured pseudowires";
            }
          }
        }
      }

      // interface pseudowire * / control-word
      leaf control-word {
        tailf:info "Control-word options";
        type enumeration {
          enum exclude {
            tailf:info "Exclude control-word in pseudowire packets";
          }
          enum "include" {
            tailf:info "Include control-word in pseudowire packets";
          }
        }
      }

      // interface pseudowire * / shutdown
      leaf shutdown {
        tailf:info "Shutdown the selected interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }

      // interface pseudowire * / shutdown
      container service-policy {
        tailf:info "Configure Service Policy";
        uses service-policy-grouping;
      }
    }

    // interface LISP #
    list LISP {
      tailf:info "Locator/ID Separation Protocol Virtual Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // subinterface LISP #.#
    container LISP-subinterface {
      tailf:cli-drop-node-name;
      list LISP {
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;
      }
    }

  }


  /// ========================================================================
  /// access-list
  /// ========================================================================

  container access-list {
    tailf:info "Add an access list entry";
    tailf:cli-compact-syntax;
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // access-list *
    list access-list-standard-range {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key listnumber;
      leaf listnumber {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-99>;;IP standard access list";
          range "1..99";
        }
      }
      list std-access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject\n"+
                        "permit;;Specify packets to forwards\n"+
                        "remark;;Access list entry comment";
            pattern "(permit.*)|(deny.*)|(remark.*)";
          }
        }
      }
    }

    // access-list *
    list access-list-extended-range {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key listnumber;
      leaf listnumber {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<100-199>;;IP extended access list";
          range "100..199";
        }
      }
      list ext-access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject"+
                        "dynamic;;Specify DYNAMIC list of PERMITs or DENYs"+
                        "permit;;Specify packets to forwards"+
                        "remark;;Access list entry comment";
            pattern "(permit.*)|(deny.*)|(remark.*)";
          }
        }
      }
    }

    // access-list *
    list access-list-standard-expanded {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key listnumber;
      leaf listnumber {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1300-1999>;;IP standard access list (expanded range)";
          range "1300..1999";
        }
      }
      list ext-access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject"+
                        "dynamic;;Specify DYNAMIC list of PERMITs or DENYs"+
                        "permit;;Specify packets to forwards"+
                        "remark;;Access list entry comment";
            pattern "(permit.*)|(deny.*)|(remark.*)";
          }
        }
      }
    }

    // access-list *
    list access-list-extended-expanded {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key listnumber;
      leaf listnumber {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<2000-2699>;;IP extended access list (expanded range)";
          range "2000..2699";
        }
      }
      list ext-access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject"+
                        "dynamic;;Specify DYNAMIC list of PERMITs or DENYs"+
                        "permit;;Specify packets to forwards"+
                        "remark;;Access list entry comment";
            pattern "(permit.*)|(deny.*)|(remark.*)|(dynamic.*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// virtual-service (XE)
  /// ========================================================================

  list virtual-service {
    tailf:info "Configure virtual service";
    tailf:cli-mode-name "config-virt-serv";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Virtual service name (up to 63 characters)";
      }
    }

    // virtual-service / description
    leaf "description" {
      tailf:info "Virtual service description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this virtual service "+
          "(up to 191 characters)";
        length "0..191";
      }
    }
  }


  /// ========================================================================
  /// route-map
  /// ========================================================================

  list route-map {
    tailf:info "Route map tag";
    tailf:cli-mode-name "config-route-map";
    tailf:cli-compact-syntax;
    tailf:cli-full-command;
    key "name sequence";
    leaf name {
      type string {
        tailf:info "WORD;;Route map tag";
      }
    }

    // route-map * #
    leaf sequence {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-65535>;;Sequence to insert to/delete from "
          +"existing route-map entry";
        range "0..65535";
      }
    }

    // route-map * permit
    // route-map * deny
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      type enumeration {
        enum deny {
          tailf:code-name "op_deny";
          tailf:info "Route map denies set operations";
        }
        enum permit {
          tailf:code-name "op_internet";
          tailf:info "Route map permits set operations";
        }
      }
    }

    // route-map * / description
    leaf "description" {
      tailf:info "Route-map comment";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Comment up to 100 characters";
        length "0..100";
      }
    }

    // route-map * / match
    container match {
      tailf:info "Match values from routing table";

      // route-map * / match as-path *
      container as-path {
        tailf:info "Match BGP AS path list";
        leaf-list path-list-number {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type uint16 {
            tailf:info "<1-500>;;AS path access-list";
          }
        }
      }

      // route-map * / match ip
      container ip {
        tailf:info "IP specific information";
        container address {
          tailf:info "Match address of route or match packet";
          choice address-choice {
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
            leaf prefix-list {
              tailf:info "Match entries of prefix-lists";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ip/prefix-list/prefixes/name";
              }
            }
          }
        }
      }

      // route-map * / match ipv6
      container ipv6 {
        tailf:info "IPv6 specific information";
        container address {
          tailf:info "Match address of route";
          choice address-choice {
            leaf access-list {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;IPv6 access-list name";
                pattern '[a-zA-Z].*';
              }
            }

            leaf prefix-list {
              tailf:info "IPv6 prefix-list";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ipv6/prefix-list/prefixes/name";
              }
            }
          }
        }
      }

      // route-map * / match community
      container community {
        tailf:info "Match BGP community list";
        leaf-list name {
          tailf:info "Named Access List";
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "<1-99>       Community-list number (standard)
            <100-500>       Community-list number (expanded)
            WORD            Community-list name
            exact-match     Do exact matching of communities
            ";
          }
        }
      }
    }

    // route-map * / set
    container set {
      tailf:info "Set values in destination routing protocol";

      // route-map * / set as-path
      container as-path {
        tailf:info "Prepend string for a BGP AS-path attribute";
        container prepend {
          tailf:info "Prepend to the as-path";
          container as-container {
            tailf:cli-drop-node-name;
            leaf as-number {
              tailf:info "<1-65535>;;AS number";
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "<1-65535>;;AS number";
              }
            }
          }
          container last-as-cont {
            tailf:cli-drop-node-name;
            leaf last-as {
              type uint16 {
                tailf:info "<1..10>;;number of last-AS prepends";
                range "1..10";
              }
            }
          }
        }
        container tag {
          tailf:info "Set the tag as an AS-path attribute";
          tailf:cli-full-command;
          presence "tag";
        }
      }

      // route-map * / set community
      container community {
        tailf:info "BGP community attribute";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf-list community-number {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;community number";
              range "1..4294967295";
            }
            type string {
              tailf:info "aa:nn;;community number in aa:nn format";
              pattern "[0-9]+:[0-9]+";
            }
            type enumeration {
              enum additive {
                tailf:info "Add to the existing community";
              }
              enum internet {
                tailf:info "Internet (well-known community)";
              }
              enum local-AS {
                tailf:info "Do not send outside local AS "
                  +"(well-known community)";
              }
              enum no-advertise {
                tailf:info "Do not advertise to any peer "
                  +"(well-known community)";
              }
              enum no-export {
                tailf:info "Do not export to next AS "
                  +"(well-known community)";
              }
              enum none {
                tailf:info "No community attribute";
              }
            }
          }
        }
      }

      // route-map * / set comm-list
      container comm-list {
        tailf:info "set BGP community list (for deletion)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-99>;;Community-list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Community-list number (expanded)";
              range "100..500";
            }
            type string {
              tailf:info "WORD;;Community-list name";
            }
          }
        }
        leaf delete {
          tailf:info "Delete matching communities";
          tailf:cli-full-command;
          type empty;
        }
      }

      // route-map * / set extcommunity
      container extcommunity {
        tailf:info "BGP extended community attribute";
        leaf-list rt {
          tailf:info "Route Target extended community";
          tailf:cli-flat-list-syntax;
          type asn-ip-type {
            tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
          }
        }
      }

      // route-map * / set ip
      container ip {
        tailf:info "IP specific information";

        // route-map * / set ip next-hop
        container next-hop {
          tailf:info "Next hop address";
          choice next-hop-choice {
            leaf-list address {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of next hop";
              }
            }
            container dynamic {
              tailf:info "application dynamically sets next hop";
              leaf dhcp {
                tailf:info "DHCP learned next hop";
                type empty;
              }
            }
            container encapsulate {
              tailf:info "Encapsulation profile for VPN nexthop";
              leaf l3vpn {
                tailf:info "L3VPN";
                type string {
                  tailf:info "WORD;;Encapsulation profile name";
                }
              }
            }
            leaf peer-address {
              tailf:info "Use peer address (for BGP only)";
              type empty;
            }
          }
        }

        // route-map * / set ip df
        container df {
          tailf:info "Set DF bit";
          tailf:cli-delete-when-empty;
          presence true;
          leaf "bit" {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-1>;;DF bit";
              range "0..1";
            }
          }
        }
      }

      // route-map * / set ipv6
      container ipv6 {
        tailf:info "IPv6 specific information";

        // route-map * / set ipv6 next-hop
        container next-hop {
          tailf:info "IPv6 Next hop";
          choice next-hop-choice {
            leaf-list address {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Next hop address";
              }
            }
            leaf peer-address {
              tailf:info "Use peer address (for BGP only)";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }

      // route-map * / set local-preference
      container local-preference {
        tailf:info "BGP local preference path attribute";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "value" {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Preference value";
          }
        }
      }

      // route-map * / set metric
      leaf metric {
        tailf:info "Metric value for destination routing protocol";
        type string {
          tailf:info "+/-<metric>;;Add or subtract metric
          <0-4294967295>;;Metric value or Bandwidth in Kbits per second";
          pattern '[+-]?[0-9].*';
        }
      }

      // route-map * / set metric-type
      leaf metric-type {
        tailf:info "Type of metric for destination routing protocol";
        type enumeration {
          enum external {
            tailf:info "IS-IS external metric";
          }
          enum internal {
            tailf:info "IS-IS internal metric or Use IGP metric "
              +"as the MED for BGP";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 metric";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 metric";
          }
        }
      }

      // route-map * / set weight
      leaf weight {
        tailf:info "BGP weight for routing table";
        type uint32 {
          tailf:info "<0-65535>;;Weight value";
          range "0..65535";
        }
      }

      // route-map * / set origin
      container origin {
        tailf:info "BGP origin code";
        choice origin-choice {
          leaf origin-value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum igp {
                tailf:info "local IGP";
              }
              enum incomplete {
                tailf:info "unknown heritage";
              }
            }
          }
          leaf egp {
                tailf:info "remote EGP";
            type uint32 {
              tailf:info "<0-65535>;;remote AS";
              range "0..65535";
            }
          }
        }
      }

      // route-map * / set vrf
      leaf vrf {
        tailf:info "Define VRF name";
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // route-map * / set tag
      leaf tag {
        tailf:info "Tag value for destination routing protocol";
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }
    }

    // route-map * / continue
   leaf "continue" {
     tailf:info "Continue on a different entry within the route-map";
     type uint16 {
       tailf:info "<0-65535>;;Route-map entry sequence number";
     }
   }

  }


  /// ========================================================================
  /// dialer
  /// ========================================================================

  container dialer {
    tailf:info "Dialer commands";

    // dialer watch-list *
    list watch-list {
      tailf:info "Dialer watch list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-255>;;Dialer watch group number";
          range "1..255";
        }
      }

      // dialer watch-list * ip
      container ip {
        tailf:info "IP";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Protocol specific address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // dialer watch-list * delay
      container delay {
        tailf:info "Dialer watch delay";
        // dialer watch-list * delay route-check
        container route-check {
          tailf:info "Interval for checking watched route";
          leaf initial {
            tailf:info "Delay for initial check of watched route after boot";
            type uint32 {
              tailf:info "<1-2147483>;;Delay time in seconds";
            }
          }
        }
        // dialer watch-list * delay connect
        leaf connect {
          tailf:info "Interval before dialing the secondary route";
          type uint32 {
            tailf:info "<1-2147483>;;Delay time in seconds";
            range "1..2147483";
          }
        }
        // dialer watch-list * delay disconnect
        leaf disconnect {
          tailf:info "Interval before disconnecting the secondary route";
          type uint32 {
            tailf:info "<1-2147483>;;Delay time in seconds";
            range "1..2147483";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dialer-list
  /// ========================================================================

  list dialer-list {
    tailf:info "Create a dialer list entry";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key id;
    leaf id {
      type uint16 {
        tailf:info "<1-128>;;Dialer group number";
      }
    }
    container protocol {
      tailf:info "Permit or Deny based on protocols";
      leaf ip {
        tailf:info "IP";
        type enumeration {
          enum deny {
            tailf:info "Deny specified protocol";
          }
          enum "list" {
            tailf:info "Add access list to dialer list";
          }
          enum permit {
            tailf:info "Permit specified protocol";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// authentication
  /// ========================================================================

  container authentication {
    //FIXME: info+syntax

    container mac-move {
      leaf permit {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner exec
    leaf exec {
      tailf:info "Set EXEC process creation banner. ";
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner login
    leaf login {
      tailf:info "Set login banner.";
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner prompt-timeout
    leaf prompt-timeout {
      tailf:info "Set Message for login authentication timeout.";
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner motd
    leaf motd {
      tailf:info "Set Message of the Day banner.";
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }
  }


  /// ========================================================================
  /// pseudowire-class
  /// ========================================================================

  list pseudowire-class {
    tailf:info "Pseudowire-class configuration";
    tailf:cli-mode-name "config-pw-class";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Pseudowire-class name";
      }
    }

    // pseudowire-class * / encapsulation
    leaf encapsulation {
      tailf:info "Data encapsulation method";
      type enumeration {
        enum l2tpv2 {
          tailf:info "Use L2TPv2 encapsulation";
        }
        enum l2tpv3 {
          tailf:info "Use L2TPv3 encapsulation";
        }
        enum mpls {
          tailf:info "Use MPLS encapsulation";
        }
      }
    }

    // pseudowire-class * / control-word
    leaf control-word {
      tailf:info "Include control-word in pseudowire packets";
      type empty;
    }

    // pseudowire-class * / status
    container "status" {
      tailf:info "Pseudowire status capabilities";
      container peer {
        tailf:info "peer status configuration";
        container topology {
          tailf:info "change status behaviour based on peer topology";
          leaf dual-homed {
            tailf:info "Our peer(s) are participating in a redundant "+
              "solution with some form of redundancy protocol running"+
              " between the peer routers";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  container control-plane {
    tailf:info "Configure control plane services";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-cp";
    presence true;

    // control-plane service-policy
    container service-policy {
      tailf:info "Configure QOS Service Policy";
      uses service-policy-grouping;
    }
  }


  /// ========================================================================
  /// cops
  /// ========================================================================

  container cops {
    tailf:info "Common Open Policy Service (COPS)";

    // cops listener access-list
    container listener {
      tailf:info "Incoming connections from policy decision points (PDPs)";
      leaf access-list {
        tailf:info "Rules for PDPs connecting to local COPS listeners";
        type exp-ip-acl-type;
      }
    }

    // cops ip dscp
    container ip {
      tailf:info "IP parameters for COPS connections";
      leaf dscp {
        tailf:info "Differentiated Services Code Point marking for "+
          "COPS messages";
        type dscp-type;
      }
    }
  }


  /// ========================================================================
  /// connect
  /// ========================================================================

  list connect {
    tailf:info "cross-connect two interfaces";
    tailf:cli-mode-name "config-connection";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;

    key "interface1 interface2";
    leaf name {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      //must "../../ip/cef" {
      //error-message "Please enable CEF before configuring connect";
      //tailf:dependency "../../ip/cef";
      //}
      type string {
        tailf:info "WORD;;Name for this connection";
      }
    }
    leaf interface1 {
      type string {
        tailf:info "WORD;;First interface name";
      }
    }
    leaf number1 {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type uint16 {
        tailf:info "<1-8184>;;Service Instance Identifier";
        range "1..8184";
      }
    }
    leaf interface2 {
      type string {
        tailf:info "WORD;;Second interface name";
      }
    }
    leaf number2 {
      tailf:cli-drop-node-name;
      tailf:cli-hide-in-submode;
      type uint16 {
        tailf:info "<1-8184>;;Service Instance Identifier";
        range "1..8184";
      }
    }

    // connect * / backup
    container backup {
      tailf:cli-break-sequence-commands;
      tailf:info "Xconnect backup configuration commands";

      // connect * / backup peer
      container peer {
        tailf:info "Backup pseudowire";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf peer-router-ip-addr {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Peer VC ID value";
            range "1..4294967295";
          }
        }
        leaf pw-class {
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "Optional Pseudowire-class to use for "+
              "backup pseudowire";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// voice-port
  /// ========================================================================

  list voice-port {
    tailf:info "Configure a specific voice-port";
    tailf:cli-mode-name "config-voiceport";
    key name;
    leaf name {
      type string {
        tailf:info "<0-0>;;Voice interface slot #";
      }
    }

    // voice-port * / timeouts
    container timeouts {
      tailf:info "Configure voice timeout parameters";
      leaf interdigit {
        tailf:info "Interdigit Timeout duration in seconds";
        type uint8 {
          tailf:info "<0-120>;;seconds";
          range "0..120";
        }
      }
    }

    // voice-port * / busyout
    container busyout {
      tailf:info "Configure busyout trigger event & procedure";

      leaf action {
        //FIXME: config not found on device
        tailf:cli-full-command;
        type string;
      }

      // voice-port * / busyout monitor
      container monitor {
        tailf:info "The event of this interface triggers busyout";

        // voice-port * / busyout monitor action<
        container action {
          tailf:info "busyout action when monitoring triggered";
          choice action-choice {
            leaf graceful {
              tailf:info "graceful busyout when monitoring triggered";
              type empty;
            }
            leaf shutdown {
              tailf:info "shutdown D channel when monitoring triggered";
              type empty;
            }
            container alarm {
              tailf:info "Use alarm generation";
              leaf blue {
                tailf:info "Use blue alarm";
                type empty;
              }
            }
          }
        }

        // voice-port * / busyout monitor *
        list state {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf in-service {
            tailf:info "Inverted logic trigger by interface "+
              "back up or in service";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dial-peer
  /// ========================================================================

  container dial-peer {
    tailf:info "Dial Map (Peer) configuration commands";

    // dial-peer voice *
    list voice {
      tailf:info "Voice type";
      tailf:cli-mode-name "config-dial-peer";
      tailf:cli-incomplete-command;
      tailf:cli-sequence-commands;
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-2147483647>;;Voice dial-peer tag";
          range "1..2147483647";
        }
      }
      leaf peer {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum mmoip {
            tailf:info "Multi Media Over IP";
          }
          enum pots {
            tailf:info "Telephony";
          }
          enum voatm {
            tailf:info "Voice over ATM";
          }
          enum vofr {
            tailf:info "Voice over Frame Relay";
          }
          enum voip {
            tailf:info "Voice over IP";
          }
        }
      }

      // dial-peer voice * / answer-address
      leaf answer-address {
        tailf:cli-break-sequence-commands;
        tailf:info "The Call Destination Number";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A string of digits including wild cards";
        }
      }

      // dial-peer voice * / trunkgroup
      leaf trunkgroup {
        tailf:info "trunk groups associated with this peer";
        type string {
          tailf:info "WORD;;trunkgroup id";
        }
        tailf:non-strict-leafref {
          path "/ios:trunk/group/name";
        }
      }

      // dial-peer voice * / description
      leaf "description" {
        tailf:info "Dialpeer specific description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Up to 64 characters describing this dialpeer";
          length "1..64";
        }
      }

      // dial-peer voice * / translation-profile
      container translation-profile {
        tailf:info "Translation profile";
        leaf incoming {
          tailf:info "Translation Profile for incoming call leg";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf outgoing {
          tailf:info "Translation Profile for outgoing call leg";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dial-peer voice * / huntstop
      leaf huntstop {
        tailf:info "Stop hunting on Dial-Peers";
        tailf:cli-full-command;
        type empty;
      }

      // dial-peer voice * / max-conn
      leaf max-conn {
        tailf:info "Sets the maximum connections per peer, "+
          "negation sets to unlimited";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-2147483647>;;Maximum connections, "+
            "negation sets to unlimited";
        }
      }

      // dial-peer voice * / destination-pattern
      leaf destination-pattern {
        tailf:info "A full E.164 telephone number prefix";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A sequence of digits - "+
            "representing the prefix or full telephone number";
        }
      }

      // dial-peer voice * / modem passthrough
      container modem {
        tailf:info "Modem commands through this peer";
        container passthrough {
          tailf:info "Pass modem traffic via clear channel";
          choice passthrough-choice {
            // dial-peer voice * / no modem passthrough system
            leaf system {
              tailf:info "Use global configuration";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            container nse {
              tailf:info "Use Named Signaling Events (NSE)";
              tailf:cli-compact-syntax;
              leaf payload-type {
                tailf:info "Configure NSE payload type";
                type uint32 {
                  tailf:info "<98-117>;;Payload type value";
                }
              }
              leaf codec {
                tailf:info "Codec selections for upspeed";
                type enumeration {
                  enum g711ulaw {
                    tailf:info "G.711 u Law 64000 bp";
                  }
                  enum g711alaw {
                    tailf:info "G.711 A Law 64000 bps";
                  }
                }
              }
              leaf redundancy {
                tailf:info "Use Packet Redundancy (RFC2198) for modem traffic";
                type empty;
              }
            }
          }
        }
      }

      // dial-peer voice * / session
      container session {
        tailf:info "The session [ target | protocol | transport ]"+
          " for this peer";
        leaf protocol {
          tailf:info "The session protocol to be used in getting to this peer";
          type enumeration {
            enum aal2-trunk {}
            enum cisco {
              tailf:info "Cisco Session Protocol";
            }
            enum sipv2 {
              tailf:info "IETF Session Initiation Protocol";
            }
            enum smtp {}
            enum multicast {
              tailf:info "Multicast Session Protocol(voice conferencing)";
            }
          }
        }
        leaf target {
          tailf:info "The session target for this peer";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;A string specifying the session target";
          }
        }
      }

      // dial-peer voice * / dtmf-relay
      container dtmf-relay {
        tailf:info "Transport DTMF digits across IP link. "+
          "Enter DTMF Relay options in order of preference.";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf cisco-rtp {
          tailf:info "Cisco Proprietary RTP";
          type empty;
        }
        leaf h245-alphanumeric {
          tailf:info "DTMF Relay via H245 Alphanumeric IE";
          type empty;
        }
        leaf h245-signal {
          tailf:info "DTMF Relay via H245 Signal IE";
          type empty;
        }
        leaf rtp-nte {
          tailf:info "RTP Named Telephone Event RFC 2833";
          type empty;
        }
      }

      // dial-peer voice * / incoming called-number
      container incoming {
        tailf:info "Incoming called number";
        leaf called-number {
          tailf:info "An incoming called number pattern";
          type string {
            tailf:info "WORD;;A sequence of digits "+
              "representing a phone number prefix";
          }
        }
      }

      // dial-peer voice * / direct-inward-dial
      leaf direct-inward-dial {
        type empty;
      }

      // dial-peer voice * / forward-digits
      leaf forward-digits {
        type union {
          type uint8 {
          }
          type enumeration {
            enum all {}
            enum extra {}
          }
        }
      }

      // dial-peer voice * / codec
      container codec {
        tailf:info "The codec rate to be attempted in getting to this peer";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Codec name";
          }
        }
        leaf bytes {
          tailf:info "Specify number of voice data bytes per frame";
          tailf:cli-break-sequence-commands;
          type uint32;
        }
        leaf mode {
          tailf:info "Specify the value of the mode";
          type uint32 {
            tailf:info "20 = 15.2 kbps, 30 = 13.33 kbps";
          }
        }
      }

      // dial-peer voice * / fax protocol
      container fax {
        tailf:info "Configure fax";
        container protocol {
          tailf:info "The fax protocol to be attempted in getting "+
            "to this peer";
          choice protocol-option {
            leaf none {
              tailf:info "No FAX protocol";
              type empty;
            }
            leaf cisco {
              tailf:info "Use Cisco proprietary protocol";
              type empty;
            }
            leaf pass-through {
              tailf:info "Use an audio codec for fax transport";
              type enumeration {
                enum g711ulaw {
                  tailf:info "G.711 u Law 64000 bps (for T1)";
                }
                enum g711alaw {
                  tailf:info "G.711 A Law 64000 bps (for E1)";
                }
              }
            }
          }
        }
      }

      // dial-peer voice * / ip qos dscp *
      container ip {
        tailf:info "Set ip packet options";
        container qos {
          tailf:info "Set ip QoS Parameters";
          list dscp {
            tailf:info "Specify ip DSCP";
            tailf:cli-compact-syntax;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              // number | set-af | set-cs | default | ef
              type string {
                tailf:info "WORD;;voice set";
              }
            }
            choice dscp-choice {
              leaf media {
                tailf:info "Apply DSCP to media payload packets";
                type empty;
              }
              leaf signaling {
                tailf:info "Apply DSCP to signaling packets";
                type empty;
              }
              leaf video {
                tailf:info "Apply DSCP to video packets";
                type enumeration {
                  enum rsvp-none {
                    tailf:info "Use this DSCP value if RSVP "+
                      "is not configured";
                  }
                  enum rsvp-pass {
                    tailf:info "Use this DSCP value if RSVP "+
                      "reservation is successful";
                  }
                  enum rsvp-fail {
                    tailf:info "Use this DSCP value if RSVP "+
                      "reservation fails";
                  }
                }
              }
            }
          }
        }
      }

      // dial-peer voice * / no vad
      leaf vad {
        tailf:info "Use VoiceActivityDetection as necessary option";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // no dial-peer outbound status-check pots
    container outbound {
      tailf:info "Define the outbound options";
      container status-check {
        tailf:info "Enable or disable status checking";
        leaf pots {
          tailf:info "Telephony";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // dial-peer cor custom
    container cor {
      container custom {
        tailf:cli-add-mode;
        presence true;
        // dial-peer cor custom / name *
        list name {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// config-register
  /// ========================================================================

  leaf config-register {
    tailf:info "Define the configuration register";
    type string {
      tailf:info "<0x0-0xFFFF>;;Config register number";
      pattern "[0-9xXa-fA-F].*";
    }
  }


  /// ========================================================================
  /// network-clock-participate
  /// ========================================================================

  container network-clock-participate {
    tailf:info "Participate in Network Clocking";
    container wic {
      tailf:info "WIC Module";
      list wic-enabled {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          type uint8 {
            tailf:info "<0-3>;;Slot Number (physical)";
            range "0..3";
          }
        }
      }
      list wic-disabled {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          type uint8 {
            tailf:info "<0-3>;;Slot Number (physical)";
            range "0..3";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mgcp
  /// ========================================================================

  container mgcp {
    tailf:info "Enable Media Gateway Control Protocol";

    // mgcp fax t38 ecm
    container fax {
      tailf:info "Configure MGCP Fax Parameters";
      container t38 {
        tailf:info "Configure MGCP Fax T.38 Parameters";
        leaf ecm {
          tailf:info "Enable Error Correction Mode (ECM)";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mgcp behavior g729-variants static-pt
    container behavior {
      tailf:info "Set MGCP message behavior";
      container g729-variants {
        leaf static-pt {
          type empty;
        }
      }
    }

    // mgcp profile *
    list profile {
      tailf:info "MGCP profile configuration mode";
      tailf:cli-mode-name "config-mgcp-profile";
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Configure MGCP default profile";
            }
          }
          type string {
            tailf:info "Enter the name(is limited to 32 characters) "+
              "of the profile";
            length "0..32";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// gatekeeper
  /// ========================================================================

  container gatekeeper {
    tailf:info "Enter gatekeeper configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-gk";

    // gatekeeper shutdown
    leaf shutdown {
      tailf:info "Shutdown Gatekeeper";
      type empty;
    }
  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Configure a terminal line";

    // line con(sole) 0
    list console {
      tailf:info "Primary terminal line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    // line aux 0
    list aux {
      tailf:info "Auxiliary line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    // line vty *
    container vty-single {
      tailf:cli-drop-node-name;
      list vty {
        tailf:info "Virtual terminal";
        tailf:cli-full-command;
        tailf:cli-mode-name "config-line";
        key first;
        leaf first {
          type uint16 {
            tailf:info "<0-1869>;;First Line number";
            range "0..1869";
          }
        }
        uses line-grouping;
      }
    }

    // line vty * *
    list vty {
      tailf:info "Virtual terminal";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key "first last";
      leaf first {
        type uint16 {
          tailf:info "<0-1869>;;First Line number";
          range "0..1869";
        }
      }
      leaf last {
        type uint16 {
          tailf:info "<1-1869>;;Last Line number";
          range "1..1869";
        }
      }
      uses line-grouping;
    }

    // line *
    list number-single {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      leaf first {
        tailf:cli-suppress-range;
        tailf:cli-disallow-value "con|console|aux|vty";
        type string {
          tailf:info "Line number";
        }
      }
      uses line-grouping;
    }

    // line * *
    list number {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key "first last";
      leaf first {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<0-X>;;First Line number";
        }
      }
      leaf last {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-Y>;;Last Line number";
        }
      }
      uses line-grouping;
    }

  }


  /// ========================================================================
  /// pnp
  /// ========================================================================

  container pnp {
    tailf:info "Configure PNP";

    // pnp profile *
    list profile {
      tailf:info "PNP profile";
      tailf:cli-mode-name "config-pnp-init";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;PNP Profile name";
        }
      }

      // pnp profile * / transport
      container transport {
        tailf:info "The transport to use";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        leaf protocol {
          tailf:cli-drop-node-name;
          type enumeration {
            enum http {
              tailf:info "Use http (plaintext) transport";
            }
            enum https {
              tailf:info "Use https (encrypted) transport";
            }
            enum xmpp {
              tailf:info "Use XMPP transport";
            }
          }
        }

        leaf over {
          tailf:cli-drop-node-name;
          when "../protocol = 'xmpp'" {
            tailf:dependency "../protocol";
          }
          type enumeration {
            enum socket {
              tailf:info "xmpp over plain socket (no encryption)";
            }
            enum starttls {
              tailf:info "xmpp starttls";
            }
            enum tls {
              tailf:info "xmpp over tls (encrypted)";
            }
          }
        }

        choice address-choice {
          leaf host {
            tailf:info "hostname of server";
            type inet:host {
              tailf:info "WORD;;Hostname of the server";
            }
          }
          leaf ipv4 {
            tailf:info "ipv4 address";
            type inet:ipv4-address {
              tailf:info "WORD;;IP address of the server";
            }
          }
          leaf ipv6 {
            tailf:info "IPv6 address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address of server";
            }
          }
        }

        leaf port {
          tailf:info "port number";
          type uint16 {
            tailf:info "<1-65535>;;Port number to use";
          }
        }

        container source {
          tailf:info "Bind port to interface";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }

      // pnp profile * / reconnect
      container reconnect {
        tailf:info "Pause to wait before reconnecting";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2000000>;;Pause in seconds";
            range "1..2000000";
          }
        }
      }
    }

    // pnp startup-vlan
    leaf startup-vlan {
      tailf:info "PNP startup-vlan";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "PNP vlan id;default vlan is 1";
        range "2..4094";
      }
    }

    // pnp tag
    leaf tag {
      tailf:info "PNP tag";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;PNP tag name";
      }
    }
  }


  /// ========================================================================
  /// onep
  /// ========================================================================

  container onep {
    tailf:info "ONEP functionality";
    tailf:cli-add-mode;

    leaf start {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    container transport {
      tailf:info "Transport type";
      container tipc {
        tailf:info "tipc transport";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";

    // logging discriminator *
    list discriminator {
      tailf:info "Create or modify a message discriminator";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key discr-name;
      leaf discr-name {
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }

      // logging discriminator * mnemonics
      container mnemonics {
        tailf:info "Mnemonics pattern for messsage filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice mnemonics-choice {
          leaf drops {
            tailf:info "To drop messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
          leaf includes {
            tailf:info "To deliver messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
        }
      }

      // logging discriminator * msg-body
      container msg-body {
        tailf:info "Msg-body pattern for messsage filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice mnemonics-choice {
          leaf drops {
            tailf:info "To drop messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
          leaf includes {
            tailf:info "To deliver messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
        }
      }

    }

    // logging cmts
    container cmts {
      tailf:info "CMTS config commands";
      container ipc-cable {
        tailf:info "Cable IPC config commands";
        // logging cmts ipc-cable log-level
        leaf log-level {
          tailf:info "cable ipc log level config commands";
          type logging-level-type;
        }
      }
      container sea {
        tailf:info "SEA config commands";
        // logging cmts sea syslog-level
        leaf syslog-level {
          tailf:info "Specify syslog loggging level";
          type logging-level-type;
        }
      }
    }

    // logging alarm
    leaf alarm {
      tailf:info "Configure syslog for alarms";
      tailf:cli-full-command;
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm Logging severity level";
          range "1..4";
        }
        type enumeration {
          enum critical {
            tailf:info "Service affecting Condition       (severity=1)";
          }
          enum informational {
            tailf:info "Informational messages            (severity=4)";
          }
          enum major {
            tailf:info "Immediate action needed           (severity=2)";
          }
          enum minor {
            tailf:info "Minor warning conditions          (severity=3)";
          }
        }
      }
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf discriminator {
        tailf:info "Establish MD-Console association";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }
      leaf buffer-size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<4096-2147483647>;;Logging buffer size";
          range "4096..2147483647";
        }
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
        default debugging;
      }
    }

    // logging console
    container console {
      tailf:info "Set console logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf discriminator {
        tailf:info "Establish MD-Console association";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
        default debugging;
      }
    }

    // logging event
    container event {
      tailf:info "Global interface events";

      // logging event link-status
      container link-status {
        tailf:info "Globally enable/disable link UPDOWN message";
        leaf boot {
          tailf:info "Supress/Allow link UPDOWN messages during boot";
          type empty;
        }
        leaf global {
          type empty;
        }
        leaf "default" {
          tailf:info "Link UPDOWN messages for all interfaces";
          type empty;
        }
      }
    }

    // logging esm
    container esm {
      tailf:info "Set ESM filter restrictions";
      leaf "config" {
        tailf:info "Permit/Deny configuration changes from ESM filters";
        tailf:cli-full-command;
        type empty;
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      type enumeration {
        enum auth {
          tailf:info "Authorization system";
        }
        enum cron {
          tailf:info "Cron/at facility";
        }
        enum daemon {
          tailf:info "System daemons";
        }
        enum kern {
          tailf:info "Kernel";
        }
        enum local0 {
          tailf:info "Local use";
        }
        enum local1 {
          tailf:info "Local use";
        }
        enum local2 {
          tailf:info "Local use";
        }
        enum local3 {
          tailf:info "Local use";
        }
        enum local4 {
          tailf:info "Local use";
        }
        enum local5 {
          tailf:info "Local use";
        }
        enum local6 {
          tailf:info "Local use";
        }
        enum local7 {
          tailf:info "Local use";
        }
        enum lpr {
          tailf:info "Line printer system";
        }
        enum mail {
          tailf:info "Mail system";
        }
        enum news {
          tailf:info "USENET news";
        }
        enum sys10 {
          tailf:info "System use";
        }
        enum sys11 {
          tailf:info "System use";
        }
        enum sys12 {
          tailf:info "System use";
        }
        enum sys13 {
          tailf:info "System use";
        }
        enum sys14 {
          tailf:info "System use";
        }
        enum sys9 {
          tailf:info "System use";
        }
        enum syslog {
          tailf:info "Syslog itself";
        }
        enum user {
          tailf:info "User process";
        }
        enum uucp {
          tailf:info "Unix-to-Unix copy system";
        }
      }
    }

    // logging history
    container history {
      tailf:info "Configure syslog history table";
      leaf size {
        tailf:info "Set history table size";
        type uint16 {
          tailf:info "<0-500>;History size";
        }
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type union {
          type uint8 {
            tailf:info "<0-7>;;Logging severity level";
            range "0..7";
          }
          type enumeration {
            enum alerts {
              tailf:info "Immediate action needed           (severity=1)";
            }
            enum critical {
              tailf:info "Critical conditions               (severity=2)";
            }
            enum debugging {
              tailf:info "Debugging messages                (severity=7)";
            }
            enum emergencies {
              tailf:info "System is unusable                (severity=0)";
            }
            enum errors {
              tailf:info "Error conditions                  (severity=3)";
            }
            enum informational {
              tailf:info "Informational messages            (severity=6)";
            }
            enum notifications {
              tailf:info "Normal but significant conditions (severity=5)";
            }
            enum warnings {
              tailf:info "Warning conditions                (severity=4)";
            }
          }
        }
      }
    }

    // logging *
    list hostname {
      tailf:info "Hostname or A.B.C.D;;IP address of the logging host";
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key host;
      leaf host {
        tailf:cli-disallow-value "esm|alarm|buffered|facility"+
          "|history|rate-limit|source-interface|host|console";
        tailf:cli-full-command;
        type inet:host {
          tailf:info "Hostname or A.B.C.D";
        }
      }
    }

    // logging host *
    list host {
      tailf:info "Set syslog server IP address and parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key host;
      leaf host {
        tailf:cli-disallow-value "esm|alarm|buffered|facility"+
          "|history|rate-limit|source-interface|host";
        tailf:cli-full-command;
        type inet:host {
          tailf:info "Hostname or A.B.C.D";
        }
      }

      leaf vrf {
        tailf:info "Set VRF option";
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      leaf discriminator {
        tailf:info "Specify a message discriminator identifier for this "
          +"logging session";
        type string {
          tailf:info "WORD;;Message discriminator identifier for this logging "
            +"session (8 chars. max)";
        }
      }
    }

    // logging rate-limit
    container rate-limit {
      tailf:info "Set messages per second limit";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf console {
        tailf:info "Rate limit only console messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf all {
        tailf:info "Rate limit all messages, including debug messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf rate {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-10000>;;Messages per second";
        }
      }
    }

    // logging source-interface
    container source-interface {
      tailf:info "Specify interface for source address in logging transactions";
      tailf:cli-compact-syntax;
      uses interface-name-grouping;
      leaf vrf {
        tailf:info "Specify the vrf of source interface for logging "+
          "transactions";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }

    // logging trap
    leaf trap {
      tailf:info "Set syslog server logging level";
      tailf:cli-full-command;
      type logging-level-type;
    }
  }


  /// ========================================================================
  /// cpd
  /// ========================================================================

  container cpd {
    tailf:info "Global Control Point Discovery Configuration";
    tailf:cli-display-separated;
    presence true;

    // cpd cr-id
    leaf cr-id {
      tailf:info "Control Relationship Identifier";
      type uint16 {
        tailf:info "<1-65535>;;Control Relationship Identifier Value";
        range "1..65535";
      }
    }
  }


  /// ========================================================================
  /// nls
  /// ========================================================================

  container nls {
    tailf:info "Global Network Layer Signaling Configuration";
    tailf:cli-display-separated;
    presence true;

    // nls resp-timeout
    leaf resp-timeout {
      tailf:info "NLS Response Timeout";
      type uint8 {
        tailf:info "<1-60>;;NLS Response Timeout Value";
        range "1..60";
      }
    }
  }


  /// ========================================================================
  /// flow-sampler-map
  /// ========================================================================

  list flow-sampler-map {
    tailf:info "Flow sampler configuration";
    tailf:cli-mode-name "config-sampler";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of the flow sampler";
      }
    }

    // flow-sampler-map * / mode
    container mode {
      tailf:info "Mode of packet sampling for netflow processing";
      container random {
        tailf:info "Random mode of sampling";
        leaf one-out-of {
          tailf:info "Select one packet out of";
          type uint16 {
            tailf:info "<1-65535>;number of sequential packets to "+
              "select one packet from";
            range "1..65535";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// frame-relay
  /// ========================================================================

  container frame-relay {
    tailf:info "global frame relay configuration commands";

    // frame-relay switching
    leaf switching {
      tailf:info "enable frame relay pvc switching";
      type empty;
    }
  }


  /// ========================================================================
  /// scheduler
  /// ========================================================================

  container scheduler {
    tailf:info "Scheduler parameters";

    // scheduler allocate
    container allocate {
      tailf:info "Guarantee CPU time for processes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interrupt-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<400-60000>;;Microseconds handling network interrupts";
          range "400..60000";
        }
      }
      leaf process-time {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<100-4000>;;Microseconds running processes";
          range "100..4000";
        }
      }
    }

    // scheduler isr-watchdog
    leaf isr-watchdog {
      tailf:info "Detect ISR Hang";
      type empty;
    }

  }


  /// ========================================================================
  /// process
  /// ========================================================================

  container process {
    tailf:info "Configure process";

    // process cpu threshold type
    container cpu {
      tailf:info "Configure cpu parameters";
      container threshold {
        tailf:info "cpu threshold parameters";
        container "type" {
          tailf:info "cpu threshold type";
          tailf:cli-compact-syntax;

          // process cpu threshold type total
          container total {
            tailf:info "total cpu utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }

          // process cpu threshold type interrupt
          container interrupt {
            tailf:info "interrupt level utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }

          // process cpu threshold type process
          container process {
            tailf:info "process level utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Configure NTP";
    tailf:cli-diff-dependency "/ios:ip/vrf";
    tailf:cli-diff-dependency "/ios:vrf/definition";

    // ntp max-associations
    leaf max-associations {
      tailf:info "Set maximum number of associations";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Number of associations";
      }
    }

    // Removed aug14 because auto-changed by device. Set outside NCS scope.
    // ntp clock-period
    // leaf clock-period {
    //  tailf:info "Length of hardware clock tick";
    //  tailf:cli-full-command;
    //  type uint32 {
    //   tailf:info "<0-4294967295>;;Clock period in 2^-32 seconds";
    //  }
    // }

    // ntp passive
    leaf passive {
      tailf:info "NTP passive mode";
      tailf:cli-full-command;
      type empty;
    }

    // ntp logging
    leaf logging {
      tailf:info "Enable NTP message logging";
      tailf:cli-full-command;
      type empty;
    }

    // ntp panic
    container panic {
      tailf:info "Reject time updates > panic threshold (default 1000Sec)";
      leaf update {
        tailf:info "Reject time updates > panic threshold (default 1000Sec)";
        type empty;
      }
    }

    // ntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key number;
      leaf number {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      leaf md5 {
        tailf:info "MD5 authentication";
        type string {
          tailf:info "WORD;;Authentication key";
        }
      }
      leaf encryption-type {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Authentication key encryption type";
        }
      }
    }

    // ntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // ntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key key-number;
      leaf key-number {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      leaf "hyphen" {
        tailf:info "hyphen";
        tailf:alt-name "-";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf end-key-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;End Key range";
          range "1..65535";
        }
      }
    }

    // ntp orphan
    leaf orphan {
      tailf:info "Threshold Stratum for orphan mode";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-16>;;Orphan stratum";
        range "1..16";
      }
    }

    // ntp mindistance
    leaf mindistance {
      tailf:info "Minimum distance to consider for clockhop";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-500>;;Minimum distance to consider for clockhop";
        range "1..500";
      }
    }

    // ntp maxdistance
    leaf maxdistance {
      tailf:info "Maximum Distance for synchronization";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-16>;;Maximum distance for synchronization";
        range "1..16";
      }
    }

    // ntp broadcastdelay
    leaf broadcastdelay {
      tailf:info "Estimated round-trip delay";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-999999>;;Round-trip delay in microseconds";
        range "1..999999";
      }
    }

    // ntp source
    container source {
      tailf:info "Configure interface for source address";
      uses interface-name-grouping;
    }

    // ntp access-group
    container access-group {
      tailf:info "Control NTP access";

      // ntp access-group peer
      container peer {
        tailf:info "Provide full access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group query-only
      container query-only {
        tailf:info "Allow only control queries";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group serve
      container serve {
        tailf:info "Provide server and query access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group server-only
      container serve-only {
        tailf:info "Provide only server access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

    }

    // ntp master
    container master {
      tailf:info "Act as NTP master clock";
      tailf:cli-delete-when-empty;
      presence true;
      leaf stratum {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-15>;;Stratum number";
          range "1..15";
        }
      }
    }

    // ntp peer
    container peer {
      tailf:info "Configure NTP peer";
      uses ntp-peer-grouping;
      // ntp peer ip
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp peer ipv6
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp peer vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-peer-grouping;
      }
    }

    // ntp server *
    container server {
      tailf:info "Configure NTP server";
      uses ntp-peer-grouping;
      // ntp server ip *
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp server ipv6 *
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp server vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-peer-grouping;
      }
    }

    // ntp allow mode private
    container allow {
      tailf:info "Allow processing of packets";
      container mode {
        tailf:info "Allow processing of particular mode packets";
        leaf private {
          tailf:info "Allow processing private mode packets";
          type empty;
        }
      }
    }

    // ntp update-calender
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      type empty;
    }

  }


  /// ========================================================================
  /// sntp
  /// ========================================================================

  container sntp {
    tailf:info "Configure SNTP";
    tailf:cli-incomplete-no;

    // sntp logging
    leaf logging {
      tailf:info "Enable SNTP message logging";
      tailf:cli-full-command;
      type empty;
    }

    // sntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key number;
      leaf number {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      leaf md5 {
        tailf:info "MD5 authentication";
        type string {
          tailf:info "WORD;;Authentication key";
        }
      }
      leaf encryption-type {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Authentication key encryption type";
        }
      }
    }

    // sntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // sntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key key-number;
      leaf key-number {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      leaf "hyphen" {
        tailf:info "hyphen";
        tailf:alt-name "-";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf end-key-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;End Key range";
          range "1..65535";
        }
      }
    }

    // sntp server *
    container server {
      tailf:info "Configure SNTP server";
      uses sntp-server-grouping;
      // sntp server ip *
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses sntp-server-grouping;
      }
      // sntp server ipv6 *
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses sntp-server-grouping;
      }
      // sntp server vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses sntp-server-grouping;
      }
    }

    // sntp broadcast
    container broadcast {
      tailf:info "Configure SNTP broadcast services";
      leaf client {
        tailf:info "Enable SNTP broadcast client mode";
        type empty;
      }
    }

    // sntp multicast client
    container multicast {
      tailf:info "Configure SNTP multicast services";
      container client {
        tailf:info "Enable SNTP multicast client mode";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf address {
          tailf:cli-drop-node-name;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast client IP address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Multicast client IPv6 address";
            }
          }
        }
      }
    }

    // sntp source-interface
    container source-interface {
      tailf:info "Configure interface for source address";
      uses interface-name-grouping;
    }

  }


  /// ========================================================================
  /// ptp
  /// ========================================================================

  container ptp {
    tailf:info "Precision Time Protocol";
    container clock {
      tailf:info "Configure PTP clock";
      container ordinary {
        tailf:info "Configure PTP Ordinary clock";

        // ptp clock ordinary domain *
        list domain {
          tailf:info "PTP domain";
          tailf:cli-mode-name "config-ptp-clk";
          key id;
          max-elements 1;
          leaf id {
            type uint8 {
              tailf:info "<0-127>;;Domain number";
              range "0..127";
            }
          }
          leaf hybrid {
            tailf:info "Hybrid Mode";
            tailf:cli-hide-in-submode;
            type empty;
          }

          // ptp clock ordinary domain * / clock-port *
          list clock-port {
            tailf:info "Configure clock port";
            tailf:cli-mode-name "config-ptp-port";
            key "name mode";
            max-elements 1;
            leaf name {
              type string {
                tailf:info "WORD;;Port name";
              }
            }
            leaf mode {
              type enumeration {
                enum master {
                  tailf:info "Configure as Master";
                }
                enum slave {
                  tailf:info "Configure as Slave";
                }
              }
            }

            // ptp clock ordinary domain * / clock-port * / transport
            container transport {
              tailf:info "Set port transport parameters";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf proto {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum ethernet {
                    tailf:info "Use Ethernet encapsulation";
                  }
                  enum ipv4 {
                    tailf:info "Use IPv4 encapsulation";
                  }
                }
              }
              leaf unicast {
                tailf:info "Use unicast communication channel";
                type empty;
              }
              leaf interface {
                tailf:info "Transport interface";
                when "../proto = 'ipv4'";
                type string {
                  tailf:info "WORD;;Abbreviated interface name";
                }
              }
              leaf negotiation {
                tailf:info "Enable unicast negotiation";
                type empty;
              }
            }

            // ptp clock ordinary domain * / clock-port * / clock
            container clock {
              tailf:info "Set clock parameters";
              leaf source {
                tailf:info "Local clock address";
                type string {
                  tailf:info "WORD;;MAC/IP address";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mac-address-table
  /// ========================================================================

  container mac-address-table {
    tailf:info "Configure the MAC address table";

    // mac-address-table notification mac-move
    container "notification" {
      tailf:info "Enable a Notification feature";
      leaf mac-move {
        tailf:info "Enable Mac Move Notification";
        type empty;
      }
    }

    // mac-address-table limit
    container limit {

      // mac-address-table limit bdomain *
      list bdomain {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
          }
        }
        leaf maximum {
          type uint16 {
          }
        }
        leaf action {
          type enumeration {
            enum warning {}
            enum limit {}
            enum shutdown {}
          }
        }
        leaf flood {
          type empty;
        }
      }
    }
  }

  container no {
    // Note: dirty construction, FIXME better

    // no mac-address-table learning vlan *
    container mac-address-table {
      tailf:info "Configure the MAC address table";
      container learning {
        tailf:info "Enable a MAC table learning feature";
        list vlan {
          tailf:info "Layer 2 table learning per VLAN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID";
              range "1..4094";
            }
          }
          leaf "module" {
            tailf:info "Layer 2 table learning per VLAN per module";
            type uint8 {
              tailf:info "<1-9>;;Module";
              range "1..9";
            }
          }
        }
      }
    }

  }


  /// ========================================================================
  /// privilege
  /// ========================================================================

  container privilege {
    tailf:info "Command privilege parameters";
    // privilege exec
    container exec {
      tailf:info "Exec mode";

      // privilege exec level *
      list level {
        tailf:info "Set privilege level of command";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-no-key-completion;
        key privilege;
        leaf privilege {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<0-15>;;Privilege level";
          }
        }
        list command-list {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          tailf:cli-no-key-completion;
          tailf:cli-suppress-key-abbreviation;
          tailf:cli-no-match-completion;
          ordered-by user;
          key command;
          leaf command {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "LINE;;Initial keywords of the command to modify";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";

    // spanning-tree etherchannel
    container etherchannel {
      tailf:info "Spanning tree etherchannel specific configuration";
      container guard {
        tailf:info "Configure guard features for etherchannel";
        leaf misconfig {
          tailf:info "Enable guard to protect against etherchannel "
            +"misconfiguration";
          type empty;
        }
      }
    }

    // spanning-tree extend
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion of the bridge id ("
          +"PVST & Rapid PVST only)";
        type empty;
      }
    }

    // spanning-tree loopguard
    container loopguard {
      tailf:info "Spanning tree loopguard options";
      leaf "default" {
        tailf:info "Enable loopguard by default on all ports";
        type empty;
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Multiple spanning tree configuration";
      list instance-range {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint16 {
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }

      // spanning-tree mst configuration
      container configuration {
        tailf:info "Enter MST configuration submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mst";

        // spanning-tree mst configuration / name
        leaf name {
          tailf:info "Set configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }

        // spanning-tree mst configuration / instance
        list instance {
          tailf:info "Map vlans to an MST instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MST instance id";
              range "0..4094";
            }
          }
          leaf-list vlan {
            tailf:info "Range of vlans to add to the instance mapping";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "LINE;;vlan range ex: 1-65, 72, 300 -200";
            }
          }
        }
      }
    }

    // spanning-tree optimize
    container optimize {
      // FIXME: does not exist on box but show running-config show it. Broken
      // spanning-tree optimize bpdu
      container bpdu {
        // spanning-tree optimize bpdu transmission
        leaf transmission {
          tailf:cli-boolean-no;
          tailf:cli-show-no; //??
          type boolean;
        }
      }
    }

    // spanning-tree portfast
    container portfast {
      tailf:info "Spanning tree portfast options";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf bdpu {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum bpdufilter {
            tailf:info "Enable portfast bdpu filter on this switch";
          }
          enum bpduguard {
            tailf:info "Enable portfast bpdu guard on this switch";
          }
        }
      }
      leaf "default" {
        tailf:info "Enable portfast by default on all access ports";
        type empty;
      }
    }

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      tailf:cli-full-command;
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum pvst {
          tailf:info "Per-Vlan spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree vlans-max-age
    container vlans-max-age {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf max-age {
          tailf:info "Set the max age interval for the spanning tree";
          type uint8 {
            tailf:info "<6-40>;;maximum number of seconds the information in a "
              +"BPDU is valid";
            range "6..40";
          }
        }
      }
    }

    // spanning-tree vlans-forward-time
    container vlans-forward-time {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf forward-time {
          tailf:info "Set the forward delay for the spanning tree";
          type uint8 {
            tailf:info "<4-30>;;number of seconds for the forward delay timer";
            range "4..30";
          }
        }
      }
    }

    // spanning-tree vlans-hello-time
    container vlans-hello-time {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf hello-time {
          tailf:info "Set the hello interval for the spanning tree";
          type uint8 {
            tailf:info "<1-10>;;number of seconds between generation of config "
              +"BPDUs";
            range "1..10";
          }
        }
      }
    }

    // spanning-tree vlans-priority
    container vlans-priority {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }
    }

    // spanning-tree vlans-root
    container vlans-root {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        container root {
          tailf:info "Configure switch as root";
          container primary {
            tailf:info "Configure this switch as primary root for this "
              +"spanning tree";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf diameter {
              tailf:info "Network diameter of this spanning tree";
              type uint8 {
                tailf:info "<2-7>;;Maximum number of bridges between any two "
                  +"end nodes";
                range "2..7";
              }
            }
            leaf hello-time {
              tailf:info "Hello interval for this spanning tree";
              type uint8 {
                tailf:info "<1-10>;;Hello interval in seconds";
                range "1..10";
              }
            }
          }
          container secondary {
            tailf:info "Configure switch as secondary root";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf diameter {
              tailf:info "Network diameter of this spanning tree";
              type uint8 {
                tailf:info "<2-7>;;Maximum number of bridges between any two "
                  +"end nodes";
                range "2..7";
              }
            }
            leaf hello-time {
              tailf:info "Hello interval for this spanning tree";
              type uint8 {
                tailf:info "<1-10>;;Hello interval in seconds";
                range "1..10";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot1x
  /// ========================================================================

  container dot1x {
    tailf:info "IEEE 802.1X Global Configuration Commands";
    // dot1x critical
    container critical {
      tailf:info "Set 802.1x Critical Authentication parameters";
      leaf eapol {
        tailf:info "Send EAPOL-Success on successful Critical Authentication";
        type empty;
      }
      container recovery {
        tailf:info "Set 802.1x Critical Authentication Recovery parameters";
        leaf delay {
          tailf:info "Set 802.1x Critical Authentication Recovery Delay period";
          type uint16 {
            tailf:info "<1-10000>;;802.1x Critical Authentication Recovery "
              +"delay in milliseconds";
            range "1..10000";
          }
        }
      }
    }
    // dot1x system-auth-control
    leaf system-auth-control {
      tailf:info "Enable or Disable SysAuthControl";
      type empty;
    }
  }


  /// ========================================================================
  /// power
  /// ========================================================================

  container power {
    tailf:info "Power configure";

    // power redundancy-mode
    leaf redundancy-mode {
      tailf:info "set power supply redundancy mode";
      type enumeration {
        enum combined {
          tailf:info "combine power supply outputs (no redundancy)";
        }
        enum redundant {
          tailf:info "either power supply can operate system (redundancy)";
        }
      }
    }
  }


  /// ========================================================================
  /// parameter-map
  /// ========================================================================

  container parameter-map {
    tailf:info "parameter map";
    container "type" {
      tailf:info "parameter map type";

      // parameter-map type inspect *
      list inspect {
        tailf:info "inspect parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }

        // parameter-map type inspect * / alert
        leaf alert {
          tailf:info "Turn on/off alert";
          type enumeration {
            enum off {
              tailf:info "Turn off alert";
            }
            enum on {
              tailf:info "Turn on alert";
            }
          }
        }

        // parameter-map type inspect * / audit-trail
        leaf audit-trail {
          tailf:info "Turn on/off audit trail";
          type enumeration {
            enum off {
              tailf:info "Turn off audit trail";
            }
            enum on {
              tailf:info "Turn on audit trail";
            }
          }
        }

        // parameter-map type inspect * / dns-timeout
        leaf dns-timeout {
          tailf:info "Specify timeout for DNS";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }

        // parameter-map type inspect * / icmp
        container icmp {
          tailf:info "Config timeout values for icmp";
          leaf idle-time {
            tailf:info "Specify timeout for icmp";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
        }

        // parameter-map type inspect * / max-incomplete
        container max-incomplete {
          tailf:info "Specify maximum number of incomplete connections before "
            +"clamping";
          leaf high {
            tailf:info "Specify high-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
          leaf low {
            tailf:info "Specify low-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
        }

        // parameter-map type inspect * / one-minute
        container one-minute {
          tailf:info "Specify one-minute-sample watermarks for clamping";
          leaf high {
            tailf:info "Specify high-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
          leaf low {
            tailf:info "Specify low-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
        }

        // parameter-map type inspect * / sessions
        container sessions {
          tailf:info "Maximum number of inspect sessions";
          leaf maximum {
            tailf:info "Maximum sessions";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of sessions";
              range "1..2147483647";
            }
          }
        }

        // parameter-map type inspect * / tcp
        container tcp {
          tailf:info "Config timeout values for tcp connections";
          leaf finwait-time {
            tailf:info "Specify timeout for TCP connections after a FIN";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
          leaf idle-time {
            tailf:info "Specify idle timeout for tcp connections";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
          container max-incomplete {
            tailf:info "Specify max half-open connection per host";
            leaf host {
              tailf:info "Specify max half-open connection per host";
              type uint32 {
                tailf:info "<1-4294967295>;;half-open sessions";
                range "1..4294967295";
              }
            }
          }
          leaf synwait-time {
            tailf:info "Specify timeout for TCP connections after a SYN and no";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
        }

        // parameter-map type inspect * / udp
        container udp {
          tailf:info "Config timeout values for udp flows";
          leaf idle-time {
            tailf:info "Specify idle timeout for udp";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn
  /// ========================================================================

  container vpdn {
    tailf:info "Virtual Private Dialup Network";

    leaf authen-before-forward {
      tailf:info "Authenticate a user locally before tunnelling";
      type empty;
    }
    leaf enable {
      tailf:info "Enable VPDN";
      type empty;
    }
    leaf-list search-order {
      ordered-by user;
      tailf:info "Configure the order to search different VPDN tunnel types";
      type enumeration {
        enum dnis {
          tailf:info "Tunnel based on DNIS";
        }
        enum domain {
          tailf:info "Tunnel based on domain";
        }
        enum multihop-hostname {
          tailf:info "Tunnel based on peer hostname from ingress tunnel";
        }
      }
    }
  }


  /// ========================================================================
  /// bba-group
  /// ========================================================================

  container bba-group {
    tailf:info "Configure BBA Group";

    // bba-group pppoe *
    list pppoe {
      tailf:info "PPPoE type";
      key id;
      leaf id {
        type union {
          type string {
            tailf:info "WORD;;BBA Group name";
          }
          type enumeration {
            enum global {
              tailf:info "PPPoE global group";
            }
          }
        }
      }
      container vendor-tag {
        tailf:info "PPPoE Vendor Specific Tag";
        container circuit-id {
          tailf:info "Circuit-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        container dsl-sync-rate {
          tailf:info "DSL-Sync-Rate";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        container remote-id {
          tailf:info "Remote-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        leaf strip {
          tailf:info "Strip all vendor tags";
          type empty;
        }
      }
      leaf virtual-template {
        tailf:info "BBA virtual template command";
        type uint16 {
          tailf:info "<1-4095>;;Virtual Template interface number";
          range "1..4095";
        }
      }
    }
  }


  /// ========================================================================
  /// mac
  /// ========================================================================

  container mac {
    tailf:info "Global MAC configuration subcommands";

    container access-list {
      tailf:info "Named access-list";
      list extended {
        tailf:info "Extended Access List";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        container deny {
          tailf:info "Specify packets to reject";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          container source {
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any source MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single source host";
                type string {
                  tailf:info "H.H.H;;48-bit source MAC address";
                }
              }
            }
          }
          container dest {
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any destination MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single destination host";
                type string {
                  tailf:info "H.H.H;;48-bit destination MAC address";
                }
              }
            }
          }
        }
        container permit {
          tailf:info "Specify packets to forward";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          container source {
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any source MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single source host";
                type string {
                  tailf:info "H.H.H;;48-bit source MAC address";
                }
              }
            }
          }
          container dest {
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any destination MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single destination host";
                type string {
                  tailf:info "H.H.H;;48-bit destination MAC address";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "Modify TACACS query parameters";

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        type host-type {
          tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
        }
      }
      // tacacs-server host * port
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }
      // tacacs-server host * timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply "+
          "(overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for "+
            "server to reply";
          range "1..1000";
        }
      }
      // tacacs-server host * key
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED key will follow";
            }
            enum 7 {
              tailf:info "Specifies HIDDEN key will follow";
            }
          }
        }
        leaf "key" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNENCRYPTED (cleartext) shared key";
          }
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // tacacs-server directed-request
    container directed-request {
      tailf:info "Allow user to specify tacacs server to use with `@server'";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      presence true;
      leaf restricted {
        tailf:info "restrict queries to directed request servers only";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf no-truncate {
        tailf:info "Do not truncate the @hostname from username.";
        type empty;
      }
    }

    // tacacs-server key
    container "key" {
      tailf:info "Set TACACS+ encryption key.";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies an UNENCRYPTED key will follow";
          }
          enum 7 {
            tailf:info "Specifies HIDDEN key will follow";
          }
        }
      }
      leaf "key" {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) shared key";
        }
      }
    }
  }


  /// ========================================================================
  /// udld
  /// ========================================================================

  container udld {
    tailf:info "Configure global UDLD setting";

    // udld aggressive
    leaf aggressive {
      tailf:info "Enable UDLD protocol in aggressive mode on fiber ports "+
        "except where locally configured";
      type empty;
    }

    // udld message time
    container message {
      tailf:info "Set UDLD message parameters";
      leaf time {
        tailf:info "Set UDLD message time period";
        type uint8 {
          tailf:info "<7-90>;;Time in seconds between sending of messages "+
            "in steady state";
          range "7..90";
        }
      }
    }

  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";

    // vtp file
    leaf file {
      tailf:info "Configure IFS filesystem file where VTP configuration is "
        +"stored.";
      type string {
        tailf:info "WORD;;The ascii name of the IFS filesystem file where VTP "
          +"configuration is stored.";
      }
    }

    // vtp interface
    leaf interface {
      tailf:info "Configure interface as the preferred source for the VTP IP "
        +"updater address.";
      type string {
        tailf:info "WORD;;The name of the interface providing the VTP updater "
          +"ID for this device.";
      }
    }

    // vtp password
    leaf password {
      tailf:info "Set the password for the VTP administrative domain";
      type string {
        tailf:info "WORD;;The ascii password for the VTP administrative "
          +"domain.";
      }
    }

    // vtp pruning
    leaf pruning {
      tailf:info "Set the adminstrative domain to permit pruning";
      type empty;
    }

    // vtp version
    leaf version {
      tailf:info "Set the adminstrative domain to VTP version";
      type uint8 {
        tailf:info "<1-3>;;Set the adminstrative domain VTP version number";
        range "1..3";
      }
    }

    // vtp domain
    leaf domain {
      tailf:info "Set the name of the VTP administrative domain.";
      type string;
    }

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      type enumeration {
        enum client {
          tailf:info "Set the device to client mode.";
        }
        enum off {
          tailf:info "Set the device to off mode.";
        }
        enum server {
          tailf:info "Set the device to server mode.";
        }
        enum transparent {
          tailf:info "Set the device to transparent mode.";
        }
      }
    }

  }


  /// ========================================================================
  /// rep
  /// ========================================================================

  container rep {
    tailf:info "Resilient Ethernet Protocol characteristics";

    // rep admin
    container admin {
      tailf:info "administrative configuration";
      list vlan {
        tailf:info "VLAN";
        key name;
        leaf name {
          type uint16 {
            tailf:info "<2-4094>;;between 2 and 4094";
            range "2..4094";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// xconnect
  /// ========================================================================

  // xconnect logging
  container xconnect {
    tailf:info "Xconnect config commands";
    container logging {
      tailf:info "Configure logging flags";

      // xconnect logging pseudowire status
      container pseudowire {
        tailf:info "pseudowire status transition logging";
        leaf "status" {
          tailf:info "pseudowire status up/down logging";
          tailf:cli-full-command;
          type empty;
        }
      }

      // xconnect logging redundancy
      leaf redundancy {
        tailf:info "xconnect redundancy events";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================

  container fabric {
    tailf:info "Catalyst 6000 crossbar fabric configuration commands";

    // fabric switching-mode
    container switching-mode {
      tailf:info "Switching mode settings";
      container allow {
        tailf:info "Allow settings";
        choice allow-choice {
          leaf bus-mode {
            tailf:info "Allow switching in bus mode for modules";
            type empty;
          }
          container truncated {
            tailf:info "Truncated switching mode";
            presence true;
            leaf threshold {
              tailf:info "Number of SFM-capable modules for truncated "
                +"switching mode. Switch applies the threshold only when the "
                +"mode is disallowed. Switch ignores the threshold when the "
                +"truncated mode is allowed";
              type uint8 {
                tailf:info "<1-9>;;Threshold for truncated switching mode.";
                range "1..9";
              }
            }
          }
        }
      }
      container force {
        tailf:info "Force modules to different switching modes";
        leaf bus-mode {
          tailf:info "Switching mode of service modules will be forced to bus-"
            +"mode by powercycling it.";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// port-channel
  /// ========================================================================

  container port-channel {
    tailf:info "EtherChannel configuration";

    // port-channel load-balance
    leaf load-balance {
      tailf:info "Load Balancing method";
      type enumeration {
        enum dst-ip {
          tailf:info "Dst IP Addr";
        }
        enum dst-mac {
          tailf:info "Dst Mac Addr";
        }
        enum dst-mixed-ip-port {
          tailf:info "Dst IP Addr and TCP/UDP Port";
        }
        enum dst-port {
          tailf:info "Dst TCP/UDP Port";
        }
        enum mpls {
          tailf:info "Load Balancing for MPLS packets";
        }
        enum src-dst-ip {
          tailf:info "Src XOR Dst IP Addr";
        }
        enum src-dst-mac {
          tailf:info "Src XOR Dst Mac Addr";
        }
        enum src-dst-mixed-ip-port {
          tailf:info "Src XOR Dst IP Addr and TCP/UDP Port";
        }
        enum src-dst-port {
          tailf:info "Src XOR Dst TCP/UDP Port";
        }
        enum src-ip {
          tailf:info "Src IP Addr";
        }
        enum src-mac {
          tailf:info "Src Mac Addr";
        }
        enum src-mixed-ip-port {
          tailf:info "Src IP Addr and TCP/UDP Port";
        }
        enum src-port {
          tailf:info "Src TCP/UDP Port";
        }
      }
    }

    // port-channel load-balance-hash-algo
    leaf load-balance-hash-algo {
      tailf:info "Algorithm selection for FBLB";
      type string;
    }
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      tailf:cli-mode-name "config-vfi";
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
      // l2 vfi * point-to-point
      leaf point-to-point {
        tailf:info "Point-to-point configuration mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }
      // l2 vfi * manual
      leaf manual {
        tailf:info "Multipoint manual configuration mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // l2 vfi * / vpn id
      container vpn {
        tailf:info "VPN configuration";
        leaf id {
          tailf:info "VPN id";
          type uint32 {
            tailf:info "<1-4294967295>;;VPN id value";
            range "1..4294967295";
          }
        }
      }

      // l2 vfi * / bridge-domain
      leaf bridge-domain {
        tailf:info "Bridge Domain";
        type uint16 {
          tailf:info "<1-8000>;;Bridge Domain ID value";
          range "1..8000";
        }
      }

      // l2 vfi * / mtu
      leaf mtu {
        tailf:cli-full-command;
        type uint16 {
        }
      }

      // l2 vfi * / neighbor *
      list neighbor {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;VFI neighbor's router id";
          }
        }
        // l2 vfi * / neighbor * / <vcid>
        leaf vcid {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter VC ID value";
            range "1..4294967295";
          }
        }
        // l2 vfi * / neighbor * / encapsulation
        leaf encapsulation {
          tailf:info "Connection encapsulation type";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum mpls {
              tailf:info "Use MPLS encapsulation";
            }
            enum l2tpv3 {
              tailf:info "Use L2TPv3 encapsulation";
            }
          }
        }
        // l2 vfi * / neighbor * / pw-class
        leaf pw-class {
          tailf:info "Pseudowire-class configuration";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
        }
        // l2 vfi * / neighbor * / no-split-horizon
        leaf no-split-horizon {
          tailf:info "Disable split-horizon forwarding";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// l2protocol-tunnel
  /// ========================================================================

  container l2protocol-tunnel {
    tailf:info "Tunnel Layer2 protocols";

    // l2protocol-tunnel cos
    leaf cos {
      tailf:info "Class of Service";
      type uint8 {
        tailf:info "<0-7>;;priority value";
        range "0..7";
      }
    }

    // l2protocol-tunnel global
    container global {
      tailf:info "Global settings";
      leaf drop-threshold {
        tailf:info "L2PT packets drop threshold";
        type uint16 {
          tailf:info "<100-20000>;;Packets per second";
          range "100..20000";
        }
      }
    }
  }


  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  // l2vpn
  container l2vpn {
    tailf:info "Layer2 VPN commands";
    tailf:cli-add-mode;
    presence true;
  }

  // l2vpn vfi
  container l2vpn-vfi {
    tailf:cli-drop-node-name;
    container l2vpn {
      container vfi {
        tailf:info "Configure a Virtual Forwarding Instance (VFI)";

        // l2vpn vfi context *
        list context {
          tailf:info "Layer2 VPN Context";
          tailf:cli-mode-name "config-vfi";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Virtual Forwarding Instance (VFI) name";
            }
          }

          // l2vpn vfi context * / vpn id
          container vpn {
            tailf:info "VPN configuration";
            leaf id {
              tailf:info "VPN id";
              type uint32 {
                tailf:info "<1-4294967295>;;VPN id value";
                range "1..4294967295";
              }
            }
          }

          // l2vpn vfi context * / autodiscovery bgp signaling
          container autodiscovery {
            tailf:info "Auto Discovery mode";
            container bgp {
              tailf:info "Use BGP for neighbor discovery";
              container signaling {
                tailf:info "Signaling protocol to use";

                // l2vpn vfi context * / autodiscovery bgp signaling bgp
                container bgp {
                  tailf:info "Use BGP signaling";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-vfi-autodiscovery";

                  // l2vpn vfi context * / autodiscovery bgp signaling bgp / ve
                  container ve {
                    leaf id {
                      type uint32;
                    }
                  }

                  // l2vpn vfi context * / autodiscovery bgp signaling bgp
                  // .. / route-target
                  container route-target {
                    tailf:info "Specify Route Target VPN Extended Communities";
                    uses vrf-route-target-grouping;
                  }
                }
              }
            }
          }

          // l2vpn vfi context * / member pseudowire *
          container member {
            tailf:info "Configure the cross connect member";
            list pseudowire {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
              }
              key name;
              leaf name {
                type uint32 {
                  tailf:info "<1-231072>;;Pseudowire interface number";
                  range "1..231072";
                }
                tailf:non-strict-leafref {
                  path "/ios:interface/pseudowire/name";
                }
              }
            }
          }
        }
      }
    }
  }

  // l2vpn xconnect
  container l2vpn-xconnect {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container xconnect {
        tailf:info "Configure a cross connect";

        // l2vpn xconnect context *
        list context {
          tailf:info "Layer2 VPN Context";
          tailf:cli-mode-name "config-xconnect";
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Configure the cross connect name";
            }
          }

          // l2vpn xconnect context * / member
          container member {
            tailf:info "Configure the cross connect member";

            // l2vpn xconnect context * / member <ifname> *
            list member-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface name";
                  pattern "(GigabitEthernet.*)|(Port-channel.*)"+
                    "|(TenGigabitEthernet.*)|(Vlan.*)|(Ethernet.*)"+
                    "|(FastEthernet.*)";
                }
              }
              leaf service-instance {
                tailf:info "Ethernet Service Instance";
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4000>;;Service Instance ID";
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member "+
                    "(0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }

            // l2vpn xconnect context * / member pseudowire *
            list pseudowire {
              tailf:info "Pseudowire Interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
              }
              key name;
              leaf name {
                type uint32 {
                  tailf:info "<1-231072>;;Pseudowire interface number";
                  range "1..231072";
                }
              }
            }

            // l2vpn xconnect context * / member A.B.C.D *
            list address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vcid {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                  range "1..4294967295";
                }
              }
              leaf encapsulation {
                tailf:info "Data encapsulation method";
                type enumeration {
                  enum mpls {
                    tailf:info "Use MPLS encapsulation";
                  }
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member "+
                    "(0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }
          }

          // l2vpn xconnect context * / redundancy
          container redundancy {
            tailf:info "Xconnect redundancy information";

            // l2vpn xconnect context * / redundancy predictive
            leaf predictive {
              tailf:info "Switch over to backup member without waiting for UP status";
              type enumeration {
                enum disabled {
                  tailf:info "Disable predictive switchover capability for this xconnect";
                }
                enum enabled {
                  tailf:info "Enable predictive switchover capability for this xconnect";
                }
              }
            }

            // l2vpn xconnect context * / redundancy delay
            list delay {
              tailf:info "Xconnect redundancy delay parameters";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key group;
              leaf group {
                tailf:info "Redundancy group name";
                tailf:cli-expose-key-name;
                type string {
                  tailf:info "Redundancy group name";
                }
              }
              leaf enable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint8 {
                  tailf:info "<0-180>;;Enable delay";
                  range "0..180";
                }
              }
              leaf disable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type union {
                  type uint8 {
                    tailf:info "<0-180>;;Disable delay";
                    range "0..180";
                  }
                  type enumeration {
                    enum never {
                      tailf:info "Disallow disable";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// system
  /// ========================================================================

  container system {
    tailf:info "Set the system configuration";

    // system env
    container env {
      tailf:info "Set the system environment settings";
      container temperature {
        tailf:info "Set the system temperature settings";
        container threshold {
          tailf:info "Set the system temperature thresholds";
          leaf yellow {
            tailf:info "Set the yellow threshold";
            type uint8 {
              tailf:info "<0-25>;;Delta value from Red threshold in Degree "
                +"Celsius";
              range "0..25";
            }
          }
        }
      }
    }

    // system mtu
    container mtu {
      tailf:info "Set the system Maximum Transmission Unit (MTU)";
      leaf size {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1500-1998>;;MTU size in bytes";
          range "1500..1998";

        }
      }
      leaf jumbo {
        tailf:info "Set Jumbo MTU value for GigabitEthernet or "
          +"TenGigabitEthernet interfaces";
        type uint16 {
          tailf:info "<1500-9000>;;Jumbo MTU size in bytes";
          range "1500..9000";
        }
      }
      leaf routing {
        tailf:info "Set the Routing MTU for the system";
        type uint16 {
          tailf:info "<1500-1500>;;MTU size in bytes";
          range "1500";
        }
      }
    }
  }


  /// ========================================================================
  /// diagnostic
  /// ========================================================================

  container diagnostic {
    tailf:info "Configure diagnostic information";

    // diagnostic bootup level
    container bootup {
      tailf:info "Configure diagnostic for bootup";
      leaf level {
        tailf:info "Select diagnostic level";
        type enumeration {
          enum complete {
            tailf:info "Complete level";
          }
          enum minimal {
            tailf:info "Minimal level";
          }
        }
      }
    }

    // diagnostic cns
    container cns {
      tailf:info "Configure diagnostic cns information";
      leaf publish {
        tailf:info "Configure diagnostic cns publish";
        type string {
          tailf:info "WORD;;Diagnostic cns subject";
        }
      }
      leaf subscribe {
        tailf:info "Configure diagnostic cns subscribe";
        type string {
          tailf:info "WORD;;Diagnostic cns subject";
        }
      }
    }
  }


  /// ========================================================================
  /// errdisable
  /// ========================================================================

  container errdisable {
    tailf:info "Error disable";

    // errdisable detect
    container detect {
      tailf:info "Error disable detection";
      container cause {
        tailf:info "Enable error disable detection for application";
        leaf all {
          tailf:info "Enable error detection on all cases";
          tailf:cli-full-command;
          type empty;
        }
        leaf arp-inspection {
          tailf:info "Enable error detection for arp inspection";
          tailf:cli-full-command;
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable error detection on bpdu-guard";
          tailf:cli-full-command;
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable error detection on dhcp-rate-limit";
          tailf:cli-full-command;
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable error detection on dtp-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable error detection on gbic-invalid";
          tailf:cli-full-command;
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable error detection for inline-power";
          tailf:cli-full-command;
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error "+
            "disable state";
          tailf:cli-full-command;
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable error detection on linkstate-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf loopback {
          tailf:info "Enable error detection on loopback";
          tailf:cli-full-command;
          type empty;
        }
        leaf mlacp-minlink {
          tailf:cli-full-command;
          type empty;
        }
        leaf pagp-flap {
          tailf:info "Enable error detection on pagp-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable error detection on PPPoE IA rate-limit";
          tailf:cli-full-command;
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable error detection on 802.1x-guard";
          tailf:cli-full-command;
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable error detection on SFP config mismatch";
          tailf:cli-full-command;
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable error detection on small_frame";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // errdisable flap-setting
    container flap-setting {
      tailf:info "Error disable flap detection setting";
      container cause {
        tailf:info "Set error disable flap parameters for application";
        container dtp-flap {
          tailf:info "Set the variables related to detection of dtp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
        container link-flap {
          tailf:info "Set the variables related to detection of link flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
        container pagp-flap {
          tailf:info "Set the variables related to detection of pagp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
      }
    }

    // errdisable recovery
    container recovery {
      tailf:info "Error disable recovery";
      // errdisable recovery cause
      container cause {
        tailf:info "Enable error disable recovery for application";
        leaf all {
          tailf:info "Enable timer to recover from all error causes";
          type empty;
        }
        leaf arp-inspection {
          tailf:info "Enable timer to recover from arp inspection error "
            +"disable state";
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable timer to recover from BPDU Guard error";
          type empty;
        }
        leaf channel-misconfig {
          tailf:info "(STP)  Enable timer to recover from channel misconfig "
            +"error";
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable timer to recover from dhcp-rate-limit error";
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable timer to recover from dtp-flap error";
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable timer to recover from invalid GBIC error";
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable timer to recover from inline-power error";
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error "
            +"disable state";
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable timer to recover from link-flap error";
          type empty;
        }
        leaf link-monitor-failure {
          type empty;
        }
        leaf loopback {
          tailf:info "Enable timer to recover from loopback error";
          type empty;
        }
        leaf mac-limit {
          tailf:info "Enable timer to recover from mac limit disable state";
          type empty;
        }
        leaf mlacp-minlink {
          tailf:cli-full-command;
          type empty;
        }
        container oam-remote-failure {
          tailf:cli-display-separated;
          presence true;
          leaf critical-event {
            tailf:cli-full-command;
            type empty;
          }
          leaf dying-gasp {
            tailf:cli-full-command;
            type empty;
          }
          leaf link-fault {
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf pagp-flap {
          tailf:info "Enable timer to recover from pagp-flap error";
          type empty;
        }
        leaf port-mode-failure {
          tailf:info "Enable timer to recover from port mode change failure";
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable timer to recover from PPPoE IA rate-limit error";
          type empty;
        }
        leaf psp {
          type empty;
        }
        leaf psecure-violation {
          tailf:info "Enable timer to recover from psecure violation error";
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable timer to recover from 802.1x violation error";
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable timer to recover from SFP config mismatch error";
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable timer to recover from small frame error";
          type empty;
        }
        leaf storm-control {
          tailf:info "Enable timer to recover from storm-control error";
          type empty;
        }
        leaf udld {
          tailf:info "Enable timer to recover from udld error";
          type empty;
        }
        leaf unicast-flood {
          //fixme tailf:info
          type empty;
        }
        leaf vmps {
          tailf:info "Enable timer to recover from vmps shutdown error";
          type empty;
        }
      }
      leaf interval {
        tailf:info "Error disable recovery timer value";
        type uint32 {
          tailf:info "<30-86400>;;timer-interval(sec)";
          range "30..86400";
        }
      }
    }
  }


  /// ========================================================================
  /// monitor
  /// ========================================================================

  container monitor {
    tailf:info "Monitoring different system events";

    // monitor session *
    list session {
      tailf:info "Configure a SPAN session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-66>;;SPAN session number";
          range "1..66";
        }
      }
      // monitor session * destination
      container destination {
        tailf:info "SPAN destination interface or VLAN";
        leaf interface {
          tailf:info "SPAN destination interface";
          type string;
        }
        // monitor session * destination encapsulation
        leaf encapsulation {
          tailf:cli-hide-in-submode;
          tailf:info "Set encapsulation for destination interface";
          type enumeration {
            enum dot1q {
              tailf:info "interface uses only dot1q encapsulation";
            }
            enum isl {
              tailf:info "interface uses only isl encapsulation";
            }
            enum replicate {
              tailf:info "interface replicates source encapsulation";
            }
          }
        }

        leaf ingress {
          tailf:info "Enable ingress traffic forwarding";
          tailf:cli-hide-in-submode;
          type empty;
        }

        leaf ingress-encap {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          when "../ingress" {
            tailf:dependency "../ingress";
          }
          type enumeration {
            enum dot1q {
              tailf:info "ingress forwarding using dot1q encapsulation";
            }
            enum isl {
              tailf:info "ingress forwarding using isl encapsulation";
            }
            enum untagged {
              tailf:info "ingress forwarding using untagged encapsulation";
            }
          }
        }

        leaf vlan {
          tailf:info "Set default VLAN for untagged ingress traffic";
          tailf:cli-hide-in-submode;
          when "../ingress" {
            tailf:dependency "../ingress";
          }
          type uint16 {
            tailf:info "<1-4094>;;Default VLAN for untagged ingress traffic";
            range "1..4094";
          }
        }
      }

      // monitor session * source
      container source {
        tailf:info "SPAN source interface, VLAN ";
        container interface {
          tailf:info "SPAN source interface";
          uses interface-name-grouping;
        }
        container vlan {
          tailf:info "SPAN source VLAN";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf vlan {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4094>;;SPAN source VLAN";
              range "1..4094";
            }
          }
          // ,     Specify another range of VLANs
          // -     Specify a range of VLANs
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum both {
                tailf:info "Monitor received and transmitted traffic";
              }
              enum rx {
                tailf:info "Monitor received traffic only";
              }
              enum tx {
                tailf:info "Monitor transmitted traffic only";
              }
            }
          }
        }
      }
    }

    // monitor event-trace *
    container event-trace {
      tailf:info "Tracing of system events";
      list event-trace-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;event trace entry";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// tftp-server
  /// ========================================================================

  list tftp-server {
    tailf:info "Provide TFTP service for netload requests";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "Allow URL file TFTP load requests";
      }
    }
    leaf alias {
      tailf:info "file alias";
      type string {
        tailf:info "WORD;;file alias";
      }
    }
    leaf access-list {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "alias";
      type std-ip-acl-type;
    }
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "Modify RADIUS query parameters";

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type string {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }

      // radius-server host * acct-port
      leaf acct-port {
        tailf:info "UDP port for RADIUS accounting server (default is 1646)";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
          range "0..65535";
        }
      }

      // radius-server host * auth-port
      leaf auth-port {
        tailf:info "UDP port for RADIUS authentication server (default is "
          +"1645)";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
          range "0..65535";
        }
      }

      // radius-server host * key
      leaf "key" {
        tailf:info "per-server encryption key (overrides default)";
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) server key";
        }
      }
    }

    // radius-server retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server";
      type uint8 {
        tailf:info "<0-100>;;Number of retries for a transaction "+
          "(default is 3)";
        range "0..100";
      }
      default 3;
    }

    // radius-server timeout
    leaf timeout {
      tailf:info "Time to wait for a RADIUS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // radius-server key
    container "key" {
      tailf:info "encryption key shared with the RADIUS servers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses password-07-grouping;
    }
  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS server configuration command";

    // radius filter *
    list filter {
      tailf:info "Packet filter configuration";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the filter (max 31 characters, longer will "
            +"be rejected";
        }
      }
      leaf match {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Filter if all of the attributes matches";
          }
          enum match-any {
            tailf:info "Filter if any of the attributes matches";
          }
        }
      }
    }

    // radius server *
    list server {
      tailf:info "Server configuration";
      key "id";
      leaf id {
        type string {
          tailf:info "WORD;;Name for the radius server configuration";
        }
      }
      container address {
        tailf:info "Specify the radius server address";
        container ipv4 {
          tailf:info "IPv4 Address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf host {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "Hostname or A.B.C.D;;IPv4 Address of radius server";
            }
          }
          // alias      1-8 aliases for this server (max. 8)
          leaf auth-port {
            tailf:info "UDP port for RADIUS authentication server (default is "
              +"1645)";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
          leaf acct-port {
            tailf:info "UDP port for RADIUS accounting server (default is "
              +"1646)";
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
        }
      }
      container backoff {
        tailf:info "Retry backoff pattern(Default is retransmits with constant "
          +"delay)";
        container exponential {
          tailf:info "Exponential retransmit backoff";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          leaf max-delay {
            tailf:cli-optional-in-sequence;
            tailf:info "Max delay between retransmits(default is 3 min)";
            type uint8 {
              tailf:info "<1-120>;;Max time (in minutes) to delay between "
                +"retransmits";
              range "1..120";
            }
          }
          leaf backoff-retry {
            tailf:info "Exponential backoff retry number(default is 8)";
            type uint8 {
              tailf:info "<1-50>;;Number of retransmits in the exponential "
                +"backoff mode";
              range "1..50";
            }
          }
        }
      }
      container "key" {
        tailf:info "Per-server encryption key";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "encryption" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED key will follow";
            }
            enum "5" {
              tailf:info "Specifies a HIDDEN key will follow";
            }
          }
        }
        leaf key {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNCRYPTED (cleartext) shared key";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// zone
  /// ========================================================================

  container zone {
    tailf:info "FW with zoning";

    // zone security *
    list security {
      tailf:info "Security zone";
      tailf:cli-mode-name "config-sec-zone";
      tailf:cli-full-command;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of security zone";
        }
      }
      leaf "description" {
        tailf:info "Zone description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
        }
      }
    }
  }


  /// ========================================================================
  /// zone-pair
  /// ========================================================================

  container zone-pair {
    tailf:info "Zone pair command";

    // zone-pair security *
    list security {
      tailf:info "Zone-pair name";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-mode-name "config-sec-zone-pair";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of zone-pair";
        }
      }
      leaf source {
        tailf:info "Source zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of source zone";
        }
      }
      leaf destination {
        tailf:info "Destination zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of destination zone";
        }
      }
      leaf "description" {
        tailf:info "Zone description";
        tailf:cli-break-sequence-commands;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
          length "1..200";
        }
      }
      container service-policy {
        tailf:info "Configure CBAC Service Policy";
        container "type" {
          tailf:info "Service Policy type";
          leaf inspect {
            tailf:info "Configure CBAC Service Policy type inspect";
            type string;
            tailf:non-strict-leafref {
              path "/ios:policy-map/name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// alarm-contact
  /// ========================================================================

  list alarm-contact {
    tailf:info "Configure the system alarm contact settings";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm contact number";
          range "1..4";
        }
        type enumeration {
          enum all {
            tailf:info "Configure all alarm contacts";
          }
        }
      }
    }

    // alarm-contact * description
    leaf "description" {
      tailf:cli-multi-value;
      type string {
        length "1..80";
      }
    }

    // alarm-contact * severity
    leaf severity {
      tailf:info "Set the severity level reported";
      type enumeration {
        enum critical {
          tailf:info "Critical alarm severity";
        }
        enum major {
          tailf:info "Major alarm severity";
        }
        enum minor {
          tailf:info "Minor alarm severity";
        }
      }
    }

    // alarm-contact * trigger
    leaf trigger {
      tailf:info "Set the alarm trigger";
      type enumeration {
        enum closed {
          tailf:info "Assert alarm when contact is closed";
        }
        enum open {
          tailf:info "Assert alarm when contact is open";
        }
      }
    }
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";

    // mpls atm
    container atm {
      tailf:info "Configure ATM options";
      leaf disable-headend-vc {
        tailf:info "Dedicated lsc capability: In this mode "
          +"headend Tag VCs are disabled.";
        type empty;
      }
    }

    // mpls cos-map
    leaf cos-map {
      tailf:info "Configure MPLS CoS ATM Multi-VC CoS Map";
      tailf:cli-full-command;
      type uint8 {
        range "1..255" {
          tailf:info "<1-255>;;cos-map number";
        }
      }
    }

    // no mpls ip
    container conf {
      tailf:cli-drop-node-name;
      leaf ip {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // mpls ip
    container ip {
      tailf:info "Dynamic MPLS forwarding for IP";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;

      // mpls ip default-route
      leaf default-route {
        tailf:info "Allow MPLS forwarding for ip default route";
        tailf:cli-full-command;
        type empty;
      }

      choice propagate-ttl-choice {
        // no mpls ip propagate-ttl
        container propagate-ttl-conf {
          tailf:cli-drop-node-name;
          leaf propagate-ttl {
            tailf:info "Propagate IP TTL into the label stack";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
        // no mpls ip propagate-ttl forwarded
        container propagate-ttl {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf forwarded {
            tailf:info "Propagate IP TTL for forwarded traffic";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // mpls ip ttl-exp
      container ttl-expiration {
        tailf:info "Control MPLS TTL expiration behavior";
        leaf pop {
          tailf:info "Popping labels on TTL expiration";
          type uint8 {
            tailf:info "<1-6>;;Popping all labels if original "
              +"packet has less than N labels";
            range "1..6";
          }
        }
      }
    }

    // mpls label
    container label {
      tailf:info "Label properties";

      // mpls label atm
      container atm {
        tailf:info "Configure ATM options";
        leaf disable-headend-vc {
          tailf:info "Dedicated lsc capability: In this mode "
            +"headend Tag VCs are disabled.";
          type empty;
        }
      }

      // mpls label protocol
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        tailf:cli-full-command;
        type enumeration {
          enum ldp {
            tailf:code-name "label_ldp";
            tailf:info "Use LDP (default)";
          }
          enum tdp: {
            tailf:code-name "label_tdp";
            tailf:info "Use TDP";
          }
        }
      }

      // mpls label range
      container "range" {
        tailf:info "Label range";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16-1048575>;;Minimum label value";
            range "16..1048575";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-1048575>;;Maximum label value";
            range "16..1048575";
          }
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";

      // no mpls ldp advertise-labels
      leaf advertise-labels {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // mpls ldp advertise-labels
      container advertise-labels-conf {
        tailf:cli-drop-node-name;
        container advertise-labels {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:info "Label advertisements";

          // mpls ldp advertise-labels for
          container "for" {
            tailf:info "Access-list specifying controls on "
              +"destination prefixes";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf from {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;IP access-list for destination"+
                  " prefixes; name or number (1-99)";
              }
            }
            leaf to {
              tailf:info "Access-list specifying controls on LDP peers";
              type string {
                tailf:info "WORD;;IP access-list for LDP peers;"
                  +" name or number (1-99)";
              }
            }
          }

          // mpls ldp advertise-labels interface
          container interface {
            tailf:info "Advertise /32 interface address";
            uses interface-name-grouping;
          }

          // mpls ldp advertise-labels oldstyle
          leaf oldstyle {
            tailf:info "Use old style (TDP) method for matching prefix acl";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // mpls ldp atm
      container atm {
        tailf:info "Configure ATM MPLS options";

        // mpls ldp atm control-mode
        leaf control-mode {
          tailf:info "Select LSP setup control mode for MPLS VCs";
          tailf:cli-full-command;
          type enumeration {
            enum independent {
              tailf:info "Independent Downstream on Demand Label VC setup";
            }
            enum ordered {
              tailf:info "Ordered Dowstream on Demand Label VC setup";
            }
          }
          //default "ordered";
        }

        // no mpls ldp atm vc-merge
        leaf vc-merge {
          tailf:info "Select VC merge capability";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // mpls ldp backoff
      container backoff {
        tailf:info "Set LDP session backoff parameters";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf initial {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<5-2147483>;;Initial session backoff time (seconds)";
            range "5..2147483";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<5-2147483>;;Maximum session backoff time (seconds)";
            range "5..2147483";
          }
        }
      }

      // mpls ldp discovery
      container discovery {
        tailf:info "LDP discovery";
        container hello {
          tailf:info "LDP discovery Hello";
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in seconds";
              range "1..65535";
            }
          }
        }
        container targeted-hello {
          tailf:info "LDP discovery Targeted Hello";
          container accept {
            tailf:info "Accept targeted hellos";
            presence "Accept targeted hellos";
            leaf from {
              tailf:info "Access list to specify acceptable "
                +"targeted hello sources";
              type string {
                tailf:info "WORD;;IP access-list for "
                  +"acceptable targeted hello sources";
              }
            }
          }
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in seconds";
              range "1..65535";
            }
          }
        }
      }

      // mpls ldp explicit-null
      container explicit-null {
        tailf:info "Advertise Explicit Null label in place of Implicit Null";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "for" {
          tailf:info "Access-list specifying controls on destination prefixes";
          type string {
            tailf:info "WORD;;IP access-list for destination "
              +"prefixes; name or number (1-99)";
          }
        }
        leaf "to" {
          tailf:info "Access-list specifying controls on LDP peers";
          type string {
            tailf:info "WORD;;IP access-list for LDP "
              +"peers; name or number (1-99)";
          }
        }
      }

      // mpls ldp loop-detection
      leaf loop-detection {
        tailf:info "Enable LDP Loop Detection";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp graceful-restart
      container graceful-restart {
        tailf:info "Configure Graceful Restart timers";
        presence "Configure Graceful Restart timers";
        container timers {
          tailf:info "Configure Graceful Restart timers";
          leaf forwarding-holding {
            tailf:info "Forwarding State Holding time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<30-600>;;seconds";
              range "30..600";
            }
          }
          leaf max-recovery {
            tailf:info "Max-Recovery time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-600>;;seconds";
              range "15..600";
            }
          }
          leaf neighbor-liveness {
            tailf:info "Neighbor-Liveness time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-300>;;seconds";
              range "5..600";
            }
          }
        }
      }

      // mpls ldp holdtime
      leaf holdtime {
        tailf:info "LDP session holdtime";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<15-2147483>;;Holdtime in seconds";
          range "15..2147483";
        }
      }

      // mpls ldp logging
      container logging {
        tailf:info "Enable LDP logging";
        leaf neighbor-changes {
          tailf:info "Log LDP neighbor state changes";
          type empty;
        }
      }

      // mpls ldp maxhops
      leaf maxhops {
        tailf:info "Limit hop count for LDP LSP setup";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;Maximum hop count value";
        }
      }

      // mpls ldp neighbor *
      list neighbor {
        tailf:info "Configure neighbor parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address for LDP neighbor";
          }
        }
        leaf implicit-withdraw {
          tailf:info "Enable LDP Implicit Withdraw Label";
          tailf:cli-full-command;
          type empty;
        }
        container lables {
          tailf:info "Configure label binding exchange controls";

          leaf accept {
            tailf:info "Specify label bindings to accept";
            type string {
              tailf:info "WORD;;IP access-list for LDP "
                +"peers; name or number (1-99)";
            }
          }
        }
        container password {
          // FIXME: better text pattern and reset siblings
          // also when configuration the text
          tailf:info "Set a password";
          tailf:cli-compact-syntax;
          leaf enctype {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-reset-container;
            type uint8 {
              tailf:info "<0-7>;;Encryption type (0 to disable "
                +"encryption, 7 for proprietary)";
              range "0..7";
            }
            default "0";
          }
          leaf text {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-reset-container;
            type string {
              pattern '[a-zA-Z].*';
              tailf:info "LINE;;The password";
            }
          }
        }
        container targeted {
          tailf:info "Establish targeted session";
          presence "Establish targeted session";
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ldp {
                tailf:code-name "target_ldp";
                tailf:info "User LDP";
              }
              enum tdp {
                tailf:code-name "target_tdp";
                tailf:info "Use TDP";
              }
            }
          }
        }
      }

      // mpls ldp request-labels
      container request-labels {
        tailf:info "Access list to specify valid downstream "
          +"on demand destinations.";
        leaf "for" {
          tailf:info "Access list to specify acceptable "
            +"downstream on demand destinations";
          type string {
            tailf:info "WORD;;IP access-list for destination "
              +"prefixes; name or number (1-99)";
          }
        }
      }

      // mpls ldp router-id
      container router-id {
        tailf:info "Select interface to prefer for LDP "
          +"identifier address";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf interface {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;intrace name";
          }
        }
        leaf force {
          tailf:info "Forcibly change the LDP router id";
          type empty;
        }
      }

      // mpls ldp session protection
      container session {
        tailf:info "Configure session parameters";
        container protection {
          tailf:info "Configure session protection parameters";
          tailf:cli-compact-syntax;
          presence true;
          // mpls ldp session protection duration
          leaf duration {
            tailf:info "Period to sustain session protection after loss of "+
              "link discovery";
            type union {
              type enumeration {
                enum "infinite" {
                  tailf:info "Protect session forever after loss of "+
                    "link discovery";
                }
              }
              type uint32 {
                tailf:info "<30-2147483>;;Holdup time in seconds";
                range "30..2147483";
              }
            }
          }
        }
      }

      // mpls ldp label
      container label {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-lbl";
        container allocate {
          tailf:info "Allocate local labels for specified destination "+
            "prefixes";
          container global {
            tailf:info "Specify global Routing/Forwarding instance";
            tailf:cli-delete-when-empty;
            presence true;
            choice global-choice {
              leaf host-routes {
                tailf:info "allocate local label for host routes only";
                type empty;
              }
              leaf prefix-list {
                tailf:info "Specify a prefix list for local label filtering";
                type string {
                  tailf:info "WORD;;IP prefix-list for destination prefixes; "+
                    "name or number (1-99)";
                }
              }
            }
          }
        }
      }
    }

    // mpls prefix-map
    container prefix-map {
      tailf:info "Configure MPLS CoS Tag-VC Multi-VC Prefix Map";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf nr {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;prefix-map number";
          range "1..255";
        }
      }
      leaf access-list {
        tailf:info "Configure access-list for this prefix-map";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;access-list number";
          range "1..255";
        }
      }
      leaf cos-map {
        tailf:info "Configure cos-map for this prefix-map";
        type uint8 {
          tailf:info "<1-255>;;cos-map number";
          range "1..255";
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Configure Traffic Engineering parameters";
      container auto-bw {
        tailf:info "auto-bw parameters";
        container timers {
          tailf:info "Enable auto-bw Timers Collection and "
            +"Application";
          presence "Enable auto-bw Timers Collection and Application";
          leaf frequency {
            tailf:info "Interval between auto-bw data collection";
            type uint32 {
              tailf:info "<1-604800>;;seconds between auto-bw";
              range "1..604800";
            }
          }
        }
      }
      container link-management {
        tailf:info "Link Management configuration";
        container timers {
          tailf:info "Link Management timers configuration";
          leaf bandwidth-hold {
            tailf:info "Link Management bandwidth hold timer";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-300>;;seconds";
              range "1..300";
            }
          }
          leaf periodic-flooding {
            tailf:info "Link Management periodic flooding interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-3600>;;seconds";
              range "0..3600";
            }
          }
        }
      }
      container logging {
        tailf:info "Trap logging configuration";
        container lsp {
          tailf:info "LSP-specific traps logging configuration";
          container path-errors {
            tailf:info "Log LSP Path Error traps";
            presence "Log LSP Path Error traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container preemption {
            tailf:info "Log LSP Preemption traps";
            presence "Log LSP Preemption traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container reservation-errors {
            tailf:info "Log LSP Reservation Error traps";
            presence "Log LSP Reservation Error traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container setups {
            tailf:info "Log LSP Establishment Traps";
            presence "Log LSP Establishment Traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container teardowns {
            tailf:info "Log LSP Teardown Traps";
            presence "Log LSP Teardown Traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
        }
        container tunnel {
          tailf:info "Tunnel-specific traps logging configuration";
          container lsp-selection {
            tailf:info "Log Tunnel LSP Selection traps";
            presence "Log Tunnel LSP Selection traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container "path" {
            tailf:info "Log Tunnel Path-related traps";
            container change {
              tailf:info "Log Tunnel Path change traps";
              presence "Log Tunnel Path change traps";
              leaf access-list {
                tailf:cli-drop-node-name;
                type exp-ip-acl-type;
              }
            }
          }
        }
      }
      container path-selection {
        tailf:info "Path Selection Configuration";
        leaf metric {
          tailf:info "Metric Type Configuration";
          tailf:cli-full-command;
          type enumeration {
            enum igp {
              tailf:info "Use IGP metric";
            }
            enum te {
              tailf:info "User TE metric";
            }
          }
        }
        container overload {
          tailf:info "Overload Node Configuration";
          container allow {
            tailf:info "Allow overloaded nodes in CSPFs";
            tailf:cli-sequence-commands;
            leaf head {
              tailf:info "Allow overloaded head node in TE CSPF";
              tailf:cli-optional-in-sequence;
              tailf:cli-reset-container;
              type empty;
            }
            leaf middle {
              tailf:info "Allow overloaded middle node in TE "
                +"CSPF";
              tailf:cli-optional-in-sequence;
              tailf:cli-reset-container;
              type empty;
            }
            leaf tail {
              tailf:info "Allow overloaded middle node in TE "
                +"CSPF";
              tailf:cli-optional-in-sequence;
              tailf:cli-reset-container;
              type empty;
            }
          }
        }
      }
      container reoptimize {
        tailf:info "Reoptimization parameters";
        container events {
          tailf:info "Reoptimization triggers";
          leaf link-up {
            tailf:info "Reoptimize tunnels on link up events";
            type empty;
          }
        }
        container timers {
          tailf:info "Reoptimization timers";
          container delay {
            tailf:info "Delay reoptimization action";
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-60>;;seconds to delay "
                  +"cleanup of replaced tunnel LSP";
                range "0..60";
              }
            }
            leaf installation {
              tailf:info "Delay replacement of current LSP "
                +"by reoptimized LSP";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-3600>;;seconds to delay "
                  +"replacement of tunnel LSP";
                range "0..3600";
              }
            }
          }
          leaf frequency {
            tailf:info "Interval between reoptimization scans";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;seconds between "
                +"reoptimizations (0 disables reoptimization)";
              range "0..604800";
            }
          }
        }
      }
      container signalling {
        tailf:info "Traffic Engineering Signalling Parameters";
        container advertise {
          tailf:info "Signalling advertisement parameters";
          container implicit-null {
            tailf:info "Use MPLS encoding for Implicit-Null "
              +"Label in signalling messages";
            presence  "Use MPLS encoding for Implicit-Null "
              +"Label in signalling messages";
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-99>;;Number of IP access-list "
                  +"to determine applicable signalling peers";
                range "1..99";
              }
            }
          }
        }
        container forwarding {
          tailf:info "Control interaction of LSP signalling and "
            +"LFIB maintenance";
          leaf sync {
            tailf:info "Program linecard LFIBs before signalling "
              +"LSP label upstream";
            type empty;
          }
        }
        container restart {
          tailf:info "Signalling restart parameters";
          container neighbors {
            tailf:info "Identify signalling restart capable "
              +"neighbors";
            presence "Identify signalling restart capable "
              +"neighbors";
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-99>;;Number of IP access-list "
                  +"to determine applicable signalling peers";
                range "1..99";
              }
            }
          }
        }
      }
      container topology {
        tailf:info "Topology Database Configuration";
        container holddown {
          tailf:info "Topology Database hold down timers";

          leaf sigerr {
            tailf:info "Link hold down time for signalling errors";
            type uint16 {
              tailf:info "<0-300>;;Hold down time in seconds";
              range "0..300";
            }
          }
        }
      }
      leaf tunnels {
        tailf:info "Traffic Engineering tunnels";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// l3vpn
  /// ========================================================================

  container l3vpn {
    tailf:info "l3vpn encapsulation ip commands";
    container encapsulation {
      tailf:info "l3vpn encapsulation ip";

      // l3vpn encapsulation ip *
      list ip {
        tailf:info "l3vpn encapsulation ip";
        tailf:cli-mode-name "config-l3vpn-encap-ip";
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;profile name";
          }
        }

        // l3vpn encapsulation ip * / transport ipv4
        container transport {
          tailf:info "transport mode";
          container ipv4 {
            tailf:info "transport ipv4 mode";
            presence true;
            // l3vpn encapsulation ip * / transport ipv4 source
            container source {
              tailf:info "transport source";
              tailf:cli-diff-dependency "/ios:interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";
    //when "not(../../ip/routing) or (../../ip/routing = 'true')" {
    //tailf:dependency "../../ip/routing";
    //}

    // router mobile
    container mobile {
      tailf:info "Mobile routes";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      presence true;
    }

    /// router bgp
    // router bgp *
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key as-no;
      max-elements 1;
      leaf as-no {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Autonomous system number";
          range "1..65535";
        }
      }

      uses router-bgp-af-grouping;
      uses router-bgp-grouping;

      // router bgp * / template
      container template {
        tailf:info "Enter template command mode";

        // router bgp * / template peer-policy *
        list peer-policy {
          tailf:info "Template configuration for policy parameters";
          tailf:cli-mode-name "config-router-ptmp";
          tailf:cli-exit-command "exit-peer-policy" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-policy template";
            }
          }
          uses router-bgp-peer-policy-grouping;
        }

        // router bgp * / template peer-session *
        list peer-session {
          tailf:info "Template configuration for session parameters";
          tailf:cli-mode-name "config-router-stmp";
          tailf:cli-exit-command "exit-peer-session" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-session template";
            }
          }
          uses router-bgp-peer-session-grouping;
        }
      }

      // router bgp * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // router bgp * / address-family ipv4 *
        list ipv4 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-full-command;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum mdt {
                tailf:info "IPv4 multicast distribution tree (MDT)";
              }
              enum tunnel {
                tailf:info "IPv4 tunnel address prefixes.";
              }
              enum labeled-unicast {
                tailf:info "IPv4 labeled-unicast address prefixes";
              }
            }
            tailf:key-default "unicast";
          }
          uses router-bgp-af-grouping;
        }

        // router bgp * / address-family ipv6 *
        list ipv6 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-full-command;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses router-bgp-af-grouping;
        }

        // router bgp * / address-family ipv4 vrf *
        container with-vrf {
          tailf:cli-drop-node-name;
          list ipv4 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            key af;
            leaf af {
              type enumeration {
                enum unicast {
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:info "Address Family modifier";
                }
                enum mdt {
                  tailf:info "IPv4 multicast distribution tree (MDT)";
                }
                enum tunnel {
                  tailf:info "IPv4 tunnel address prefixes.";
                }
                enum labeled-unicast {
                  tailf:info "IPv4 labeled-unicast address prefixes";
                }
              }
              tailf:key-default "unicast";
            }
            // router bgp * / address-family ipv4 vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-full-command;
              tailf:cli-diff-dependency "/ios:ip/vrf";
              tailf:cli-diff-dependency "/ios:vrf/definition";
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration mode";
              }
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
              uses router-bgp-af-grouping;
            }
          }
        }

        // router bgp * / address-family ipv6 vrf *
        container ipv6-with-vrf {
          tailf:cli-drop-node-name;
          list ipv6 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            key af;
            leaf af {
              type enumeration {
                enum unicast {
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:info "Address Family modifier";
                }
              }
              tailf:key-default "unicast";
            }
            // router bgp * / address-family ipv6 vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-full-command;
              tailf:cli-diff-dependency "/ios:vrf/definition";
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration mode";
              }
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            uses router-bgp-af-grouping;
          }
          uses router-bgp-af-grouping;
          }
        }

        // router bgp * / address-family vpnv4 *
        list vpnv4 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses router-bgp-af-grouping;
        }

        // router bgp * / address-family vpnv6 *
        list vpnv6 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses router-bgp-af-grouping;
        }

        // router bgp * / address-family l2vpn *
        list l2vpn {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum vpls {
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "vpls";
          }
          uses router-bgp-af-grouping;
        }

        // router bgp * / address-family nsap *
        list nsap {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses router-bgp-af-grouping;
        }

        // router bgp * / address-family rtfilter *
        list rtfilter {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses router-bgp-af-grouping;
        }
      }
    }

    /// router eigrp
    // router eigrp *
    list eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        type union {
          type uint16 {
            tailf:info "<1-65535>;;Autonomous System";
            range "1..65535";
          }
          type string {
            tailf:info "WORD;;EIGRP Virtual-Instance Name";
          }
        }
      }

      // router eigrp * / network *
      list network {
        tailf:info "Enable routing on an IP network";
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip;
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network number";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;EIGRP wild card bits";
          }
        }
      }

      // router eigrp * / redistribute
      container redistribute {
        tailf:info "Redistribute IPv4 routes from another routing protocol";

        // router eigrp * / redistribute connected
        container connected {
          tailf:info "Connected";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute bgp
        container bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf as-number {
            tailf:cli-drop-node-name;
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;Autonomous system number";
              }
              type string {
                tailf:info "<1.0-XX.YY>;;Autonomous system number";
              }
            }
          }
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute eigrp *
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;Autonomous system number";
              range "1..65535";
            }
          }
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute isis
        container isis {
          tailf:info "ISO IS-IS";
          tailf:cli-compact-syntax;
          presence true;
          // router eigrp * / redistribute isis *
          list isis-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key name;
            leaf name {
              tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|route-map";
              type string {
                tailf:info "WORD;;ISO routing area tag";
              }
            }
            leaf level {
              tailf:cli-drop-node-name;
              type isis-level-type;
            }
            uses eigrp-metric-route-map-grouping;
          }
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute iso-igrp
        container iso-igrp {
          tailf:info "IGRP for OSI networks";
          presence true;
          list iso-igrp-list {
            tailf:info "Border Gateway Protocol (BGP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            key name;
            leaf name {
              tailf:cli-disallow-value "metric|route-map";
              type string {
                tailf:info "WORD;;ISO routing area tag";
              }
            }
            uses eigrp-metric-route-map-grouping;
          }
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute mobile
        container mobile {
          tailf:info "Mobile routes";
          tailf:cli-compact-syntax;
          presence true;
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute odr
        container odr {
          tailf:info "On Demand stub Routes";
          tailf:cli-compact-syntax;
          presence true;
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute ospf *
        list ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          uses eigrp-metric-route-map-grouping;

          // router eigrp * / redistribute ospf * match
          container match {
            tailf:info "Redistribution of OSPF routes";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses redistribute-ospf-match-grouping;
            uses eigrp-metric-route-map-grouping;
          }
        }

        // router eigrp * / redistribute static
        container static {
          tailf:info "Static routes";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence "Static routes";
          uses eigrp-metric-route-map-grouping;
        }

        // router eigrp * / redistribute rip
        container rip {
          tailf:info "Routing Information Protocol (RIP)";
          tailf:cli-compact-syntax;
          presence true;
          uses eigrp-metric-route-map-grouping;
        }
      }

      // router eigrp * / auto-summary
      leaf auto-summary {
        tailf:info "Enable automatic network number summarization";
        tailf:cli-full-command;
        type empty;
      }
    }

    /// router ospfv3
    // router ospfv3 *
    list ospfv3 {
      tailf:info "OSPFv3";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }

      uses router-ospfv3-grouping;
      uses router-ospf-common-grouping;

      // router ospfv3 * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // router ospfv3 * / address-family ipv4
        container ipv4 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-ospfv3-grouping;
            uses router-ospf-common-grouping;
            uses router-ospf-common-af-grouping;
            uses router-ospfv3-af-grouping;
          }
        }

        // router ospfv3 * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-ospfv3-grouping;
            uses router-ospf-common-grouping;
            uses router-ospf-common-af-grouping;
            uses router-ospfv3-af-grouping;
          }
        }
      }
    }

    /// router ospf
    // router ospf *
    list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-mode-name "config-router";
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }
      leaf vrf {
        tailf:info "VPN Routing/Forwarding Instance";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
        }
      }
      uses router-ospf-common-grouping;
      uses router-ospf-common-af-grouping;
      uses router-ospf-grouping;
    }

    /// router isis
    // router isis
    container isis {
      tailf:cli-add-mode;
      tailf:info "ISO IS-IS";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/ios:ip/routing";
      presence true;
      uses router-isis-grouping;
    }

    // router isis *
    container isis-container {
      tailf:cli-drop-node-name;
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "/ios:ip/routing";
        key area-tag;
        leaf area-tag {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses router-isis-grouping;
      }
    }

    /// router rip
    // router rip
    container rip {
      tailf:info "Routing Information Protocol (RIP)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;

      uses router-rip-grouping;

      // router rip / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address family";

          // router rip / address-family ipv4 unicast
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-diff-dependency "/ios:ip/routing" {
              tailf:cli-trigger-on-set;
            }
            uses router-rip-grouping;
          }

          // router rip / address-family ipv4 vrf *
          list vrf {
            tailf:info "Specify parameters for a VPN Routing/Forwarding "+
              "instance";
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-diff-dependency "/ios:ip/routing" {
              tailf:cli-trigger-on-set;
            }
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            uses router-rip-af-grouping;
          }
        }
      }
    }

    /// router lisp
    // router lisp
    container lisp {
      tailf:info "Locator/ID Separation Protocol";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router-lisp";
      presence true;
      uses router-lisp-grouping;
    }

    // router lisp *
    container router-lisp {
      tailf:cli-drop-node-name;
      list lisp {
        tailf:cli-mode-name "config-router-lisp";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-15>;;router lisp ID";
            range "0..15";
          }
        }
        uses router-lisp-grouping;
      }
    }

  }


  /// ========================================================================
  /// snmp
  /// ========================================================================

  container snmp {
    tailf:info "Modify non engine SNMP parameters";

    // snmp ifmib
    container ifmib {
      tailf:info "IF-MIB commands";

      // snmp ifmib ifindex
      container ifindex {
        tailf:info "ifindex persistence";
        leaf persist {
          tailf:info "Persist interface indices";
          type empty;
        }
      }

      // snmp ifmib ifalias long
      container ifalias {
        tailf:info "ifAlias description option, by default it is limited "+
          "to 64 character";
        leaf long {
          tailf:info "ifAlias description can be up to 256 characters";
          type empty;
        }
      }
    }

    // snmp mib
    container mib {
      tailf:info "MIB commands";

      // snmp mib bulkstat
      container bulkstat {
        tailf:info "Bulkstat Configuration commands";

        // snmp mib bulkstat object-list
        list object-list {
          tailf:info "Configure an Object List.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of object list";
            }
          }
        }
      }

      // snmp mib persist
      leaf persist {
        tailf:info "Persistence for MIBS";
        tailf:cli-full-command;
        type enumeration {
          enum cbqos {
            tailf:info "CBQOS MIB index persistence";
          }
          enum circuit {
            tailf:info "Circuit MIB persistence";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "Modify SNMP engine parameters";

    // snmp-server chassis-id
    leaf chassis-id {
      tailf:info "String to uniquely identify this chassis";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Unique ID string";
      }
    }

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;SNMP community string";
        }
      }
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      leaf ipv6 {
        tailf:info "Specify IPv6 Named Access-List";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;IPv6 Access-list name";
        }
      }
      leaf access-list-name {
        tailf:cli-drop-node-name;
        type std-ip-acl-type;
      }
    }

    // snmp-server contact
    leaf "contact" {
      tailf:info "Text for mib object sysContact";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;identification of the contact person for this "
          +"managed node";
      }
    }

    // snmp-server context *
    list context {
      tailf:info "Create/Delete a context apart from default";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Context Name";
        }
      }
    }

    // snmp-server drop
    container drop {
      tailf:info "Silently drop SNMP packets";
      leaf vrf-traffic {
        tailf:info "Silently drop SNMP packets that come on VRF interface";
        type empty;
      }
    }

    // snmp-server enable
    container enable {
      tailf:info "Enable SNMP Traps or Informs";
      choice enable-choice {

        // snmp-server enable informs
        leaf informs {
          tailf:info "Enable SNMP Informs";
          type empty;
        }

        // snmp-server enable traps *
        list traps {
          tailf:info "Enable SNMP Traps";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          ordered-by "user";
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Trap name";
            }
          }
        }
      }
    }

    // snmp-server engine-id
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";

      // snmp-server engineID local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
          length "1..24";
        }
      }

      // snmp-server engineID remote *
      // FIXME: one entry per udp-port|vrf|udp-port&vrf can co-exist.
      list remote {
        tailf:info "engineID of the remote agent";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type host-v4v6-type;
        }
        leaf udp-port {
          tailf:info "The remote notification host's UDP port number";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<0-65535>;;The remote notification host's "+
              "UDP port number";
          }
        }
        leaf vrf {
          tailf:info "The remote notification host's VPN routing instance";
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf engineid-string {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      choice security-model {
        container v1 {
          tailf:info "group using the v1 security model";
        }
        container v2c {
          tailf:info "group using the v2c security model";
        }
        container v3 {
          tailf:info "group using the User Security Model (SNMPv3)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf security-level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum auth {
                tailf:info "group using the authNoPriv Security Level";
              }
              enum noauth {
                tailf:info "group using the noAuthNoPriv Security Level";
              }
              enum priv {
                tailf:info "group using SNMPv3 authPriv security level";
              }
            }
          }
          leaf context {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a context to associate these views for the "
              +"group";
            type string {
              tailf:info "WORD;;context name";
            }
          }
          leaf match {
            tailf:cli-optional-in-sequence;
            tailf:info "context name match criteria";
            type enumeration {
              enum exact {
                tailf:info "match the exact context";
              }
              enum prefix {
                tailf:info "only match the context prefix";
              }
            }
          }
          leaf read {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a read view for the group";
            type string {
              tailf:info "WORD;;read view name";
            }
          }
          leaf write {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a write view for the group";
            type string {
              tailf:info "WORD;;write view name";
            }
          }
          leaf notify {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a notify view for the group";
            type string {
              tailf:info "WORD;;notify view name";
            }
          }
          leaf access {
            tailf:info "specify an access-list associated with this group";
            type union {
              type uint8 {
                tailf:info "<1-99>;;Std IP accesslist allowing access with "
                  +"this group";
                range "1..99";
              }
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }
      }
    }

    // snmp-server host *
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key ip-address;
      leaf ip-address {
        tailf:cli-disallow-value "vrf";
        tailf:cli-case-sensitive;
        type host-type {
          tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP"+
            " notification host";
        }
      }
      // snmp-server host * vrf *
      list vrf {
        tailf:info "VPN Routing instance for this host";
        tailf:cli-optional-in-sequence;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses snmp-server-host-grouping;
      }
      uses snmp-server-host-grouping;
    }

    // snmp-server ip
    container ip {
      tailf:info "IP ToS configuration for SNMP traffic";

      // snmp-server ip dscp
      leaf dscp {
        tailf:info "IP DSCP value for SNMP traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0 )";
          range "0..63";
        }
      }

      // snmp-server ip precedence
      leaf precedence  {
        tailf:info "IP Precedence value for SNMP traffic";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }
    }

    // snmp-server ifindex
    container ifindex {
      tailf:info "Enable ifindex persistence";
      leaf persist {
        tailf:info "Persist interface indices";
        type empty;
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib object sysLocation";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server manager
    container manager {
      tailf:info "Modify SNMP manager parameters";
      tailf:cli-display-separated;
      presence true;
      leaf session-timeout {
        tailf:info "Timeout value for destroying sessions";
        type uint32 {
          tailf:info "<10-2147483>;;seconds";
          range "10..2147483";
        }
      }
    }

    // snmp-server packetsize
    leaf packetsize {
      tailf:info "Largest SNMP packet size";
      type uint16 {
        tailf:info "<484-17940>;;Packet size";
        range "484..17940";
      }
    }

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      type uint16 {
        tailf:info "<1-5000>;;Queue length (default 10)";
        range "1..5000";
      }
    }

    // snmp-server queue-limit notification-host
    container queue-limit {
      tailf:info "Message queue size for different queues";
      leaf notification-host {
        tailf:info "Message queue length for each notification host";
        type uint16 {
          tailf:info "<1-5000>;;notification host queue length";
          range "1..5000";
        }
      }
    }

    // snmp-server source-interface
    container source-interface {
      tailf:info "Assign an source interface";
      container informs {
        tailf:info "source interface for informs";
        uses interface-name-grouping;
      }
      container traps {
        tailf:info "source interface for traps";
        uses interface-name-grouping;
      }
    }

    // snmp-server trap
    container trap {
      tailf:info "SNMP trap options";
      leaf timeout {
        tailf:info "Set timeout for TRAP message retransmissions";
        type uint16 {
          tailf:info "<1-1000>;;Timeout (default 30 seconds)";
          range "1..1000";
        }
      }
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";
      uses interface-name-grouping;
    }

    // snmp-server trap-timeout
    leaf trap-timeout {
      tailf:info "Set timeout for TRAP message retransmissions";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-1000>;;Timeout (default 30 seconds)";
      }
    }

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "name mib";
      leaf name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      leaf mib {
        type string {
          tailf:info "WORD;;MIB view family name";
        }
      }
      leaf inc-exl {
        tailf:cli-drop-node-name;
        type enumeration {
          enum excluded {
            tailf:info "MIB family is excluded from the view";
          }
          enum included {
            tailf:info "MIB family is included in the view";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot11
  /// ========================================================================

  container dot11 {
    tailf:info "IEEE 802.11 config commands";

    // dot11 syslog
    leaf syslog {
      tailf:info "Enable syslog";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// ipc
  /// ========================================================================

  container ipc {
    tailf:info "Configure IPC system";
    container zone {
      tailf:info "Configure an IPC Zone";

      // ipc zone default
      container "default" {
        tailf:info "Configure the default zone";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ipczone";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// cts
  /// ========================================================================

  container cts {
    tailf:info "Cisco Trusted Security commands";
    container logging {
      tailf:info "Set logging parameters";
      leaf verbose {
        tailf:info "Show verbose messages in system logs";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// license
  /// ========================================================================

  container license {
    tailf:info "Configure license features";

    // license accept end user agreement
    container accept {
      tailf:info "Accept all further License Agreements";
      container end {
        tailf:info "Accept all further License Agreements";
        container user {
          tailf:info "Accept all further License Agreements";
          leaf agreement {
            tailf:info "Accept all further License Agreements";
            type empty;
          }
        }
      }
    }

    // license udi
    container udi {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf pid {
        type string;
      }
      leaf sn {
        type string;
      }
    }

    // license boot *
    list boot {
      tailf:info "license boot config commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by "user";
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;License line";
        }
      }
    }

    // license smart enable
    container smart {
      tailf:info "Smart licensing";
      leaf enable {
        tailf:info "Enable Smart Licensing";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// trunk
  /// ========================================================================

  container trunk {
    tailf:info "Global trunk configuration";

    // trunk group *
    list group {
      tailf:info "Specify a trunk group";
      tailf:cli-mode-name "config-trunk-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Trunk group label";
        }
      }

      // trunk group * / hunt-scheme
      container hunt-scheme {
        tailf:info "The hunt scheme in trunk group";
        choice hunt-scheme-choice {
          container round-robin {
            tailf:info "The next interface with free timeslots is selected";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
          }
          leaf random {
            tailf:info "The timeslot is selected randomly";
            type empty;
          }
          leaf sequential {
            type empty;
          }
        }
      }
    }

  }


  /// ========================================================================
  /// voice-card
  /// ========================================================================

  list voice-card {
    tailf:info "Configure a specific voice-card";
    tailf:cli-mode-name "config-voicecard";
    key slot;
    leaf slot {
      type uint8 {
        tailf:info "<0-2>;;Voice interface slot #";
        range "0..2";
      }
    }

    // voice-card * / dspfarm
    leaf dspfarm {
      tailf:info "Enable dspFarm feature for this voice card";
      type empty;
    }
  }


  /// ========================================================================
  /// voice
  /// ========================================================================

  container voice {
    tailf:info "Global voice configuration";

    container service {
      tailf:info "Global packet telephony service commands";

      // voice service voip
      container voip {
        tailf:info "Voice over IP";
        tailf:cli-add-mode;
        tailf:cli-mode-name "conf-voi-serv";

        // voice service voip / sip
        container sip {
          tailf:info "SIP configuration commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "conf-serv-sip";
          tailf:cli-delete-when-empty;
          presence true;
          container bind {
            tailf:info "SIP bind command";
            container control {
              tailf:info "bind only SIP control packets";
              // voice service voip / sip / bind control source-interface
              container source-interface {
                tailf:info "Specify interface for source address of "+
                  "SIP packets";
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
            }
            container media {
              tailf:info "bind only SIP media packets";
              // voice service voip / sip / bind media source-interface
              container source-interface {
                tailf:info "Specify interface for source address of "+
                  "SIP packets";
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
            }
          }
        }
      }
    }

    // voice iec syslog
    container iec {
      tailf:info "Configure Internal Error Code behavior";
      leaf syslog {
        tailf:info "Enable syslog reporting whenever an IEC is triggered";
        type empty;
      }
    }

    // voice translation-rule *
    list translation-rule {
      tailf:info "Translation Rule configuration commands";
      tailf:cli-mode-name "cfg-translation-rule";
      key tag;
      leaf tag {
        type uint32 {
          tailf:info "<1-2147483647>;;Translation rule tag";
          range "1..2147483647";
        }
      }

      // voice translation-rule * / rule *
      list rule {
        tailf:info "Translation rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        ordered-by "user";
        key tag;
        leaf tag {
          type uint8 {
            tailf:info "<1-15>;;Translation rule tag";
            range "1..15";
          }
        }
        leaf reject {
          tailf:info "Call block rule";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf "pattern" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;Matching pattern";
          }
        }
      }
    }

    // voice translation-profile *
    list translation-profile {
      tailf:info "Translation profile configuration commands";
      tailf:cli-mode-name "cfg-translation-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Translation profile name";
        }
      }

      // voice translation-profile * / translate
      container translate {
        tailf:info "Specify numbers that should be translated";

        // voice translation-profile * / translate called *
        list called {
          tailf:info "Translation rule for the called-number";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key tag;
          leaf tag {
            type uint32 {
              tailf:info "<1-2147483647>;;Translation rule tag";
              range "1..2147483647";
            }
          }
        }
      }
    }

  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related configuration commands";

    // event manager
    container manager {
      tailf:info "Event Manager configuration commands";

      // event manager environment *
      list environment {
        tailf:info "Set an Embedded Event Manager global environment variable";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the global environment variable";
          }
        }
        leaf "value" {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "LINE;;Value of the global environment variable";
          }
        }
      }

      // event manager directory
      container directory {
        tailf:info "Set Embedded Event Manager directory information";
        container user {
          tailf:info "Set Embedded Event Manager user directory information";
          leaf policy {
            tailf:info "Set Embedded Event Manager user policy directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user "+
                "policy directory";
            }
          }
        }
      }

      // event manager applet *
      list applet {
        tailf:info "Register an Event Manager applet";
        tailf:cli-mode-name "config-applet";
        tailf:cli-exit-command "exit" {
          tailf:info "Exit from Event Manager applet configuration submode";
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Event Manager applet";
          }
        }

        // event manager applet * / description
        leaf "description" {
          tailf:info "Add or modify an applet description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;description";
          }
        }

        // event manager applet * / authorization
        leaf authorization  {
          tailf:info "Specify an authorization type for the applet";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum bypass {
              tailf:info "EEM aaa authorization type bypass";
            }
          }
        }

        // event manager applet * / class
        leaf class {
          tailf:info "Specify a class for the applet";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "Class A-Z | default - default class";
            pattern "[A-Z]|default";
          }
        }

        // event manager applet * / trap
        leaf trap {
          tailf:info "Generate an SNMP trap when applet is triggered.";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // event manager applet * / event
        container event {
          tailf:info "Add or modify event information";
          uses event-manager-applet-event-grouping;

          // event manager applet * / event tag *
          list tag {
            tailf:info "event tag identifier";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;tag name";
              }
            }
            uses event-manager-applet-event-grouping;
          }
        }

        // event manager applet * / action *
        list action {
          tailf:info "Add or modify an action statement";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          ordered-by "user";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Label";
            }
          }
          leaf cmd {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "Action string within quotes";
            }
          }
        }

        // event manager applet * / trigger
        container trigger {
          tailf:info "Enter applet trigger configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-applet-trigger";
        }
      }

      // event manager policy *
      list policy {
        tailf:info "Run a pre-registered policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Embedded Event Manager policy file";
          }
        }
        leaf "type" {
          tailf:info "Type of Embedded Event Manager policy";
          type enumeration {
            enum system {
              tailf:info "Search for a Embedded Event Manager system policy";
            }
            enum user {
              tailf:info "Search for a Embedded Event Manager user policy";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// disable-eadi
  /// ========================================================================

  leaf disable-eadi {
    tailf:cli-full-command;
    type empty;
  }


  /// ========================================================================
  /// memory-size
  /// ========================================================================

  container memory-size {
    tailf:info "Adjust memory size by percentage";

    // memory-size iomem
    leaf iomem {
      tailf:info "I/O memory";
      type uint8 {
        tailf:info "<5-25>;;percentage of DRAM to use for I/O memory: "+
          "5, 10, 15, 20, 25";
        range "5..25" {
          tailf:step 5;
        }
      }
    }
  }


  /// ========================================================================
  /// transceiver
  /// ========================================================================

  container transceiver {
    tailf:info "Select from transceiver configuration commands";
    container "type" {
      tailf:info "type keyword";

      // transceiver type all
      container all {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xcvr-type";
        tailf:cli-full-command;

        // transceiver type all / monitoring
        container monitoring {
          tailf:info "Enable/disable monitoring";
          presence true;
          leaf interval {
            tailf:info "Set interval for monitoring";
            type uint16 {
              tailf:info "<300-3600>;;Time interval for monitoring "+
                "transceiver in seconds";
              range "300..3600";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// alias
  /// ========================================================================

  list alias {
    tailf:info "Create command alias";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    ordered-by "user";
    key line;
    leaf line {
      tailf:cli-multi-word-key;
      type string {
        tailf:info "WORD;;alias line";
      }
    }
  }


  /// ========================================================================
  //                          EOF
  /// ========================================================================

}
