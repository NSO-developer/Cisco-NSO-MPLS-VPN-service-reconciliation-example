module tailf-ned-cisco-ios-xr {
  namespace 'http://tail-f.com/ned/cisco-ios-xr';
  prefix cisco-ios-xr;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2015-02-09 {
    description
      "3.5.0.7
      Enhancements:
       Expanded router bgp.
       Added traceroute, copy and reload commands under live-status exec.
      Corrections:
      ";
  }

  revision 2015-02-04 {
    description
      "3.5.0.6
      Enhancements:
       Implemented basic support for router hsrp.
       Added timer config in bfd address-family ipv4 interface config.
       Added route-policy config to vrf address-family export/import.
      Corrections:
      ";
  }

  revision 2015-01-19 {
    description
      "3.5.0.5
      Enhancements:
       Expanded rewrite ingress tag sub-interface config.
       Added level option to isis router metric config.
       Added signalled-name to interface tunnel-te config.
      Corrections:
      ";
  }

  revision 2015-01-14 {
    description
      "3.5.0.4
      Enhancements:
       Expanded interface tunnel-te config.
      Corrections:
      ";
  }

  revision 2014-12-19 {
    description
      "3.5.0.3
      Enhancements:
       Added domain list config.
       Expanded ospf and ospfv3 config.
       Added generic snmp-server traps list accepting all entries.
      Corrections:
       Removed all 'tailf:cli-no-keyword' on non policy-map config.
      ";
  }

  revision 2014-12-10 {
    description
      "3.5.0.2
      Enhancements:
       Added support for explicit-path config.
      Corrections:
      ";
  }

  revision 2014-12-08 {
    description
      "3.5.0.1
      Enhancements:
       Added ping and clear exec commands under live-status, e.g.:
        devices device asr9k live-status exec ping 192.168.1.1
        devices device asr9k live-status exec clear ppp queues
       Added PW-Ether interface and sub-interface. (RT 17184)
       Send initial newline to device for terminal support. (RT 16500)
      Corrections:
       Strip no commands inside extcommunity-set, rd-set, prefix-set,
        as-path-set and community-set on real devices. (RT 17090)
      ";
  }

  revision 2014-11-26 {
    description
      "3.4.0
      Enhancements:
       The method to use by the NED for calculating transaction ID is now a
        configurable option.
        The config option cisco-iosxr-transaction-id-method is available under:
         /ncs:devices/global-settings/ned-settings/
         /ncs:devices/ncs:profiles/profile:cisco-iosxr/ned-settings/
         /ncs:/device/devices/device:<dev name>/ned-settings/
        Two values are supported:
         config-hash (default) : Use a snapshot of the running config for
                                 calculation.
         commit-list :           Use the configuration commit list time of
                                 the latest commit for calculation.
       Implemented support for 'crypto key' exec commands under live-status,
        e.g.: devices device asr9k live-status exec crypto key generate rsa
       Expanded router ospf, router pim, router igmp and router static.
       Numerous YANG model expansions in various areas.
       Implemented basic support for router ospfv3.
       YANG data model updates: class-map / match vlan
       YANG data model updates: l2vpn
      Corrections:
       Fixed two problem with class-map / match dscp, ordering and ipv4/ipv6.
      ";
  }

  revision 2014-10-16 {
    description
      "3.2.0
       Master merge and release.
      ";
  }

  revision 2014-10-15 {
    description
      "3.0.1.6
       Expanded router isis / interface *
       Added interface * / transport-mode
       Expanded snmp-server user *
       Various new config items supported.
      ";
  }

  revision 2014-10-12 {
    description
      "3.0.1.5
       Expanded router isis and router bgp.
       Reworked broken route-policy to single quoted string.
       Expanded path-option in tunnel-te interface.
      ";
  }

  revision 2014-10-09 {
    description
      "3.0.1.4
       Added version string in NED trace.
       Expanded router pim address family config.
      ";
  }

  revision 2014-09-30 {
    description
      "3.0.1.3
       Added isis and ospf to router bgp address family redistribute config.
       Expanded router bgp config.
      ";
  }

  revision 2014-09-15 {
    description
      "3.0.1.2
       Major config expansion in numerous areas all over, mainly routing.
       Expanded l2vpn bridge domain config settings.
       Implemented support for show commands under live-status exec show, e.g.
        devices device asr9k live-status exec show running-config interface Loopback0
      ";
  }

  revision 2014-08-22 {
    description
      "3.0.1.1
       Expanded RSVP config.
       Enabled transaction ID's unique string, restoring check-sync.
       Implemented support for multiple secondary ipv4 addresses in interface.
       Implemented l2vpn / xconnect / mp2mp / autodiscovery / bgp / rd
         skeleton config to avoid matching top level rd-set.
      ";
  }

  revision 2014-06-05 {
    description
      "Additional config supported for Ethernet/Frame Relay Bundled Service
       and Ethernet MPLS L2VPN.
      ";
  }

  revision 2014-02-18 {
    description
      "Additional config supported";
  }

  revision 2014-02-17 {
    description
      "Added support for route-policy in router bgp / vrf / address-family";
  }

  revision 2014-01-27 {
    description
      "Added 'mpls static' config
       Added 'interface tunnel-ip' config
       Added 'tailf:cli-explicit-exit' to top containers
       Changed references to interface(s) to non-strict leafrefs";
  }

  revision 2014-01-16 {
    description
      "Additional config supported";
  }

  revision 2013-12-19 {
    description
      "Additional config supported and bugfixes";
  }

  revision 2013-12-11 {
    description
      "Cleanup, improvements and bugfixes";
  }

  revision 2013-08-20 {
    description
      "Renamed YANG module, submodule and namespace.
       First revision statement added.
      ";
  }


  // =========================================================================
  // TODO
  // =========================================================================

  // test banner's.

  // =========================================================================
  // TYPEDEF
  // =========================================================================


  typedef month-type {
    type enumeration {
      enum january;
      enum february;
      enum march;
      enum april;
      enum may;
      enum june;
      enum july;
      enum august;
      enum september;
      enum october;
      enum november;
      enum december;
    }
  }

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  typedef asn-ip-type {
    type string {
 pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
      tailf:info "ASN:nn or IP-address:nn";
    }
  }

  typedef ipv4-prefix {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
      "The ipv4-prefix type represents an IPv4 address prefix.
    The prefix length is given by the number following the
    slash character and must be less than or equal to 32.

    A prefix length value of n corresponds to an IP address
    mask that has n contiguous 1-bits from the most
    significant bit (MSB) and all other bits set to 0.

    The canonical format of an IPv4 prefix has all bits of
    the IPv4 address set to zero that are not part of the
    IPv4 prefix.";
  }

  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
        + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
        + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
        + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
        + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
        + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
        + '(/.+)';
    }
  }

  typedef task-type {
    type enumeration {
      enum li;
      enum aaa;
      enum acl;
      enum bfd;
      enum bgp;
      enum cdp;
      enum cef;
      enum cgn;
      enum eem;
      enum pbr;
      enum qos;
      enum rib;
      enum bcdl;
      enum diag;
      enum dwdm;
      enum ipv4;
      enum ipv6;
      enum isis;
      enum lpts;
      enum ouni;
      enum rcmd;
      enum snmp;
      enum vlan;
      enum l2vpn;
      enum bundle;
      enum crypto;
      enum fabric;
      enum static;
      enum sysmgr;
      enum system;
      enum tunnel;
      enum drivers;
      enum logging;
      enum monitor;
      enum netflow;
      enum network;
      enum pkg-mgmt;
      enum fault-mgr;
      enum interface;
      enum inventory;
      enum multicast;
      enum route-map;
      enum transport;
      enum ext-access;
      enum filesystem;
      enum tty-access;
      enum config-mgmt;
      enum ip-services;
      enum route-policy;
      enum host-services;
      enum config-services;
      enum ethernet-services;
      enum basic-services;
    }
  }

  typedef severity-type {
    type enumeration {
      enum alerts {
        tailf:info "Immediate action needed           (severity=1)";
      }
      enum critical {
        tailf:info "Critical conditions               (severity=2)";
      }
      enum debugging {
        tailf:info "Debugging messages                (severity=7)";
      }
      enum emergencies {
        tailf:info "System is unusable                (severity=0)";
      }
      enum errors {
        tailf:info "Error conditions                  (severity=3)";
      }
      enum info {
      }
      enum informational {
        tailf:info "Informational messages            (severity=6)";
      }
      enum notifications {
        tailf:info "Normal but significant conditions (severity=5)";
      }
      enum warnings {
        tailf:info "Warning conditions                (severity=4)";
      }
    }
  }

  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "AF11 dscp (001010)";
          tailf:code-name "dscp_af11";
        }
        enum af12 {
          tailf:info "AF12 dscp (001100)";
          tailf:code-name "dscp_af12";
        }
        enum af13 {
          tailf:info "AF13 dscp (001110)";
          tailf:code-name "dscp_af13";
        }
        enum af21 {
          tailf:info "AF21 dscp (010010)";
          tailf:code-name "dscp_af21";
        }
        enum af22 {
          tailf:info "AF22 dscp (010100)";
          tailf:code-name "dscp_af22";
        }
        enum af23 {
          tailf:info "AF23 dscp (010110)";
          tailf:code-name "dscp_af23";
        }
        enum af31 {
          tailf:info "AF31 dscp (011010)";
          tailf:code-name "dscp_af31";
        }
        enum af32 {
          tailf:info "AF32 dscp (011100)";
          tailf:code-name "dscp_af32";
        }
        enum af33 {
          tailf:info "AF33 dscp (011110)";
          tailf:code-name "dscp_af33";
        }
        enum af41 {
          tailf:info "AF41 dscp (100010)";
          tailf:code-name "dscp_af41";
        }
        enum af42 {
          tailf:info "AF42 dscp (100100)";
          tailf:code-name "dscp_af42";
        }
        enum af43 {
          tailf:info "AF43 dscp (100110)";
          tailf:code-name "dscp_af43";
        }
        enum cs1 {
          tailf:info "CS1(precedence 1) dscp (001000)";
          tailf:code-name "dscp_cs1";
        }
        enum cs2 {
          tailf:info "CS2(precedence 2) dscp (010000)";
          tailf:code-name "dscp_cs2";
        }
        enum cs3 {
          tailf:info "CS3(precedence 3) dscp (011000)";
          tailf:code-name "dscp_cs3";
        }
        enum cs4 {
          tailf:info "CS4(precedence 4) dscp (100000)";
          tailf:code-name "dscp_cs4";
        }
        enum cs5 {
          tailf:info "CS5(precedence 5) dscp (101000)";
          tailf:code-name "dscp_cs5";
        }
        enum cs6 {
          tailf:info "CS6(precedence 6) dscp (110000)";
          tailf:code-name "dscp_cs6";
        }
        enum cs7 {
          tailf:info "CS7(precedence 7) dscp (111000)";
          tailf:code-name "dscp_cs7";
        }
        enum "default" {
          tailf:info "Default dscp (000000)";
          tailf:code-name "dscp_default";
        }
        enum ef {
          tailf:info "EF dscp (101110)";
          tailf:code-name "dscp_ef";
        }
      }
    }
  }

  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum internet {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control "+
            "precedence (6)";
        }
        enum network {
          tailf:info "Set packets with network control precedence "+
            "(7)";
        }
        enum priority {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
        }
        enum ipv4 {
          tailf:info "IPV4 precedence";
          tailf:code-name "prec_ipv4";
        }
        enum ipv6 {
          tailf:info "IPV6 precedence";
          tailf:code-name "prec_ipv6";
        }
      }
    }
  }

  typedef police-burst-units-type {
    type enumeration {
      enum bytes {
        tailf:info "Bytes (default)";
      }
      enum gbytes {
        tailf:info "Gigabytes";
      }
      enum kbytes {
        tailf:info "Kilobytes";
      }
      enum mbytes {
        tailf:info "Megabytes";
      }
      enum ms {
        tailf:info "Milliseconds";
      }
      enum packets {
        tailf:info "Packets";
      }
      enum us {
        tailf:info "Microseconds";
      }
    }
  }

  typedef police-rate-units-type {
    type enumeration {
      enum bps {
        tailf:info "Bits per second (default)";
      }
      enum gbps {
        tailf:info "Gigabits per second";
      }
      enum kbps {
        tailf:info "Kilobits per second";
      }
      enum mbps {
        tailf:info "Megabits per second";
      }
      enum pps {
        tailf:info "Packets per second";  //??
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
      enum rg {
        tailf:info "Not in range";
      }
    }
  }

  typedef control-plane-proto {
    type enumeration {
      enum HTTP {
        tailf:info "HTTP(S)";
      }
      enum NETCONF {
        tailf:info "NETCONF version 1.1 protocol";
      }
      enum SNMP {
        tailf:info "SNMP (all versions)";
      }
      enum SSH {
        tailf:info "Secure Shell (v1 & v2)";
      }
      enum TFTP {
        tailf:info "Enable TFTP";
      }
      enum Telnet {
        tailf:info "Telnet";
      }
      enum XML {
        tailf:info "XML";
      }
      enum all {
        tailf:info "All Protocols";
      }
    }
  }

  typedef vrf-type {
    type union {
      type string {
        tailf:info "WORD;;Name of VRF";
      }
      type enumeration {
        enum "default" {
          tailf:info "Default vrf";
        }
      }
    }
  }


  // =========================================================================
  // GROUPING
  // =========================================================================

  grouping banner-grouping {
    leaf start-marker {
      tailf:cli-drop-node-name;
      type string;
    }
    leaf message {
      tailf:cli-drop-node-name;
      type string;
    }
    leaf end-marker {
      tailf:cli-drop-node-name;
      type string;
      must "../end-marker = ../start-marker" {
        tailf:dependency "../start-marker";
      }
    }
  }

  // vrf * / address-family ipv4 unicast / import route-target
  // vrf * / address-family ipv4 unicast / export route-target
  // vrf * / address-family ipv6 unicast / import route-target
  // vrf * / address-family ipv6 unicast / export route-target
  grouping vrf-route-target-grouping {

    // vrf * / address-family ipv6 unicast / export route-target / *
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "<1-65535>:<0-4294967295>;;ASN2:index\n"+
            "<65536-4294967295>:<0-65535>;;ASN4:index\n"+
            "<IP address>:<0-65535>;;IPAddress:index "+
            "(hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
    }
  }

  // router-af-redistribute-grouping
  grouping router-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
    }
  }

  // router-ospf-af-redistribute-grouping
  grouping router-ospf-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
    }
  }

  // router-isis-af-redistribute-grouping
  grouping router-isis-af-redistribute-grouping {
    uses router-af-redistribute-grouping;
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "External metric type";
        }
        enum internal {
          tailf:info "Internal metric type";
        }
        enum rib-metric-as-external {
          tailf:info "External metric type and use RIB metric";
        }
        enum rib-metric-as-internal {
          tailf:info "Internal metric type and use RIB metric";
        }
      }
    }
  }

  // router ospf * / area * / X
  // router ospf * / area * / interface * / X
  grouping router-ospf-area-grouping {

    // router ospf * / area * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router ospf * / area * / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        type uint32 {
          tailf:info "<15-30000>;;hello interval in milli-seconds";
          range "15..30000";
        }
      }

      // router ospf * / area * / bfd fast-detect
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "Prevent bfd settings from being inherited "+
            "from the parent";
          type empty;
        }
      }

      // router ospf * / area * / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        type uint8 {
          tailf:info "<2-30>;;Detect multiplier";
          range "2..30";
        }
      }
    }

    // router ospf * / area * / cost
    leaf cost {
      tailf:info "Interface cost";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-65535>;;Cost";
        range "1..65535";
      }
    }

    // router ospf * / area * / authentication
    container authentication {
      tailf:info "Enable authentication";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice  authentication-choice {
        container message-digest {
          tailf:info "Use message-digest authentication";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf keychain {
            tailf:info "Specify keychain name";
            type string {
              tailf:info "WORD;;The keychain name";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:key/chain/name";
            }
          }
        }
        leaf "null" {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }

    // router ospf * / area * / message-digest-key
    list message-digest-key {
      tailf:info "Message digest authentication password (key)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Key ID";
          range "1..255";
        }
      }
      container md5 {
        tailf:info "Use MD5 algorithm";
        tailf:cli-compact-syntax;
        choice md5-choice {
          leaf "key" {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED password (key)";
            }
          }
        }
      }
    }

    // router ospf * / area * / network
    leaf network {
      tailf:info "Network type";
      tailf:cli-full-command;
      type enumeration {
        enum broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
        }
        enum non-broadcast {
          tailf:info "Specify OSPF NBMA network";
        }
        enum point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
        }
        enum point-to-point {
          tailf:info "Specify OSPF point-to-point network";
        }
      }
    }

    // router ospf * / area * / passive
    container passive {
      tailf:info "Enable/Disable passive";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable passive";
          }
          enum enable {
            tailf:info "Enable passive";
          }
        }
      }
    }

    // router ospf * / area * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        container sync {
          tailf:info "Enable LDP IGP synchronization on interfaces";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync";
            type empty;
          }
        }
      }
      leaf traffic-eng {
        tailf:info "Configure an ospf area to run MPLS Traffic Engineering";
        type empty;
      }
    }

    // router ospf * / area * / priority
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }

    // router ospf * / area * / mtu-ignore
    container mtu-ignore {
      tailf:info "Enable/Disable ignoring of MTU in DBD packets";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable ignoring of MTU in DBD packets";
          }
          enum enable {
            tailf:info "Ignores the MTU in DBD packets";
          }
        }
      }
    }

    // router ospf * / area * / fast-reroute
    container fast-reroute {
      tailf:info "IP Fast Reroute";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      container per-link {
        tailf:info "Per-link Computation";
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        presence true;
        leaf enable {
          type empty;
        }
      }
    }

    // router ospf * / area * / hello-interval
    leaf hello-interval {
      tailf:info "Time between HELLO packets";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }
  }

  // router ospf *
  // router ospfv3 *
  grouping router-ospf-common-grouping {

    // router ospf * / nsr
    leaf nsr {
      tailf:info "Enable NSR for all VRFs in this process";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / router-id
    leaf router-id {
      tailf:info "Specify the router-id for this OSPF process";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF router-id in IPv4 address format";
      }
    }

    // router ospf * / log
    container log {
      tailf:info "Log ospf info";
      container adjacency {
        tailf:info "Log adjacency state info";
        container changes {
          tailf:info "Log changes";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf changes-state {
            tailf:cli-drop-node-name;
            type enumeration {
              enum detail {
                tailf:info "Log all state changes";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";
      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";
        container lsa {
          tailf:info "LSA throttle timers";
          container all {
            tailf:info "For all types of OSPF LSAs";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<0-600000>;;Delay to generate first occurrence "
                  +"of LSA in milliseconds";
                range "0..600000";
              }
            }
            leaf min-delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-600000>;;Minimum delay between originating "
                  +"the same LSA in milliseconds";
                range "1..600000";
              }
            }
            leaf max-delay {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-600000>;;Maximum delay between originating "
                  +"the same LSA in milliseconds";
                range "1..600000";
              }
            }
          }
        }
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf delay {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "1..600000";
              tailf:info "<1-600000>;;Delay between receiving a change "
                +"to SPF calculation in milliseconds";
            }
          }
          leaf min-delay {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "1..600000";
              tailf:info "<1-600000>;;Delay between first and second "
                +"SPF calculation in milliseconds";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1..600000";
              tailf:info "<1-600000>;;Maximum wait time in milliseconds "
                +"for SPF calculations";
            }
          }
        }
      }
      // router ospf * / timers lsa
      container lsa {
        tailf:info "OSPF global LSA timers";
        leaf min-arrival {
          tailf:info "OSPF MinLSArrival timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in millisec "+
              "between accepting the same LSA";
            range "0..600000";
          }
        }
      }
    }

    // router ospf * / auto-cost
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      tailf:cli-delete-when-empty;
      presence true;

      // router ospf * / auto-cost reference-bandwidth
      leaf reference-bandwidth {
        tailf:info "Specify reference bandwidth for OSPF cost computations";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms of "+
            "Mbits per second";
          range "1..4294967";
        }
      }
    }

    // router ospf * / maximum
    container maximum {
      tailf:info "Set OSPF limits";

      // router ospf * / maximum paths
      leaf paths {
        tailf:info "Limit number of paths";
        type uint8 {
          tailf:info "<1-64>;;Maximum number of paths per route";
          range "1..64";
        }
      }

      // router ospf * / maximum interfaces
      leaf interfaces {
        tailf:info "Limit number of interfaces";
        type uint32 {
          tailf:info "<1-4294967295>;;Maximum number of interfaces";
        }
      }

      // router ospf * / maximum redistributed-prefixes
      container redistributed-prefixes {
        tailf:info "Limit number of redistributed prefixes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of prefixes "+
              "redistributed into OSPF";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning messsage when limit is exceeded";
          type empty;
        }
      }
    }

    // router ospf * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router ospf * / bfd fast-detect
      leaf fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-full-command;
        type empty;
      }

      // router ospf * / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-30000>;;hello interval in milli-seconds";
          range "0..30000";
        }
      }

      // router ospf * / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-30>;;Detect multiplier";
        }
      }
    }

    // router ospf * / network
    container network {
      tailf:info "Network type";
      choice network-choice {
        leaf broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
          type empty;
        }
        leaf non-broadcast {
          tailf:info "Specify OSPF NBMA network";
          type empty;
        }
        container point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-broadcast {
            tailf:info "Specify OSPF non-broadcast point-to-multipoint "+
              "network";
            type empty;
          }
        }
        leaf point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          type empty;
        }
      }
    }

    // router ospf * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }
    }

    // router ospf * / spf
    container spf {
      tailf:info "SPF configuration";
      container prefix-priority {
        tailf:info "Configure SPF prefix priority route policy";
        leaf route-policy {
          tailf:info "Specify the route-policy to prioritize route install";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        leaf preserve-med {
          tailf:info "Preserve med of BGP routes";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }
    }

    // router ospf * / area *
    list area {
      tailf:info "Enter the OSPF area configuration submode";
      tailf:cli-mode-name "config-ospf-ar";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }
      uses router-ospf-area-grouping;

      // router ospf * / area * / interface *
      list interface {
        tailf:info "Enable routing on an interface";
        tailf:cli-mode-name "config-ospf-ar-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }
    }
  }

  // router ospf *
  // router ospf * / vrf *
  grouping router-ospf-grouping {

    // router ospf * / ?
    uses router-ospf-common-grouping;

    // router ospf * / nsf
    container nsf {
      tailf:info "Enable Cisco Non Stop Forwarding";
      // router ospf * / nsf ietf
      container ietf {
        tailf:info "Enable ietf graceful restart";
        tailf:cli-display-separated;
        presence true;
        container helper {
          tailf:info "router's helper support level";
          leaf disable {
            tailf:info "router's helper support disabled";
            type empty;
          }
        }
      }
      // router ospf * / nsf cisco
      container cisco {
        tailf:info "Enable Cisco Non Stop Forwarding";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        container enforce {
          tailf:info "Cancel NSF restart when non-NSF-aware "+
            "neighbors detected";
          leaf global {
            tailf:info "For the whole OSPF process";
            type empty;
          }
        }
      }
    }

    // router ospf * / address-family ipv4
    container address-family {
      tailf:info "OSPF address family";
      container ipv4 {
        tailf:info "IPV4 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }

    // router ospf * / max-metric
    container max-metric {
      tailf:info "Set maximum metric";
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        leaf on-startup {
          tailf:info "On startup";
          tailf:cli-optional-in-sequence;
          type union {
            type uint32 {
              tailf:info "<5-86400>;;Time in seconds to originate "+
                "router-LSA with max-metric";
              range "5..86400";
            }
            type enumeration {
              enum wait-for-bgp {
                tailf:info "Let BGP decide when to originate router-LSA "+
                  "with normal metric";
              }
            }
          }
        }
        leaf include-stub {
          tailf:info "Set maximum metric for stub links in router-LSAs";
          type empty;
        }
        choice external-lsa-choice {
          container external-lsa-container {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf external-lsa {
              type uint32 {
                tailf:info "<1-16777215>;;Overriding metric in "+
                  "external-LSAs (default 16711680)";
                range "1..16777215";
              }
            }
          }
          leaf external-lsa {
            tailf:info "Override external-lsa metric with max-metric";
            type empty;
          }
        }
        choice summary-lsa-choice {
          container summary-lsa-container {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf summary-lsa {
              type uint32 {
                tailf:info "<1-16777215>;;Overriding metric in "+
                  "summary-LSAs (default 16711680)";
                range "1..16777215";
              }
            }
          }
          leaf summary-lsa {
            tailf:info "Override summary-lsa metric with max-metric value";
            type empty;
          }
        }
      }
    }
  }

  // router ospfv3 *
  // router ospfv3 * / vrf *
  grouping router-ospfv3-grouping {

    // router ospfv3 * / graceful-restart
    container graceful-restart {
      tailf:info "Enable Graceful-Restart";
      presence true;
    }

    // router ospfv3 * / ?
    uses router-ospf-common-grouping;

    // router ospfv3 * / address-family ipv6
    container address-family {
      tailf:info "OSPF address family";
      container ipv6 {
        tailf:info "IPV6 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
  }

  grouping router-isis-af-grouping {

    // router isis * / address-family ? unicast / metric
    leaf metric {
      tailf:info "Configure metric";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-16777214>;;Default metric: <1-63> "+
            "for narrow, <1-16777214> for wide";
          range "1..16777214";
        }
        type enumeration {
          enum maximum {
            tailf:info "Maximum wide metric. All routers will exclude "+
              "this link from their SPF";
          }
        }
      }
    }

    // router isis * / address-family ? unicast / metric * level *
    container metric-level {
      tailf:cli-drop-node-name;
      list metric {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          tailf:info "Set metric for one level only";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Set metric at this level only";
            range "1..2";
          }
        }
        leaf "value" {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric: <1-63> "+
                "for narrow, <1-16777214> for wide";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum wide metric. All routers will exclude "+
                  "this link from their SPF";
              }
            }
          }
        }
      }
    }

    // router isis * / address-family ? unicast / metric-style
    container metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      leaf wide {
        tailf:info "Use new style of TLVs to carry wider metric";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router isis * / address-family ? unicast / spf-interval
    container spf-interval {
      tailf:info "Route calculation scheduling parameters "+
        " (FSPF, ISPF, PRC)";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf maximum-wait {
        tailf:info "Maximum delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf initial-wait {
        tailf:info "Initial delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf secondary-wait {
        tailf:info "Secondary delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
    }

    // router isis * / address-family ? unicast / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf external {
          tailf:info "Originate default prefix as an external route";
          type empty;
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router isis * / address-family ? unicast / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum number of active parallel paths per route";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    // router isis * / address-family ? unicast / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          type empty;
        }
        // router isis * / address-family ? unicast / mpls ldp sync
        container sync {
          tailf:info "Configure LDP ISIS synchronization";
          presence true;
        }
      }
      container traffic-eng {
        tailf:info "Routing protocol commands for MPLS Traffic "+
          "Engineering";
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Enable mpls traffic-eng at level 1";
            }
            enum level-1-2 {
              tailf:info "Enable mpls traffic-eng at both level 1 and 2";
            }
            enum level-2-only {
              tailf:info "Enable mpls traffic-eng at level 2";
            }
          }
        }
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          tailf:cli-diff-dependency "/cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
    }

    // router isis * / interface * / address-family ? unicast / propagate level
    container propagate {
      tailf:info "Propagate routes between IS-IS levels";
      list level {
        tailf:info "Source level";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key "from level";
        leaf from {
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf into {
          tailf:info "into";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type empty;
        }
        leaf level {
          tailf:info "Destination level";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf route-policy {
          tailf:info "Propagate only specified routes";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router isis * / interface * / address-family ? unicast / tag
    leaf tag {
      tailf:info "Set interface tag";
      type uint32 {
        tailf:info "<1-4294967295>;;Interface tag";
      }
    }

    // router isis * / address-family ? unicast / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }
    }
  }

  // router-isis-address-family-grouping
  grouping router-isis-address-family-grouping {

    // router isis * / address-family ipv4 unicast
    // router isis * / interface * / address-family ipv4 unicast
    container ipv4 {
      tailf:info "IPV4 address family";
      container unicast {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-isis-af";
        presence true;
        uses router-isis-af-grouping;
      }
    }
    // router isis * / address-family ipv6 unicast
    // router isis * / interface * / address-family ipv6 unicast
    container ipv6 {
      container unicast {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-isis-af";
        presence true;
        uses router-isis-af-grouping;
      }
    }
  }

  // vty-pool-grouping
  grouping vty-pool-grouping {
    leaf first-vty {
      tailf:cli-drop-node-name;
      type uint16;
    }
    leaf last-vty {
      tailf:cli-drop-node-name;
      type uint16;
    }
    leaf line-template {
      tailf:cli-optional-in-sequence;
      type string;
    }
  }

  // line-grouping
  grouping line-grouping {

    // line * / flowcontrol hardware
    container flowcontrol {
      tailf:info "Configure flow control.";
      container hardware {
        tailf:info "Hardware flow control.";
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum in {
              tailf:info "Inbound flow control.";
            }
            enum none {
              tailf:info "No flow control.";
            }
            enum out {
              tailf:info "Outbound flow control.";
            }
          }
        }
      }
    }

    // line * / parity
    leaf parity {
      tailf:info "Set the parity used.";
      type enumeration {
        enum even {
          tailf:info "Even parity.";
        }
        enum none {
          tailf:info "No parity.";
        }
        enum odd {
          tailf:info "Odd parity.";
        }
      }
    }

    // line * / databits
    leaf databits {
      tailf:info "Set the number of databits.";
      type uint8 {
        tailf:info "<5-8>;;Number of databits the serial connection should use.";
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set the stopbits used.";
      type enumeration {
        enum "1" {
          tailf:info "One stopbit.";
        }
        enum "2" {
          tailf:info "Two stopbits.";
        }
      }
    }

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      leaf egress {
        tailf:info "Filter outgoing connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
      leaf ingress {
        tailf:info "Filter incoming connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
    }

    // line * / password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED password will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
        }
      }
    }

    // line * / accounting
    container accounting {
      tailf:info "Accounting parameters";
      tailf:cli-diff-dependency "/cisco-ios-xr:aaa/accounting";
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }

    }

    // line * / authorization
    container authorization {
      tailf:info "Authorization parameters";
      tailf:cli-diff-dependency "/cisco-ios-xr:aaa/authorization";
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }

    // line * / timeout
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeouts for any user input during login sequence";
          type uint16 {
            tailf:info "<0-300>;;Timeout in seconds (default 30 seconds)";
          }
        }
      }
    }

    // line * / timestamp
    container timestamp {
      tailf:info "To enable timestamp printing before each command.";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf disable {
        tailf:info "To disable timestamp printing before each command.";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";
      leaf-list "input" {
        tailf:info "Define which protocols to use when connecting to "+
          "the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            //tailf:info
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
        }
      }
      leaf-list "output" {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-full-command;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "Unix ssh protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf minutes {
        tailf:info "<0-35791>;;Timeout in minutes";
        tailf:cli-drop-node-name;
        type uint32;
      }
      leaf seconds {
        tailf:info "<0-2147483>;;Timeout in seconds";
        tailf:cli-drop-node-name;
        type uint32;
      }
    }

    // line * / length
    leaf "length" {
      tailf:info "Set number of lines on a screen.";
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing).";
      }
    }

    // line * / width
    leaf width {
      tailf:info "Set width of the display terminal.";
      type uint16 {
        tailf:info "<0-512>;;Number of characters on a screen line.";
      }
    }

    // line * / login
    container login {
      tailf:info "Enable password checking";
      tailf:cli-diff-dependency "/cisco-ios-xr:aaa/authentication";
      leaf authentication {
        tailf:info "Authentication parameters";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }

    // line * / session-limit
    leaf session-limit {
      tailf:info "Set the number of outgoing connections";
      type uint8 {
        tailf:info "<0-20>;;Number of outgoing connections";
        range "0..20";
      }
    }

    // line * / absolute-timeout
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection.";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes.";
        range "0..10000";
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no "+
        "input traffic";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf "output" {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }
  }

  // lpts-grouping
  grouping lpts-grouping {
    list flow {
      tailf:info "lpts flow type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;flow type";
        }
      }
      leaf ospf-type {
        when "../name = 'ospf'";
        tailf:cli-drop-node-name;
        type enumeration {
          enum multicast {
            tailf:info "Multicast";
          }
          enum unicast {
            tailf:info "Unicast";
          }
        }
      }
      leaf ldp-type {
        when "../name = 'ldp'";
        tailf:cli-drop-node-name;
        type enumeration {
          enum tcp {
            tailf:info "TCP";
          }
          enum udp {
            tailf:info "UDP";
          }
        }
      }
      leaf rsvp-type {
        when "../name = 'rsvp'";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum udp {
            tailf:info "UDP";
          }
        }
      }
      leaf raw-type {
        when "../name = 'raw'";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum listen {
            tailf:info "Listen";
          }
        }
      }
      leaf udp-tcp-type {
        when "../name = 'udp' or ../name = 'tcp'" {
          tailf:dependency "../name";
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum configured {
            tailf:info "Config peer";
          }
          enum listen {
            tailf:info "Listen";
          }
        }
      }
      leaf icmp-type {
        when "../name = 'icmp'";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum application {
            tailf:info "Specific application packets";
          }
          enum control {
            tailf:info "Control packets";
          }
          enum generic {
            tailf:info "Generic application packets";
          }
          enum local {
            tailf:info "Local interest packets";
          }
        }
      }
      leaf "which" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence; // not avail for all types
        tailf:cli-incomplete-command;
        type enumeration {
          enum "default" {
            tailf:info "Default";
          }
          enum known {
            tailf:info "Known";
          }
        }
      }
      leaf rate {
        tailf:info "Rate in PPS";
        type uint32 {
          tailf:info "<0-4294967295>;;Packets Per Second";
        }
      }
    }
  }

  grouping class-random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Minimum threshold";
        range "0..1073741823";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type police-burst-units-type;
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Maximum threshold";
        range "0..1073741823";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      type police-burst-units-type;
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {

    // class-map * / match access-group
    container access-group {
      tailf:info "Match access group";
      // class-map * / match access-group ipv4
      leaf ipv4 {
        tailf:info "IPv4 access list";
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
      }
      // class-map * / match access-group ipv6
      leaf ipv6 {
        tailf:info "IPv6 access list";
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
        }
      }
    }

    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }

    // class-map * / match cos
    container cos {
      tailf:info "Match based on IEEE 802.1Q/ISL Class Of Service value";
      leaf-list cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      // class-map * / match cos inner
      leaf-list inner {
        tailf:info "Match inner cos values (Upto 8 values)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }

    // class-map * / match destination-address
    container destination-address {
      tailf:info "Match based on destination address";
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }

    // class-map * / match discard-class
    leaf-list discard-class {
      tailf:info "Match based on discard class (upto 8 Ids)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;Discard Class Id";
        range "0..7";
      }
    }

    // class-map * / match dscp
    container dscp {
      tailf:info "Match based on IP DSCP value (upto 8 values or ranges)";
      // class-map * / match dscp *
      leaf-list dscp-list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
      // class-map * / match dscp ipv4 *
      leaf-list ipv4 {
        tailf:info "IPV4 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
      // class-map * / match dscp ipv6 *
      leaf-list ipv6 {
        tailf:info "IPV6 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
    }

    // class-map * / match fr-de
    container fr-de {
      tailf:info "Match on Frame-relay DE bit";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf fr-de-value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;FR DE value";
          }
        }
      }
    }

    // class-map * / match frame-relay
    container frame-relay {
      tailf:info "Match based on frame-relay specific criteria";
      leaf-list dlci {
        tailf:info "Match frame-relay dlci value(s)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<16-1007>;;DLCI number";
          range "16..1007";
        }
      }
    }

    // class-map * / match mpls
    container mpls {
      tailf:info "Match based on MPLS specific values";
      container experimental {
        tailf:info "Match MPLS experimental values";
        leaf-list topmost {
          tailf:info "Match topmost label (Upto 8 values)";
          tailf:cli-flat-list-syntax;
          type uint8 {
            tailf:info "<0-7>;;MPLS experimental topmost label";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match packet
    container packet {
      tailf:info "Layer 3 Packet length";
      container "length" {
        tailf:info "Layer 3 Packet length";
        leaf max {
          tailf:info "Maximum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
        leaf min {
          tailf:info "Minimum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
      }
    }

    // class-map * / match precedence
    leaf-list precedence {
      tailf:info "Match based on IP precedence values";
      tailf:cli-flat-list-syntax;
      type precedence-type;
    }

    // class-map * / match protocol
    container protocol {
      tailf:info "Match based on L3 protocol (Upto 8 values or ranges)";
      leaf aarp {
        tailf:info "AppleTalk ARP";
        type empty;
      }
      leaf appletalk {
        tailf:info "AppleTalk";
        type empty;
      }
      leaf arp {
        tailf:info "IP ARP";
        type empty;
      }
      leaf bgp {
        tailf:info "Border Gateway Protocol";
        type empty;
      }
      leaf bridge {
        tailf:info "Bridging";
        type empty;
      }
      leaf bstun {
        tailf:info "Block Serial Tunnel";
        type empty;
      }
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }
      container citrix {
        tailf:info "Citrix Systems ICA protocol";
        presence "enable citrix system protocol matching";
        leaf ica-tag {
          tailf:info "Citrix ICA tag 0-high 1-medium 2-low "+
            "3-background";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf clns {
        tailf:info "ISO CLNS";
        type empty;
      }
      leaf clns_es {
        tailf:info "ISO CLNS End System";
        type empty;
      }
      leaf clns_is {
        tailf:info "ISO CLNS Intermediate System";
        type empty;
      }
      leaf cmns {
        tailf:info "ISO CMNS";
        type empty;
      }
      leaf compressedtcp {
        tailf:info "Compressed TCP (VJ";
        type empty;
      }
      leaf cuseeme {
        tailf:info "CU-SeeMe desktop video conference";
        type empty;
      }
      leaf decnet {
        tailf:info "DECnet";
        type empty;
      }
      leaf decnet_node {
        tailf:info "DECnet Node";
        type empty;
      }
      leaf decnet_router-l1 {
        tailf:info "DECnet Router L1";
        type empty;
      }
      leaf decnet_router-l2 {
        tailf:info "DECnet Router L2";
        type empty;
      }
      leaf dhcp {
        tailf:info "Dynamic Host Configuration";
        type empty;
      }
      leaf dlsw {
        tailf:info "Data Link Switching (Direct encapsulation only";
        type empty;
      }
      leaf dns {
        tailf:info "Domain Name Server lookup";
        type empty;
      }
      leaf edonkey {
        tailf:info "eDonkey";
        type empty;
      }
      leaf egp {
        tailf:info "Exterior Gateway Protocol";
        type empty;
      }
      leaf eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol";
        type empty;
      }
      leaf exchange {
        tailf:info "MS-RPC for Exchange";
        type empty;
      }
      container fasttrack {
        tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster";
        presence "enable fasttrack matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf finger {
        tailf:info "Finger";
        type empty;
      }
      leaf ftp {
        tailf:info "File Transfer Protocol";
        type empty;
      }
      container gnutella {
        tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, "+
          "Morpheus";
        presence "enable gnutella matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf gopher {
        tailf:info "Gopher";
        type empty;
      }
      leaf gre {
        tailf:info "Generic Routing Encapsulation";
        type empty;
      }
      leaf h323 {
        tailf:info "H323 Protocol";
        type empty;
      }
      container http {
        tailf:info "World Wide Web traffic";
        presence "enable http traffic matching";
        leaf c-header-field {
          tailf:info "Client general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf host {
          tailf:info "Server Host Name";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf mime {
          tailf:info "Match MIME Type";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf s-header-field {
          tailf:info "Server general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf url {
          tailf:info "Match URL String";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf icmp {
        tailf:info "Internet Control Message";
        type empty;
      }
      leaf imap {
        tailf:info "Internet Message Access Protocol";
        type empty;
      }
      leaf ip {
        tailf:info "IP";
        type empty;
      }
      leaf ipv4 {
        tailf:info "Any IPv4 Protocol";
        type empty;
      }
      leaf ipinip {
        type empty;
        tailf:info "IP in IP (encapsulation";
      }
      leaf ipsec {
        type empty;
        tailf:info "IP Security Protocol (ESP/AH";
      }
      leaf ipv6 {
        tailf:info "Any IPv6 Protocol";
        type empty;
      }
      leaf ipx {
        tailf:info "Novell IPX";
        type empty;
      }
      leaf irc {
        tailf:info "Internet Relay Chat";
        type empty;
      }
      container kazaa2 {
        tailf:info "Kazaa Version 2";
        presence "enable kazaa version 2 matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf kerberos {
        tailf:info "Kerberos";
        type empty;
      }
      leaf l2tp {
        tailf:info "L2F/L2TP tunnel";
        type empty;
      }
      leaf ldap {
        tailf:info "Lightweight Directory Access Protocol";
        type empty;
      }
      leaf llc2 {
        tailf:info "llc2";
        type empty;
      }
      leaf mgcp {
        tailf:info "Media Gateway Control Protocol";
        type empty;
      }
      container napster {
        tailf:info "Napster Traffic";
        presence "enable napster matching";
        leaf non-std {
          tailf:info "Non-standard port advertizements";
          type empty;
        }
      }
      leaf netbios {
        tailf:info "NetBIOS";
        type empty;
      }
      leaf netshow {
        tailf:info "Microsoft Netshow";
        type empty;
      }
      leaf nfs {
        tailf:info "Network File System";
        type empty;
      }
      leaf nntp {
        tailf:info "Network News Transfer Protocol";
        type empty;
      }
      leaf notes {
        tailf:info "Lotus Notes(R";
        type empty;
      }
      leaf novadigm {
        tailf:info "Novadigm EDM";
        type empty;
      }
      leaf ntp {
        tailf:info "Network Time Protocol";
        type empty;
      }
      leaf ospf {
        tailf:info "Open Shortest Path First";
        type empty;
      }
      leaf pad {
        tailf:info "PAD links";
        type empty;
      }
      leaf pcanywhere {
        tailf:info "Symantec pcANYWHERE";
        type empty;
      }
      leaf pop3 {
        tailf:info "Post Office Protocol";
        type empty;
      }
      leaf pppoe {
        tailf:info "PPP over Ethernet";
        type empty;
      }
      leaf pptp {
        tailf:info "Point-to-Point Tunneling Protocol";
        type empty;
      }
      leaf printer {
        tailf:info "print spooler/lpd";
        type empty;
      }
      leaf qllc {
        tailf:info "qllc protocol";
        type empty;
      }
      leaf rcmd {
        tailf:info "BSD r-commands (rsh, rlogin, rexec";
        type empty;
      }
      leaf rip {
        tailf:info "Routing Information Protocol";
        type empty;
      }
      leaf rsrb {
        tailf:info "Remote Source-Route Bridging";
        type empty;
      }
      leaf rsvp {
        tailf:info "Resource Reservation Protocol";
        type empty;
      }
      leaf rtcp {
        tailf:info "Real Time Control Protocol";
        type empty;
      }
      container rtp {
        tailf:info "Real Time Protocol";
        presence "enable rtp matching";
        leaf audio {
          tailf:info "Match voice packets";
          type empty;
        }
        leaf payload-type {
          tailf:info "Match an explicit PT";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf video {
          tailf:info "Match video packets";
          type empty;
        }
      }
      leaf rtsp {
        type empty;
        tailf:info "Real Time Streaming Protocol";
      }
      leaf secure-ftp {
        type empty;
        tailf:info "FTP over TLS/SSL";
      }
      leaf secure-http {
        tailf:info "Secured HTTP";
        type empty;
      }
      leaf secure-imap {
        tailf:info "Internet Message Access Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-irc {
        tailf:info "Internet Relay Chat over TLS/SSL";
        type empty;
      }
      leaf secure-ldap {
        tailf:info "Lightweight Directory Access Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-nntp {
        tailf:info "Network News Transfer Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-pop3 {
        tailf:info "Post Office Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-telnet {
        tailf:info "Telnet over TLS/SSL";
        type empty;
      }
      leaf sip {
        tailf:info "Session Initiation Protocol";
        type empty;
      }
      leaf skinny {
        tailf:info "Skinny Protocol";
        type empty;
      }
      leaf smtp {
        tailf:info "Simple Mail Transfer Protocol";
        type empty;
      }
      leaf snapshot {
        tailf:info "Snapshot routing support";
        type empty;
      }
      leaf snmp {
        tailf:info "Simple Network Management Protocol";
        type empty;
      }
      leaf socks {
        tailf:info "SOCKS";
        type empty;
      }
      leaf sqlnet {
        tailf:info "SQL*NET for Oracle";
        type empty;
      }
      leaf sqlserver {
        tailf:info "MS SQL Server";
        type empty;
      }
      leaf ssh {
        tailf:info "Secured Shell";
        type empty;
      }
      leaf streamwork {
        tailf:info "Xing Technology StreamWorks player";
        type empty;
      }
      leaf stun {
        tailf:info "Serial Tunnel";
        type empty;
      }
      leaf sunrpc {
        tailf:info "Sun RPC";
        type empty;
      }
      leaf syslog {
        tailf:info "System Logging Utility";
        type empty;
      }
      leaf telnet {
        tailf:info "Telnet";
        type empty;
      }
      leaf tftp {
        tailf:info "Trivial File Transfer Protocol";
        type empty;
      }
      leaf vdolive {
        tailf:info "VDOLive streaming video";
        type empty;
      }
      leaf vofr {
        tailf:info "voice over Frame Relay packets";
        type empty;
      }
      leaf winmx {
        tailf:info "WinMx file-sharing application";
        type empty;
      }
      leaf xwindows {
        tailf:info "X-Windows remote access";
        type empty;
      }
    }

    // class-map * / match qos-group
    leaf-list qos-group {
      tailf:info "Match based on QoS Group (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-63>;;Qos Group Id";
        range "0..63";
      }
    }

    // class-map * / match source-address
    container source-address {
      tailf:info "Match based on source address";
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }

    // class-map * / match vlan
    container vlan {
      tailf:info "Match based on Vlan Ids (Upto 8 values or ranges)";
      // class-map * / match vlan *
      leaf-list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4092";
        }
      }
      // class-map * / match vlan inner *
      leaf-list inner {
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4092";
        }
      }
    }

  }


  // grouping interface-ipv6-nd-prefix-list-grouping
  grouping interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf valid-lifetime {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Valid Lifetime";
              }
            }
          }
        }
        leaf preferred-lifetime {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Preferred Lifetime (secs) "+
                "must be <= Valid Lifetime";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Preferred Lifetime";
              }
            }
          }
        }
      }
      //TODO: at - Expire prefix at a specific time/date
      leaf no-adv {
        tailf:info "Do not advertise prefix";
        tailf:cli-full-command;
        type empty;
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        leaf no-autoconfig {
          tailf:info "Do not use prefix for autoconfiguration";
          type empty;
        }
        leaf off-link {
          tailf:info "Do not use prefix for onlink determination";
          type empty;
        }
      }
    }
  }

  // grouping interface-ipv6-nd-grouping
  grouping interface-ipv6-nd-grouping {
    container nd {
      tailf:info "IPv6 interface Neighbor Discovery subcommands";
      leaf cache-limit {
        tailf:info "Set Cache Limit for neighbor entry";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-10000>;;Cache Limit";
          range "1..10000";
        }
      }
      container dad {
        tailf:info "Duplicate Address Detection";
        leaf attempts {
          tailf:info "Set IPv6 Duplicate Address Detection Transmits";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-600>;;Number of attempts";
            range "0..600";
          }
        }
      }
      leaf managed-config-flag {
        tailf:info "Hosts should use stateful protocol for address config";
        tailf:cli-full-command;
        type empty;
      }
      leaf ns-interval {
        tailf:info "Set advertised NS retransmission interval";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1000-4294967295>;;Retransmission interval in"
            +" milliseconds";
          range "1000..4294967295";
        }
      }
      leaf other-config-flag {
        tailf:info "Hosts should use stateful protocol for non-address config";
        tailf:cli-full-command;
        type empty;
      }
      container prefix {
        tailf:info "Configure IPv6 Routing Prefix Advertisement";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type ipv6-prefix {
              //FIXME: %zone
              tailf:info "X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
            }
          }
          uses interface-ipv6-nd-prefix-list-grouping;
        }
        container default {
          tailf:info "Specify prefix default parameters";
          uses interface-ipv6-nd-prefix-list-grouping;
        }
      }
      container ra {
        tailf:info "IPv6 interface ND RA subcommands";
        leaf hoplimit {
          tailf:info "IPv6 ND RA hoplimit";
          tailf:cli-full-command;
          type enumeration {
            enum "unspecified" {
              tailf:info "Unspecified IPv6 ND RA hop-limit value";
            }
          }
        }
        leaf mtu {
          tailf:info "IPv6 ND RA mtu option configuration";
          tailf:cli-full-command;
          type enumeration {
            enum "unspecified" {
              tailf:info "Unspecified IPv6 ND RA hop-limit value";
            }
          }
        }
      }
      leaf ra-interval {
        tailf:info "Set IPv6 Router Advertisement Interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<4-1800>;;Maximum RA Interval (sec)";
          range "4..1800";
        }
      }
      leaf ra-lifetime {
        tailf:info "Set IPv6 Router Advertisement Lifetime";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-9000>;;RA Lifetime (seconds)";
          range "0..9000";
        }
      }
      leaf reachable-time {
        tailf:info "Set advertised reachability time";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-3600000>;;Reachability time in milliseconds";
          range "0..3600000";
        }
      }
      leaf redirects {
        tailf:info "Enable sending of ICMP Redirect messages";
        tailf:cli-full-command;
        type empty;
      }
      leaf suppress-ra {
        tailf:info "Suppress IPv6 Router Advertisements";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  // grouping interface-service-policy-grouping
  grouping interface-service-policy-grouping  {
    container service-policy {
      tailf:info "Configure QoS Service Policy";
      // interface * / service-policy input
      list "input" {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
        }
        leaf shared-policy-instance {
          tailf:info "Configure a shared-policy-instance";
          type string {
            tailf:info "WORD;;Name of the shared-policy-instance";
          }
        }
      }
      // interface * / service-policy output
      list "output" {
        tailf:info "direction of service policy application";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
        }
        leaf shared-policy-instance {
          tailf:info "Configure a shared-policy-instance";
          type string {
            tailf:info "WORD;;Name of the shared-policy-instance";
          }
        }
      }
      // interface * / service-policy type
      container "type" {
        tailf:info "Enter service policy type (default: qos)";
        container lan-queuing {
          tailf:info "Configure Lan Queuing Policy Map";
          leaf "input" {
            tailf:info "Assign policy-map to the input of an interface";
            type string;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "output" {
            tailf:info "Assign policy-map to the output of an interface";
            type string;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
        }
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          leaf "input" {
            tailf:info "Assign policy-map to the input of an interface";
            type string;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "output" {
            tailf:info "Assign policy-map to the output of an interface";
            type string;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container test {
          tailf:info "Configure Test Policy Map";
          leaf "input" {
            tailf:info "Assign policy-map to the input of an interface";
            type string;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "inline" {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
      }
    }
  }

  // grouping interface-isis-grouping
  grouping interface-isis-grouping {
    // interface * / isis
    container isis {
      tailf:info "IS-IS commands";
      // interface * / isis authentication
      container authentication {
        tailf:info "ISIS authentication for interface related PDUs";
        // interface * / isis authentication mode
        container mode {
          tailf:info "Authentication mode for PDUs";
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-compact-syntax;
          leaf crypt {
            tailf:cli-drop-node-name;
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text password";
              }
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
        // interface * / isis authentication key-chain
        leaf key-chain {
          tailf:info "Authentication key-chain";
          type string {
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:key/chain/name";
          }
        }
        // interface * / isis authentication send-only
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
      }
      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        tailf:cli-reset-container;
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }
      // interface * / isis hello
      container hello {
        tailf:info "Add padding to IS-IS hello packets";
        leaf padding {
          tailf:info "Pad hello packets";
          type empty;
        }
      }
      // interface * / isis metric
      container metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf metric {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum metric. All routers will exclude "
                  +"this link from their SPF";
              }
            }
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Delay metric";
              range "1..16777214";
            }
          }
        }
        leaf expense {
          when "../delay != 'level-1' and ../delay != 'level-2'" {
            tailf:dependency "../delay";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Expense metric";
              range "1..16777214";
            }
          }
        }
        leaf error {
          when "../delay != 'level-1' and ../delay != 'level-2' "
            +"and ../expense != 'level-1' and ../expense != 'level-2'" {
            tailf:dependency "../delay";
            tailf:dependency "../expense";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Error metric";
              range "1..16777214";
            }
          }
        }
        leaf rest {
          when "../delay != 'level-1' and ../delay != 'level-2' "
            +"and ../expense != 'level-1' and ../expense != 'level-2'"
            +"and ../error != 'level-1' and ../error != 'level-2'" {
            tailf:dependency "../delay";
            tailf:dependency "../expense";
            tailf:dependency "../error";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }
    }
  }

  // grouping interface-switch-grouping
  grouping interface-switch-grouping {

    // interface * / channel-protocol
    container channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / switch
    container "switch" {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;core switch number";
            range "1..2";
          }
        }
      }
    }

    // interface * / no switchport
    container switchport-conf {
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:cli-boolean-no;
        type boolean;
        //default true;
      }
    }

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-no;
      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          tailf:cli-diff-dependency "/cisco-ios-xr:vlan/vlan-list";
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is "
              +"in access mode";
            range "1..4094";
          }
        }
      }
      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }
      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          leaf access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            type empty;
          }
          leaf dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            type empty;
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate "+
              "access or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation "+
                  "parameter to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation "+
                  "parameter to DESIRABLE";
              }
            }
          }
          leaf trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            type empty;
          }
        }
      }
      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation "
          +"protocol on this interface";
        type empty;
      }
      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is "
            +"in trunking mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking "
              +"mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics "
            +"when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                  +"this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }

        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in"
            +" trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in "
              +"trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU guard for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum disable {
            tailf:info "Disable portfast for this interface";
          }
          enum edge {
            tailf:info "Enable portfast edge on the interface";
          }
          enum network {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
    }

  }

  // grouping interface-bundle-grouping
  grouping interface-bundle-grouping {

    // interface * / bundle
    container bundle {
      tailf:info "Bundle interface commands";
      leaf wait-while {
        tailf:info "Set the wait-while timeout for members of this bundle";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-2000>;;Wait-while timeout in milliseconds "+
            "(default: 2000)";
          range "0..2000";
        }
      }
      container maximum-active {
        tailf:info "Set a limit on the number of links that can be active";
        container links {
          tailf:info "Set the number of active links needed to bring up "+
            "this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of active links needed to bring "+
                "up this bundle";
              range "1..64";
            }
          }
          leaf hot-standby {
            tailf:info "Hot-standby behaviour (non-standard, only "+
              "effective on links with LACP enabled)";
            type empty;
          }
        }
      }
      container minimum-active {
        tailf:info "Set the minimum criteria for the bundle to be active";
        leaf links {
          tailf:info "Set the number of active links needed to bring up "+
            "this bundle";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;Number of active links needed to bring up "+
              "this bundle";
          }
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "Bundle interface LACP commands";
      container switchover {
        tailf:info "Modify behavior for switching between links in this "+
          "bundle";
        leaf suppress-flaps {
          tailf:info "Set the time for which to suppress flaps during a "+
            "LACP switchover";
          type uint16 {
            tailf:info "<100-65535>;;The longest down flap which "+
              "should be suppressed (milliseconds)";
            range "100..65535";
          }
        }
      }
    }

    // interface * / mlacp
    container mlacp {
      tailf:info "Multi-chassis LACP per-interface commands";
      leaf iccp-group {
        tailf:info "ICCP redundancy group related commands for this bundle.";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;The ICCP redundancy group in which "+
            "this bundle should operate.";
          range "1..4294967295";
        }
      }
      leaf port-priority {
        tailf:info "Set the priority for all member links on this device "+
          "when running mLACP.";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority for member ports. Lower value "+
            "is higher priority.";
          range "1..65535";
        }
      }
      container switchover {
        tailf:info "Set the parameters for performing a switchover "+
          "to/from the mLACP peer";
        container maximize {
          tailf:info "Parameters for switchover behavior to maximize "+
            "operational links/bandwidth";
          container links {
            tailf:info "Compare the number of operational links";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf threshold {
              tailf:info "Set the threshold below which to switch to the "+
                "peer if it has more links available";
              type uint8 {
                tailf:info "<1-64>;;The number of links below which to "+
                  "switch to the peer if it has more links available";
                range "1..64";
              }
            }
          }
        }
        leaf recovery-delay {
          tailf:info "Specify delay before bundle becoming active after "+
            "recovery from failure";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Recovery delay in seconds.";
          }
        }
        leaf "type" {
          tailf:info "Set the type of switchover operation to use";
          tailf:cli-full-command;
          type enumeration {
            enum brute-force {
              tailf:info "Force switchover by disabling all local member "+
                "links";
            }
            enum revertive {
              tailf:info "Revert based on configured priority values";
            }
          }
        }
      }
    }
  }

  // grouping interface-non-bundle-grouping
  grouping interface-non-bundle-grouping {
    // interface * / bundle
    container bundle {
      tailf:info "Link aggregation per-interface commands";
      // interface * / bundle id
      container id {
        tailf:info "Add the port to an aggregated interface.";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf id-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Identifier of the bundle to add the "+
              "port to.";
          }
        }
        leaf mode {
          tailf:info "Specify the mode of operation.";
          type enumeration {
            enum active {
              tailf:info "Run LACP in active mode over the port.";
            }
            enum on {
              tailf:info "Do not run LACP over the port.";
            }
            enum passive {
              tailf:info "Run LACP in passive mode over the port.";
            }
          }
        }
      }
      // interface * / bundle port-priority
      leaf port-priority {
        tailf:info "Priority for this port. Lower value is higher priority.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this port. "+
            "Lower value is higher priority.";
          range "1..65535";
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "Link Aggregation Control Protocol per-interface commands";
      container period {
        tailf:info "Configure the rate at which packets are sent or received";
        leaf period-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "Specify the requested transmission period "+
              "(in milliseconds) for the partner system "+
              "(must be multiple of 100; default 1000)";
            range "100..1000";
          }
        }
        container short {
          tailf:info "Configure usage of the LACP short interval";
          tailf:cli-delete-when-empty;
          presence true;
        }
      }
    }
  }

  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {
    // interface * / keepalive
    container keepalive {
      choice keepalive-choice {
        container values {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-30>;; Enable keepalives with this interval "+
                "(default is 10 seconds)";
              range "1..30";
            }
          }
          leaf retry {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Set the keepalive retry count "+
                "(default is 3 for HDLC, 5 for PPP)";
              range "1..255";
            }
          }
        }
        leaf disable {
          tailf:info "Disable keepalives";
          type empty;
        }
      }
    }
  }

  // grouping interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Set the carrier delay on an interface";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Set the carrier delay up value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
      leaf down {
        tailf:info "Set the carrier delay down value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operational mode";
      tailf:cli-full-command;
      type enumeration {
        enum full {
          tailf:info "Full duplex";
          tailf:code-name "duplex_full";
        }
        enum half {
          tailf:info "Half duplex";
          tailf:code-name "duplex_half";
        }
      }
    }

    //  interface * / ethernet
    container ethernet {
      tailf:info "Ethernet per-interface configuration commands";
      container udld {
        tailf:info "Enable the UniDirectional Link Detection protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-udld";
        leaf mode {
          tailf:info "Set the mode in which to run the UDLD protocol";
          tailf:cli-full-command;
          type enumeration {
            enum aggressive {
              tailf:info "Run UDLD in aggressive mode";
            }
            enum normal {
              tailf:info "Run UDLD in normal mode";
            }
          }
        }
      }
    }

    //  interface * / ethernet-services
    container ethernet-services {
      tailf:info "Ethernet related services";
      //  interface * / ethernet-services access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Access-list name";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ethernet-services/access-list/name";
          }
        }
      }
    }

    //  interface * / mac-address
    leaf mac-address {
      tailf:info "Set the Mac address(xxxx.xxxx.xxxx) on an interface";
      type string {
        pattern "[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+";
      }
    }

    // interface * / speed
    leaf speed {
      tailf:info "Set the ethernet speed on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum "10" {
          tailf:info "Ethernet is 10Mb";
        }
        enum "100" {
          tailf:info "Ethernet is 100Mb";
        }
        enum "1000" {
          tailf:info "Ethernet is 1Gb";
        }
      }
    }

    //  interface * / transceiver
    container transceiver {
      tailf:info "transceiver commands";
      container permit {
        tailf:info "permit";
        container pid {
          tailf:info "Permit pluggable pid (Product ID) all";
          leaf all {
            tailf:info "all";
            type empty;
          }
        }
      }
    }

    //  interface * / nv
    container nv {
      tailf:info "Network Virtualisation interface configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-nV";
      container satellite-fabric-link {
        tailf:info "Satellite Fabric Link configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-satellite-fabric-link";
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands;
        leaf satellite {
          tailf:info "Satellite ID";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }
        container remote-ports {
          tailf:cli-break-sequence-commands;
          tailf:info "Remote ports configuration";
          leaf GigabitEthernet {
            tailf:info "Remote ports type";
            type string {
              tailf:info "Slot/Subslot/Port(s)";
            }
          }
        }
      }
    }
  }

  // grouping interface-common-grouping
  grouping interface-common-grouping {

    // interface * / description
    leaf "description" {
      tailf:info "Set description for this interface";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this interface";
      }
    }

    // interface * / bandwidth
    leaf bandwidth {
      tailf:info "Set the bandwidth of an interface";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;bandwidth in kbps";
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the MTU on an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;MTU size in bytes";
        range "64..65535";
      }
    }

    // interface * / negotiation auto
    container negotiation {
      tailf:info "Select autonegotiation mode";
      container auto {
        tailf:info "Perform link autonegotiation";
        tailf:cli-delete-when-empty;
        presence true;
        leaf allow-overrides {
          tailf:info "Allow configured values to override negotiated settings";
          type empty;
        }
      }
    }

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set the encapsulation on an (sub)interface";
      choice encapsulation-choice {
        // interface * / encapsulation frame-relay
        container frame-relay {
          tailf:info "Frame Relay networks";
          tailf:cli-delete-when-empty;
          presence true;
          leaf IETF {
            tailf:info "Use RFC1490/RFC2427 encapsulation";
            type empty;
          }
        }
        // interface * / encapsulation hdlc
        leaf hdlc {
          tailf:info "Serial HDLC synchronous";
          tailf:cli-full-command;
          type empty;
        }
        // interface * / encapsulation mfr
        leaf mfr {
          tailf:info "Multilink Frame Relay Member Link";
          tailf:cli-full-command;
          type empty;
        }
        // interface * / encapsulation ppp
        leaf ppp {
          tailf:info "Point-to-Point protocol";
          tailf:cli-full-command;
          type empty;
        }
        // interface * / encapsulation default
        leaf "default" {
          tailf:info "Packets unmatched by other service instances";
          type empty;
        }
        // interface * / encapsulation untagged
        container untagged {
          tailf:info "Packets with no explicit VLAN tag";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          // +ingress
        }
        // interface * / encapsulation dot1q
        container dot1q {
          tailf:info "IEEE 802.1Q VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf vlan-id {
            tailf:cli-drop-node-name;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string {
                // VLAN range
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf second-dot1q {
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string {
                // VLAN range
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          container ingress {
            tailf:info "Perform MAC-based matching";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            leaf source-mac {
              tailf:info "Perform source MAC-based matching";
              type string {
                tailf:info "H.H.H;;MAC Address";
              }
            }
          }
        }
        // interface * / encapsulation dot1ad
        container dot1ad {
          tailf:info "IEEE 802.1ad VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf vlan-id {
            tailf:cli-drop-node-name;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string {
                // VLAN range
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type string {
                // VLAN range
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
        }
      }
    }

    // interface * / frame-relay
    container frame-relay {
      tailf:info "Frame Relay interface configuration commands";
      container lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI to select type";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum ansi {
              tailf:info "Use ANSI type LMI";
            }
            enum cisco {
              tailf:info "Use CISCO type LMI";
            }
            enum q933a {
              tailf:info "Use CCITT type LMI";
            }
          }
        }
      }
      container intf-type {
        tailf:info "Use DTE/DCE mode for LMI";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum dce {}
          }
        }
      }
    }

    // interface * / frequency synchronization
    container frequency {
      tailf:info "Frequency Synchronization configuration";

      // interface * / frequency synchronization
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-freqsync";

        // interface * / frequency synchronization / selection
        container selection {
          tailf:info "Selection configuration commands";
          leaf "input" {
            tailf:info "Enable this source for selection";
            type empty;
          }
        }

        // interface * / frequency synchronization / priority
        leaf priority {
          tailf:info "Source priority";
          type uint8 {
            tailf:info "<1-254>;;Source priority";
            range "1..254";
          }
        }

        // interface * / frequency synchronization / wait-to-restore
        leaf wait-to-restore {
          tailf:info "Set the wait-to-restore time";
          type uint8 {
            tailf:info "<0-12>;;Wait-to-restore time, in minutes";
            range "0..12";
          }
        }

        // interface * / frequency synchronization / quality
        container quality {
          tailf:info "Quality level configuration";
          container receive {
            tailf:info "Adjust the received quality level";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-freqsync-quality-grouping;
          }
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-freqsync-quality-grouping;
          }
        }
      }
    }

    // interface * / service-policy
    uses interface-service-policy-grouping;

    // interface * / vrf
    leaf vrf {
      tailf:info "Set VRF in which the interface operates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
      type vrf-type;
    }

    // interface * / ipv4
    container ipv4 {
      tailf:info "IPv4 interface subcommands";

      // interface * / ipv4 point-to-point
      leaf point-to-point {
        tailf:info "Enable point-to-point handling for this interface.";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ipv4 address
      choice address-choice {
        case no {
          // interface * / no ipv4 address
          container no-address {
            tailf:cli-drop-node-name;
            leaf address {
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
        case yes {
          // interface * / ipv4 address [mask]
          container address {
            tailf:info "Set the IPv4 address of an interface";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP subnet mask";
              }
            }
          }
          // interface * / ipv4 address [mask] secondary
          container address-secondary-list {
            tailf:cli-drop-node-name;
            list address {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "ip secondary";
              leaf ip {
                type string {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
              leaf secondary {
                type enumeration {
                  enum secondary {
                    tailf:info "Make this IPv4 address a secondary address";
                  }
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP subnet mask";
                }
              }
            }
          }
        }
      }

      // interface * / ipv4 access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;access-list name";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
          }
        }
      }

      // interface * / ipv4 helper-address
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        choice helper-address-choice {
          leaf local {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          container vrf {
            tailf:info "VRF name for helper-address (if different from"
              +" interface VRF)";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP destination address";
              }
            }
          }
        }
      }

      // interface * / ipv4  directed-broadcast
      leaf directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        type empty;
      }

      // interface * / ipv4 mtu
      leaf mtu {
        tailf:info "Set IPv4 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-65535>;;MTU (bytes)";
          range "68..65535";
        }
      }

      // interface * / ipv4 pim
      container pim {
        tailf:info "PIM interface commands";
        leaf bidir-neighbor-filter {
          tailf:info "PIM bidir capable peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference"
              +" given to larger value";
            range "0..4294967294";
          }
        }
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode"
            +" on interface";
          type empty;
        }
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        container query-interval {
          tailf:info "PIM router query interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice interval-choice {
            case secs {
              leaf secs {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or"
                    +" milliseconds";
                  range "1..65535";
                }
              }
            }
            case msec {
              leaf msecs {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or"
                    +" milliseconds";
                  range "100..65535";
                }
                must "../msec";
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            tailf:info "Enable PIM sparse-dense-mode operation";
            type empty;
          }
          container dense-mode {
            tailf:cli-reset-container;
            tailf:info "Enable PIM dense-mode operation";
            presence true;
            container proxy-register {
              tailf:cli-reset-container;
              tailf:info "Send proxy registers";
              choice proxy-mode {
                leaf "list" {
                  tailf:info "Access list";
                  type union {
                    type uint16 {
                      tailf:info "<100-199>;;Extended access list number";
                      range "100..199";
                    }
                    type uint16 {
                      tailf:info "<2000-2699>;;Extended access list "
                        +"number (expanded range)";
                      range "2000..2699";
                    }
                    type string {
                      tailf:info "WORD;;IP named extended access list";
                    }

                  }
                }
                leaf route-map {
                  tailf:info "Route-map";
                  type string {
                    tailf:info "WORD;;Route-map reference";
                  }
                }
              }
            }
          }
          leaf sparse-mode {
            tailf:info "Enable PIM sparse-mode operation";
            type empty;
          }
        }
        container state-refresh {
          tailf:info "PIM DM State-Refresh configuration";
          container origination-interval {
            tailf:info "PIM State-Refresh origination interval";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf secs {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Interval in seconds";
                range "1..100";
              }
            }
          }
        }
      }

      // interface * / ipv4 verify
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          // interface * / ipv4 verify unicast notification
          container "notification" {
            tailf:info "drop-rate notify";
            leaf threshold {
              tailf:info "Urpf NOTIFY drop rate threshold";
              type uint32 {
                tailf:info "<0-4294967295>;;Drop rate in pps triggering"
                  +" notify - 0 is any drops";
                range "0..4294967295";
              }
            }
          }
          // interface * / ipv4 verify unicast source
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the "
                +"source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which"
                    +" packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability "+
                "in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking "+
                "source address";
              type empty;
            }
          }
        }
      }

      // interface * / ipv4 router
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          presence true;
          tailf:cli-reset-container;
          leaf routing-process {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ipv4 unnumbered
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        uses interface-name-grouping;
      }

      // interface * / ipv4 unreachables
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }

    // interface * / proxy-arp
    leaf proxy-arp {
      tailf:info "Enable proxy ARP";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";
      // interface * / ipv6 access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;access-list name";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
          }
        }
      }
      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-compact-syntax;
          key "prefix";
          leaf prefix {
            type ipv6-prefix {
              tailf:info "X:X::X/length;;IPv6 prefix";
            }
          }
          leaf eui-64 {
            tailf:info "Use eui-64 interface identifier";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf route-tag {
            tailf:info "Route-tag to be associated with this address";
            type uint32 {
              tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
              range "1..4294967295";
            }
          }
        }
      }
      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-full-command;
        type empty;
      }
      // interface * / ipv6 nd
      uses interface-ipv6-nd-grouping;
      // interface * / ipv6 verify
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container source {
            tailf:info "Validation of source address";
            tailf:cli-sequence-commands;
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the"
                +" source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on "+
                    "which packet was received";
                }
              }
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking "+
                "source address";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself "+
                "(opens vulnerability in verification)";
              type empty;
            }
          }
        }
      }
    }

    // interface * / lldp
    container lldp {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-lldp";
      // interface * / lldp / receive disable
      container receive {
        tailf:info "Disable LLDP RX on an interface";
        leaf disable {
          tailf:info "Disable LLDP RX on an interface";
          type empty;
        }
      }
      // interface * / lldp / transmit disable
      container transmit {
        tailf:info "Disable LLDP TX on an interface";
        leaf disable {
          tailf:info "Disable LLDP TX on an interface";
          type empty;
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "MPLS interface subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-mpls";
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }
      container label-security {
        tailf:info "MPLS label-security for the interface";
        leaf rpf {
          tailf:info "MPLS RPF for incoming packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf multi-label-packet {
          tailf:info "Handling incoming packets with multiple labels on the "
            +"stack";
          tailf:cli-full-command;
          type enumeration {
            enum drop {
              tailf:info "Drop packets with multiple labels on the stack";
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Set the MPLS MTU for the interface";
        type uint16 {
          tailf:info "<68-65535>;;MTU size in bytes";
          range "68..65535";
        }
      }
    }

    // interface * / shutdown
    leaf shutdown {
      tailf:info "shutdown the given interface";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / isis
    uses interface-isis-grouping;

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;Number of seconds";
        range "0..600" {
          tailf:step 30;
        }
      }
    }

    // interface * / transport-mode
    container transport-mode {
      tailf:info "Set the transport mode on an interface";
      choice transport-mode-choice {
        leaf wan {
          tailf:info "10GBASE-W WAN SONET/SDH (9.95328Gb/s)";
          type empty;
        }
        container otn {
          tailf:info "10GE over Optical Transport Network (G.709)";
          leaf bit-transparent {
            tailf:info "10GBASE-R transparently mapped into OTU-2";
            type enumeration {
              enum opu1e {
                tailf:info "10GBASE-R over OPU1e without fixed stuffing "+
                  "(11.0491Gb/s)";
              }
              enum opu2e {
                tailf:info "10GBASE-R over OPU2e with fixed stuffing "+
                  "(11.0957Gb/s)";
              }
            }
          }
        }
        leaf rx-only {
          tailf:info "10GE UDLR Mode, Receive Only";
          type empty;
        }
        leaf tx-only {
          tailf:info "10GE UDLR Mode, Transmit Only";
          type empty;
        }
      }
    }

    // interface * / flow
    // flow [ ipv4 | ipv6 | mpls ] monitor name sampler name { egress | ingress }
    list flow {
      tailf:info "Netflow configuration";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      key "proto monitor direction";
      leaf proto {
        type enumeration {
          enum ipv4 {
            tailf:info "IPV4 netflow configuration";
          }
          enum ipv6 {
            tailf:info "IPV6 netflow configuration";
          }
          enum mpls {
            tailf:info "MPLS netflow configuration";
          }
        }
      }
      leaf monitor {
        tailf:info "Specify a flow monitor for packets";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Flow monitor map name";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:flow/monitor-map/name";
        }
      }
      leaf sampler {
        tailf:info "Specify a sampler for packets";
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type string {
          tailf:info "WORD;;Sampler map name";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:sampler-map/name";
        }
      }
      leaf direction {
        type enumeration {
          enum egress {
            tailf:info "Apply flow monitor on outgoing packets";
          }
          enum ingress {
            tailf:info "Apply flow monitor on incoming packets";
          }
        }
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "configure state dampening on the given interface";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence true;
      leaf half-life {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-45>;;Decay half life (in minutes)";
          range "1..45";
        }
      }
      leaf reuse {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Reuse threshold";
          range "1..20000";
        }
      }
      leaf suppress {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-20000>;;Suppress threshold";
          range "1..20000";
        }
      }
      leaf max-suppress-time {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Max suppress time (in minutes)";
          range "1..255";
        }
      }
    }

    // interface * / logging
    container logging {
      tailf:info "Configure logging for interface";
      container events {
        tailf:info "Interface events";
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          type empty;
        }
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          type empty;
        }
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          type empty;
        }
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf status {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }
        container subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          presence true;
          leaf ignore-bulk {
            tailf:info "Do not log messages when the main interface is"
              +" transitioning";
            type empty;
          }
        }
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          type empty;
        }
        // interface * / logging events lsp-status
        container lsp-status {
          tailf:info "Enable interface LSP state change alarms";
          leaf reoptimize {
            tailf:info "Enable interface LSP REOPT change alarms";
            type empty;
          }
          leaf state {
            tailf:info "Enable interface LSP UP/DOWN change alarms";
            type empty;
          }
          leaf reroute {
            tailf:info "Enable interface LSP REROUTE change alarms";
            type empty;
          }
          leaf insufficient-bandwidth {
            tailf:info "Enable Syslog for setup/reopt failure due to "+
              "bandwidth";
            type empty;
          }
        }
      }
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info "Access-list";
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }
      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }
    }

  }

  // grouping subinterface-common-grouping
  grouping subinterface-common-grouping {

    // interface * / rewrite
    container rewrite {
      tailf:info "Set the tag rewriting policy for this EFP";
      container ingress {
        tailf:info "Set the tag rewriting policy for this EFP";
        container tag {
          tailf:info "Set the tag rewriting policy for this EFP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }

          choice tag-choice {
            // interface * / rewrite ingress tag pop
            leaf pop {
              tailf:info "Remove one or more tags";
              type enumeration {
                enum "1" {
                  tailf:info "Remove outer tag only";
                }
                enum "2" {
                  tailf:info "Remove two outermost tags";
                }
              }
            }
            // interface * / rewrite ingress tag push
            leaf push {
              tailf:info "Push one or more tags";
              tailf:cli-incomplete-command;
              type empty;
            }
            // interface * / rewrite ingress tag translate
            leaf translate {
              tailf:info "Replace tags with other tags";
              tailf:cli-incomplete-command;
              type enumeration {
                enum "1-to-1" {
                  tailf:info "Replace the outermost tag with another tag";
                }
                enum "1-to-2" {
                  tailf:info "Replace the outermost tag with two tags";
                }
                enum "2-to-1" {
                  tailf:info "Replace the outermost two tags with one tag";
                }
                enum "2-to-2" {
                  tailf:info "Replace the outermost two tags with two "+
                    "other tags";
                }
              }
            }
          }

          leaf dot1ad {
            when "not(../pop)" {
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1ad tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf dot1q {
            when "not(../pop)" {
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf second-dot1q {
            when "(../dot1q and not(../dot1ad))" {
              tailf:dependency "../dot1ad";
              tailf:dependency "../dot1q";
            }
            tailf:info "Push another Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }

          // [symmetric]
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum symmetric {
                tailf:info "All rewrites must be symmetric";
              }
            }
          }
        }
      }
    }

    // interface * / monitor-session *
    list monitor-session {
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name "config-if-mon";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session Name";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:monitor-session/name";
        }
      }
      // interface * / monitor-session * direction
      leaf direction {
        tailf:info "Specify the direction of traffic to replicate";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum rx-only {
            tailf:info "Replicate only received (ingress) traffic";
          }
          enum tx-only {
            tailf:info "Replicate only transmitted (egress) traffic";
          }
        }
      }

      // interface * / monitor-session * / acl
      leaf acl {
        tailf:info "Enable acl based mirroring";
        type empty;
      }
    }

    // interface * / dot1q
    container dot1q {
      leaf vlan {
        type uint16 {
          tailf:info "<1-4094>;;VLAN ID";
          range "1..4094";
        }
      }
    }

    // interface * / l2protocol
    container l2protocol {
      tailf:info "Layer 2 protocol handling";
      leaf cpsv {
        tailf:info "CDP, PVST+, STP, and VTP protocols";
        tailf:cli-full-command;
        type enumeration {
          enum drop {
            tailf:info "Drop these protocol packets";
          }
          enum reverse-tunnel {
            tailf:info "Tunnel at egress";
          }
          enum tunnel {
            tailf:info "Tunnel at ingress";
          }
        }
      }
    }

    // interface * / pvc
    list pvc {
      tailf:info "Configure a pvc on this interface";
      key dlci;
      leaf dlci {
        type uint16 {
          tailf:info "<16-1007>;;DLCI Number";
        }
      }
      leaf encap {
        tailf:info "Set the Encapsulation of this PVC";
        type enumeration {
          enum cisco {
            tailf:info "Use Cisco encapsulation for this PVC";
          }
          enum ietf {
            tailf:info "Use RFC1490/RFC2427 encapsulation for this PVC";
          }
        }
      }
    }
  }

  // grouping non-subinterface-common-grouping
  grouping non-subinterface-common-grouping {

    // interface * / backup
    container backup {
      tailf:info "Modify backup parameters";
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";
      // interface * / bfd address-family
      container address-family {
        tailf:info "Set configuration for a given address family";
        container ipv4 {
          tailf:info "Set configuration for the IPv4 address family";
          // interface * / bfd address-family timers
          container timers {
            tailf:info "Set the timers that determine when a BFD session "+
              "defaults to down";
            // interface * / bfd address-family timers start
            leaf start {
              tailf:info "The time since starting a BFD session before it "+
                "is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
            // interface * / bfd address-family timers nbr-unconfig
            leaf nbr-unconfig {
              tailf:info "The time since a BFD signalled that a peer session"+
                "is unconfigured before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
          }
          // interface * / bfd address-family multiplier
          leaf multiplier {
            tailf:info "Set the preferred multiplier for the BFD session";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-50>;;The preferred multiplier for the BFD "+
                "session";
              range "2..50";
            }
          }
          // interface * / bfd address-family destination
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "IPv4 destination address for the BFD session";
            }
          }
          // interface * / bfd address-family fast-detect
          leaf fast-detect {
            tailf:info "Enable fast detection using BFD on bundle members";
            tailf:cli-full-command;
            type empty;
          }
          // interface * / bfd address-family minimum-interval
          leaf minimum-interval {
            tailf:info "Set the preferred minimum interval for the BFD "+
              "session";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-30000>;;The preferred minimum interval "+
                "(in ms) for the BFD session";
              range "15..30000";
            }
          }
        }
      }
      // interface * / bfd echo
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }
      // interface * / bfd interval
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }

    // interface * / cdp
    leaf cdp {
      tailf:info "Enable CDP on an interface";
      type empty;
      tailf:cli-full-command;
    }

    // interface * / dual-active
    container dual-active {
      tailf:info "VS dual-active configuration command";
      leaf fast-hello {
        tailf:info "dual-active fast-hello detection method";
        type empty;
      }
    }

    // interface * / l2transport
    container l2transport {
      tailf:info "Enable Layer 2 transport and enter its "+
        "configuration submode";
      presence true;
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-l2";
    }

    // interface * / platform
    container platform {
      tailf:info "platform specific interface configuration";
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // interface * / xconnect
    container xconnect {
      tailf:info "Xconnect commands";
      leaf vfi {
        tailf:info "connect to a virtual forwarding instance";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
    }

    uses interface-switch-grouping;
  }

  // interface-name-grouping - all interface lists collected
  grouping interface-name-grouping {
    choice interface-choice {
      leaf Bundle-Ether {
        tailf:info "Aggregated Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Bundle-Ether/id";
        }
      }
      container Bundle-Ether-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle-Ether {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Bundle-Ether-subinterface/Bundle-Ether/id";
          }
        }
      }
      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/BVI/id";
        }
      }
      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/GigabitEthernet/id";
        }
      }
      //todo: subinterface GigabitEthernet #/#/#/#.#
      leaf TenGigE {
        tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/TenGigE/id";
        }
      }
      //todo: subinterface TenGigE #/#/#/#.#
      leaf HundredGigE {
        tailf:info "HundredGigEthernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/HundredGigE/id";
        }
      }
      leaf PW-Ether {
        tailf:info "Pseudo-Wire Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-32768>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/PW-Ether/id";
        }
      }
      //todo: subinterface PW-Ether
      //todo: subinterface HundredGigE #/#/#/#.#
      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<0-2147483647>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Loopback/id";
        }
      }
      leaf MgmtEth {
        tailf:info "Ethernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/MgmtEth/id";
        }
      }
      leaf Multilink {
        tailf:info "Multilink network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Multilink/id";
        }
      }
      //todo: subinterface Multilink #/#/#/#.#
      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-0>";
          pattern "0";
        }
      }
      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-512>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Port-channel/id";
        }
      }
      leaf POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in "+
            "Rack/Slot/Instance/Port format";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/POS/id";
        }
      }
      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in "+
            "Rack/Slot/Instance/Port format";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Serial/id";
        }
      }
      leaf tunnel-ip {
        tailf:info "GRE/IPinIP Tunnel Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
           path "/cisco-ios-xr:interface/tunnel-ip/id";
        }
      }
      leaf tunnel-te {
        tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-te/id";
        }
      }
      leaf Vlan {
        tailf:info "Iosxr Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Vlan/id";
        }
      }
    }
  }

  // interface-grouping
  grouping interface-grouping {

    // interface Loopback#
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<0-2147483647>;;Loopback interface number";
          range "0..2147483647";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface Bundle-Ether#
    list Bundle-Ether {
      tailf:info "Aggregated Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }

      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-bundle-grouping;
    }

    // interface Bundle-Ether-subinterface#.#
    container Bundle-Ether-subinterface {
      tailf:cli-drop-node-name;
      list Bundle-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface MgmtEth#/#/#/#
    list MgmtEth {
      tailf:info "Ethernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in "+
            "Rack/Slot/Instance/Port format";
          pattern "[0-9]+/.+/.+/.+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // interface TenGigE #/#/#/#
    list TenGigE {
      tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface TenGigE #/#/#/#.#
    container TenGigE-subinterface {
      tailf:cli-drop-node-name;
      list TenGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface HundredGigE #/#/#/#
    list HundredGigE {
      tailf:info "HundredGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface HundredGigE #/#/#/#.#
    container HundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list HundredGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface GigabitEthernet #/#/#/#
    list GigabitEthernet {
      tailf:info "GigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface GigabitEthernet #/#/#/#.#
    container GigabitEthernet-subinterface {
      tailf:cli-drop-node-name;
      list GigabitEthernet {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface PW-Ether#
    list PW-Ether {
      tailf:info "Pseudo-Wire Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-32768>";
          range "1..32768";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;

      // interface * / attach generic-interface-list
      container attach {
        tailf:info "Attach to an interface list";
        leaf generic-interface-list {
          tailf:info "Interface List";
          type string {
            tailf:info "WORD;;The name of the interface list";
          }
        }
      }
    }

    // interface PW-Ether-subinterface#.#
    container PW-Ether-subinterface {
      tailf:cli-drop-node-name;
      list PW-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+\.[0-9]+";
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;

        // interface * / attach generic-interface-list
        container attach {
          tailf:info "Attach to an interface list";
          leaf generic-interface-list {
            tailf:info "Interface List";
            type string {
              tailf:info "WORD;;The name of the interface list";
            }
          }
        }
      }
    }

    // interface Port-channel#
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface POS #/#/#/#
    list POS {
      tailf:info "Packet over SONET/SDH network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in "+
            "Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container pos {
        tailf:info "Modify POS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-pos";
        leaf crc {
          tailf:cli-full-command;
          type enumeration {
            enum "16" {
              tailf:info "16-bit CRC mode ";
            }
            enum "32" {
              tailf:info "32-bit CRC mode (default)";
            }
          }
        }
      }
    }

    // interface BVI#
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface Vlan#
    list Vlan {
      tailf:info "Iosxr Vlans";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface tunnel-ip#
    list tunnel-ip {
      tailf:info "GRE/IPinIP Tunnel Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;

      // interface * / tunnel
      container tunnel {
        tailf:info "Configure GRE tunnel parameters";
        container mode {
          tailf:info "Tunnel encapsulation method (default: gre ipv4)";
          leaf gre {
            tailf:info "IP over GRE encapsulation";
            type enumeration {
              enum ipv4 {
                tailf:info "GRE over IPV4 encapsulation";
              }
            }
          }
        }
        leaf source {
          tailf:info "Tunnel source physical interface";
          type string;
        }
        leaf destination {
          tailf:info "Tunnel destination IP address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Ip Address";
          }
        }
      }

    }

    // interface tunnel-te#
    list tunnel-te {
      tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;

      // interface * / auto-bw
      container auto-bw {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-autobw";
        container bw-limit {
          tailf:info "Set min/max bandwidth auto-bw can apply on a tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:info "Set minimum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Minimum bandwidth to apply (kbps)";
            }
          }
          leaf max {
            tailf:info "Set maximum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Maximum bandwidth to apply (kbps)";
            }
          }
        }
        container overflow {
          tailf:info "Configuring the tunnel overflow detection";
          container threshold {
            tailf:info "Set the bandwidth change percent to trigger an "+
              "overflow";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf percentage {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>  Bandwidth change percent to trigger "+
                  "an overflow";
                range "1..100";
              }
            }
            leaf min {
              tailf:info "Set the bandwidth change value to trigger an "+
                "overflow";
              tailf:cli-optional-in-sequence;
              type uint32 {
                tailf:info "<10-4294967295>;;Bandwidth change value to "+
                  "trigger an overflow (kbps)";
                range "10..4294967295";
              }
            }
            leaf limit {
              tailf:info "Set the number of consecutive collections "+
                "exceeding threshold";
              type uint8 {
                tailf:info "<1-10>;;Number of consecutive collections "+
                  "exceeding threshold";
                range "1..10";
              }
            }
          }
        }
        container adjustment-threshold {
          tailf:info "Set the bandwidth change threshold to trigger "+
            "adjustment";
            leaf percentage {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Bandwidth change percent to trigger "+
                  "adjustment";
                range "1..100";
              }
            }
            leaf min {
              tailf:info "Set the bandwidth change value to trigger "+
                "adjustment";
              type uint32 {
                tailf:info "<10-4294967295>;;Bandwidth change value to "+
                  "trigger adjustment (kbps)";
                range "10..4294967295";
              }
            }
        }
        leaf application {
          tailf:info "Set the tunnel auto-bw application frequency";
          type uint16 {
            tailf:info "<5-10080>;;Auto-bw application frequency (minutes)";
            range "5..10080";
          }
        }
      }

      // interface * / autoroute announce
      container autoroute {
        tailf:info "Parameters for IGP routing over tunnel";
        container announce {
          tailf:info "Announce tunnel to IGP";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-tunte-aa";
          presence true;
        }
      }

      // interface * / destination
      leaf destination {
        tailf:info "Specify tunnel destination";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;Destination address";
        }
      }

      // interface * / policy-class
      leaf policy-class {
        tailf:info "Specify classs for policy-based tunnel selection";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Default class for policy-based tunnel selection";
            }
          }
          type uint8 {
            tailf:info "<1-7>;;Tunnel policy class";
            range "1..7";
          }
        }
      }

      // interface * / soft-preemption
      leaf soft-preemption {
        tailf:info "Enable the soft-preemption feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / affinity
      container affinity {
        tailf:info "Link attributes for links traversed by tunnel";

        // interface * / affinity exclude *
        list exclude {
          tailf:info "Affinity to exclude";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
      }

      // interface * / path-selection
      container path-selection {
        tailf:info "Path Selection Configuration";
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }
        }
      }

      // interface * / priority
      container priority {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf setup {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-7>;;Setup Priority";
            range "0..7";
          }
        }
        leaf hold-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-7>;;Hold Priority";
          }
        }
      }

      // interface * / signalled-name
      leaf signalled-name {
        tailf:info "The signaling name to assign to tunnel";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;The name to be included in signaling";
        }
      }

      // interface * / signalled-bandwidth
      container signalled-bandwidth {
        tailf:info "Tunnel bandwidth requirement to be signalled";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf sub-pool {
          tailf:info "Specify sub-pool bandwidth";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf bandwidth {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
          }
        }
        leaf class-type {
          when "not(../sub-pool)" {
            tailf:dependency "../sub-pool";
          }
          tailf:info "Specify the bandwidth class type";
          type uint8 {
            tailf:info "<0-1>;;Class type number";
            range "0..1";
          }
        }
      }

      // interface * / fast-reroute
      leaf fast-reroute {
        tailf:info "Specify MPLS tunnel can be fast-rerouted";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / record-route
      leaf record-route {
        tailf:info "Record the route used by the tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / path-option *
      list path-option {
        tailf:info "Primary or fallback path setup option";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key preference-priority;
        leaf preference-priority {
          type uint16 {
            tailf:info "<1-1000>;;Preference for this path option";
            range "1..1000";
          }
        }

        choice path-option-choice {
          container dynamic {
            tailf:info "Setup based on dynamically allocated path";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            presence true;
          }
          container explicit {
            tailf:info "Setup based on preconfigured path";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice path-choice {
              leaf identifier {
                tailf:info "Specify an IP explicit path by number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Specify an IP explicit path "+
                    "by number";
                }
              }
              leaf name {
                tailf:info "Specify an IP explicit path by name";
                type string {
                  tailf:info "WORD;;Specify an IP explicit path by name";
                }
              }
            }
          }
        }
        leaf verbatim {
          tailf:info "Do not require topology database for explicit path";
          tailf:cli-break-sequence-commands;
          type empty;
        }
        leaf lockdown {
          tailf:info "Not a candidate for reoptimization";
          type empty;
        }
        // [ ospf instance-name area { value | address } ]
        container ospf {
          tailf:info "Limit CSPF to a single OSPF instance and area";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf instance-name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;OSPF instance name";
            }
          }
          leaf area {
            tailf:info "OSPF area";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
        }
      }
    }

    // interface Multilink
    list Multilink {
      tailf:info "Multilink network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port "+
            "format";
          pattern "([0-9]+/[0-9]+/[0-9]+/[0-9]+)"+
            "|([0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+)";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // subinterface Multilink #/#/#/#.#
    container Multilink-subinterface {
      tailf:cli-drop-node-name;
      list Multilink {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point;
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }

    // interface Serial
    list Serial {
      tailf:info "Serial network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port "+
            "format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      // interface * / multilink
      container multilink {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-multilink";
        leaf group {
          tailf:info "Enter multilink group ID";
          type uint32 {
            tailf:info "<1-999999999>;;Group Id";
            range "1..999999999";
          }
        }
      }
    }
  }

  // bgp-address-family-pre-grouping
  grouping bgp-address-family-pre-grouping {

    // router bgp * / address-family * / retain
    container retain {
      tailf:info "Accept/Retain specified bgp parameters";

      // router bgp * / address-family * / retain local-label
      leaf local-label {
        tailf:info "Delay the release of the local label as configured";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<3-60>;;Label retention time in minutes";
          range "3..60";
        }
      }

      // router bgp * / address-family * / retain route-target
      container route-target {
        tailf:info "Accept received updates with the specified route targets";
        choice route-target-choice {
          leaf all {
            tailf:info "Accept received updates containing at least one route target";
            type empty;
          }
          leaf route-policy {
            tailf:info "Accept received updates accepted by the specified policy";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:route-policy/name";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / update
    container update {
      tailf:info "BGP Update generation configuration";
      container limit {
        tailf:info "Upper bound on transient memory usage for update "+
          "generation";
        leaf address-family {
          tailf:info "Update limit for address-family";
          type uint16 {
            tailf:info "<4-2048>;;Update limit in MegaBytes(MB); "+
              "default is 256 MB";
            range "4..2048";
          }
        }
        container sub-group {
          tailf:info "Update limit for sub-groups";
          leaf ebgp {
            tailf:info "Update limit for eBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); "+
                "default is 32 MB";
              range "1..512";
            }
          }
          leaf ibgp {
            tailf:info "Update limit for iBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); "+
                "default is 32 MB";
              range "1..512";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / additional-paths
    container additional-paths {
      tailf:info "Additional paths configuration";
      // address-family ? / additional-paths receive
      leaf receive {
        tailf:info "Additional paths Receive capability";
        tailf:cli-full-command;
        type empty;
      }
      // address-family ? / additional-paths selection
      container selection {
        tailf:info "Additional paths selection";
        list route-policy {
          tailf:info "Route-policy for additional paths selection";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:route-policy/name";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / bgp attribute-download
    container bgp {
      tailf:info "BGP Commands";
      leaf attribute-download {
        tailf:info "Configure attribute download for this address-family";
        type empty;
      }
    }

    // router bgp * / address-family * / weight
    leaf weight {
      tailf:info "Define or modify weight";
      tailf:cli-full-command;
      type enumeration {
        enum reset-on-import {
          tailf:info "Reset weight of paths on import";
        }
      }
    }

    // router bgp * / address-family * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / address-family * / maximum-paths ebgp
      container ebgp {
        tailf:info "eBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

      // router bgp * / address-family * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths (limit includes backup path)";
          }
        }
        leaf unequal-cost {
          tailf:info "Allow multipaths to have different BGP nexthop IGP metrics";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

    }

    // router bgp * / address-family * / nexthop
    container nexthop {
      tailf:info "Nexthop";
      container resolution {
        tailf:info "Nexthop resolution";
        container prefix-length {
          tailf:info "Nexthop resolution prefix-length";
          leaf minimum {
            tailf:info "Set minimum prefix-length for nexthop "+
              "resolution";
            type uint16 {
              tailf:info "<0-32|128>;;Prefix-length value "+
                "(only 0 and 32|128 are supported)";
            }
          }
        }
      }
      leaf route-policy {
        tailf:info "Policy to filter out nexthop notification";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }
      container trigger-delay {
        tailf:info "Processing trigger delay";
        leaf critical {
          tailf:info "For critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
        leaf non-critical {
          tailf:info "For non-critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
      }
    }
  }

  // bgp-address-family-post-grouping
  grouping bgp-address-family-post-grouping {

    // router bgp * / address-family * / aggregate-address
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "prefix";
      leaf "prefix" {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 Aggregate address and "+
            "mask or masklength";
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf as-confed-set {
        tailf:info "Generate AS confed set path information";
        type empty;
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      container route-policy {
        tailf:info "Policy to condition advertisement, suppression, "+
          "and attributes";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router bgp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // address-family ? / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // address-family ? / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // address-family ? / redistribute ospf
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF router tag";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum "external" {
              tailf:info "Redistribute OSPF external routes";
            }
            enum "internal" {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum "nssa-external" {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }

      // address-family ? / redistribute isis
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:info "Redistribute routes from the specified ISIS levels";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute ISIS level 1 routes";
            }
            enum "1-inter-area" {
              tailf:info "Redistribute ISIS level 1 inter-area routes";
            }
            enum "2" {
              tailf:info "Redistribute ISIS level 2 ISIS routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }
    }

    // router bgp * / address-family * / allocate-label
    container allocate-label {
      tailf:info "Allocate label for selected prefixes";
      choice allocate-label-choice {
        leaf all {
          tailf:info "Allocate labels for all prefixes";
          type empty;
        }
        leaf route-policy {
          tailf:info "Use a route policy to select prefixes for "+
            "label allocation";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

  }

  // bgp-address-family-ipv4-grouping
  grouping bgp-address-family-ipv4-grouping {
    uses bgp-address-family-pre-grouping;

    // router bgp * / address-family * / network
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key net;
      leaf net {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }
    }

    uses bgp-address-family-post-grouping;
  }

  // bgp-address-family-ipv6-grouping
  grouping bgp-address-family-ipv6-grouping {
    uses bgp-address-family-pre-grouping;

    // router bgp * / address-family * / network
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key net;
      leaf net {
        type ipv6-prefix {
          tailf:info "X:X::X/length;;IPv6 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }
    }

    uses bgp-address-family-post-grouping;
  }

  // bgp-address-family-grouping
  grouping bgp-address-family-grouping {

    container address-family {
      tailf:info "Enter Address Family command mode";

      // router bgp * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
      }

      // router bgp * / address-family vpnv4
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family vpnv6
      container vpnv6 {
        tailf:info "VPNv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
      }

      // router bgp * / address-family l2vpn
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }
    }
  }


  // router bgp * / neighbor *
  // router bgp * / neighbor-group *
  grouping bgp-neighbor-grouping {

    // router bgp * / neighbor * / remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;AS of remote neighbor";
          range "1..4294967295";
        }
        type string {
          tailf:info "<1.0-XX.YY>;;AS of remote neighbor";
          pattern "[0-9]+\.[0-9]+";
        }
      }
    }

    // router bgp * / neighbor * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<15-30000>;;hello interval in milli-seconds";
          range "15..30000";
        }
      }
    }

    // router bgp * / neighbor * / ebgp-multihop
    leaf ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      type uint8 {
        range "1..255";
      }
    }

    // router bgp * / neighbor * / timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0|3-65535>;;Holdtime (0=disable)";
        }
      }
      leaf min-holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
        }
      }
    }

    // router bgp * / neighbor * / description
    leaf "description" {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / neighbor * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf enc-type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum clear;
          enum encrypted;
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }

    // router bgp * / neighbor * / update-source
    container update-source {
      tailf:info "Source of routing updates";
      tailf:cli-diff-dependency "/cisco-ios-xr:interface";
      uses interface-name-grouping;
    }

    // router bgp * / neighbor * / cluster-id
    leaf cluster-id {
      tailf:info "Enter cluster id for this neighbor";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as "+
            "32 bit quantity";
        }
        type inet:host {
          tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address "+
            "format";
        }
      }
    }

    // router bgp * / neighbor * / graceful-restart
    container graceful-restart {
      tailf:info "Enable graceful restart support for this neighbor";
      presence true;
      leaf suppress {
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf disable {
        tailf:info "Disable graceful restart support for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * / capability suppress
    container capability {
      tailf:info "Advertise capability to the peer";
      container suppress {
        tailf:info "Suppress advertising capability to the peer ";
        container "four-byte-as" {
          tailf:alt-name "4-byte-as";
          tailf:info "4-byte-as capability";
          presence true;
          leaf inheritance-disable {
            tailf:info "Prevent capability suppress 4-type-as being "+
              "inherited from the parent";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses bgp-neighbor-address-family-grouping;
          container accept-own {
            tailf:info "Handle self-originated routes with Accept-Own "+
              "community";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf inheritance-disable {
              tailf:info "Prevent item being inherited from a parent group";
              type empty;
            }
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
      container vpnv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses bgp-neighbor-address-family-grouping;
        }
      }
    }

    // router bgp * / neighbor * / keychain
    leaf keychain {
      tailf:info "Set keychain based authentication";
      type string {
        tailf:info "WORD;;The Key Chain name";
      }
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:key/chain/name";
      }
    }

    // router bgp * / neighbor * / peer-group
    container peer-group {
      tailf:info "Configure peer-group";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf group-name {
        // Note: only applicable to ipv4 neighbours
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
    }

    // router bgp * / neighbor * / use
    container use {
      tailf:info "Inherit configuration from a group";
      choice use-choice {
        leaf af-group {
          tailf:info "Inherit configuration from an af-group";
          type string;
        }
        leaf neighbor-group {
          tailf:info "Inherit configuration from a neighbor-group";
          type string;
        }
        leaf session-group {
          tailf:info "Inherit address-family independent config "+
            "from a session-group";
          type string;
        }
      }
    }

    // router bgp * / neighbor * / shutdown
    container shutdown {
      tailf:info "Administratively shut down this neighbor";
      presence true;
    }
  }

  // bgp-neighbor-address-family-grouping
  grouping bgp-neighbor-address-family-grouping {

    // neighbor * / address-family ? / route-policy
    list route-policy {
      tailf:info "Apply route policy to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply route policy to inbound routes";
          }
          enum out {
            tailf:info "Apply route policy to outbound routes";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }
    }

    // neighbor * / address-family ? / remove-private-AS
    container remove-private-AS {
      tailf:info "Remove private AS number from outbound updates";
      presence true;
    }

    // neighbor * / address-family ? / soft-reconfiguration inbound
    container soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      container inbound {
        tailf:info "Allow inbound soft reconfiguration for this neighbor";
        tailf:cli-compact-syntax;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum always {
              tailf:info "Always use soft reconfig, even if route refresh "+
                "is supported";
            }
            enum inheritance-disable {
              tailf:info "Prevent soft-reconfiguration from being inherited "+
                "from the parent";
            }
          }
        }
      }
    }

    // neighbor * / address-family ? / as-override
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent as-override from being inherited from the parent";
        type empty;
      }
    }

    // neighbor * / address-family ? / maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes to accept "
        +"from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-sequence-commands;
      leaf max-prefix-limit {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;maximum no. of prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at "
            +"which to generate a warning msg";
          range "1..100";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }

    // neighbor * / address-family ? / next-hop-self
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-self from being inherited from the "+
          "parent";
        type empty;
      }
    }

    // neighbor * / address-family ? / route-reflector-client
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }

    // neighbor * / address-family ? / default-originate
    container default-originate {
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
    }

    // neighbor * / address-family ? / send-community-ebgp
    container send-community-ebgp {
      tailf:info "Send community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-community-ebgp from being inherited "+
          "from the parent";
        type empty;
      }
    }

    // neighbor * / address-family ? / use af-group
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration for this address-family from an "+
          "af-group";
        tailf:cli-full-command;
        type string; //FIXME: dependency
      }
    }

    // neighbor * / address-family ? / capability
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf "prefix" {
          tailf:info "Advertise address prefix ORF capability to this neighbor";
          type enumeration {
            enum both {
              tailf:info "Capability to RECEIVE and SEND the ORF from/to "+
                "this neighbor";
            }
            enum none {
              tailf:info "No capability to RECEIVE or SEND the ORF from/to "+
                "this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }
  }

  // grouping router-bgp-vrf-grouping
  grouping router-bgp-vrf-grouping {

    // router bgp / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router bgp / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }

      // router bgp / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<15-30000>;;hello interval in milli-seconds";
          range "15..30000";
        }
      }
    }

    // router bgp / bgp
    container bgp {
      tailf:info "BGP specific commands";

      // router bgp / bgp router-id
      leaf router-id {
        tailf:info "Configure Router-id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp / bgp cluster-id
      leaf cluster-id {
        tailf:info "Configure Route-Reflector Cluster-id";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as "+
              "32 bit quantity";
          }
          type inet:host {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address "+
              "format";
          }
        }
      }

      // router bgp / bgp scan-time
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }

      // router bgp / bgp update-delay
      container update-delay {
        tailf:info "Set the max initial delay for sending updates";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update-delay-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Delay value (seconds)";
            range "0..3600";
          }
        }
        leaf always {
          tailf:info "Keepalive trigger bestpath is disabled and delay "+
            "is enforced";
          type empty;
        }
      }

      // router bgp / bgp graceful-restart
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        presence true;
        tailf:cli-display-separated;

        // router bgp / bgp graceful-restart extended
        leaf extended {
          tailf:info "Enable Graceful-Restart Extension";
          type empty;
        }

        // router bgp / bgp graceful-restart restart-time
        leaf restart-time {
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-4095>;;Max time (seconds)";
            range "1..4095";
          }
        }

        // router bgp / bgp graceful-restart stalepath-time
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto "
            +"restarting peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }

        // router bgp / bgp graceful-restart purge-time
        leaf purge-time {
          tailf:info "Time before stale routes are purged.";
          type uint16 {
            tailf:info "<1-6000>;;Max time (seconds)";
            range "1..6000";
          }
        }
      }

      // router bgp / bgp bestpath
      container bestpath {
        tailf:info "Change default route selection criteria";
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }
        container cost-community {
          tailf:info "Cost community";
          leaf ignore {
            tailf:info "Ignore cost-community comparison";
            type empty;
          }
        }
        container med {
          tailf:info "MED related";
          leaf always {
            tailf:info "Allow comparing MED from different neighbors";
            tailf:cli-full-command;
            type empty;
          }
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // router bgp / bgp log
      container log {
        tailf:info "Log bgp info";
        container neighbor {
          tailf:info "Log neighbor state info";
          leaf changes {
            tailf:info "Log neighbor up/down and reset reason";
            type enumeration {
              enum detail {
                tailf:info "Include extra detail in change messages";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }

      // router bgp / bgp default
      container "default" {
        tailf:info "Configure default value";
        leaf local-preference {
          tailf:info "Local preference";
          type uint32 {
            tailf:info "<0-4294967295>;;Higher = more preferred";
          }
        }
      }
    }

    // router bgp / mpls activate
    container mpls {
      tailf:info "Enable mpls parameters";
      container activate {
        tailf:info "Enter mpls interfaces in BGP mpls activate mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-mpls";

        // router bgp / mpls activate / interface *
        list interface {
          tailf:info "Interface to enable mpls";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }

    // router bgp * / update
    container update {
      tailf:info "BGP Update configuration";
      leaf limit {
        tailf:info "Upper bound on transient memory usage for update "+
          "generation";
        type uint16 {
          tailf:info "<16-2048>;;Update limit in MegaBytes(MB); "+
            "default is 512 MB";
          range "16..2048";
        }
      }
    }

    // router bgp * / address-family
    uses bgp-address-family-grouping;

    // router bgp * / af-group *
    list af-group {
      tailf:info "Specify a AF group";
      tailf:cli-mode-name "config-bgp-afgrp";
      key "name address-family af-modifier";
      leaf name {
        type string {
          tailf:info "WORD;;AF group name";
        }
      }
      leaf address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-expose-key-name;
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 Address Family";
          }
          enum ipv6 {
            tailf:info "IPv6 Address Family";
          }
          enum l2vpn {
            tailf:info "L2VPN Address Family";
          }
          enum vpnv4 {
            tailf:info "VPNv4 Address Family";
          }
          enum vpnv6 {
            tailf:info "VPNv6 Address Family";
          }
        }
      }
      leaf af-modifier {
        type enumeration {
          enum labeled-unicast {
            tailf:info "Address Family modifier";
          }
          enum mdt {
            tailf:info "Address Family modifier";
          }
          enum multicast {
            tailf:info "Address Family modifier";
          }
          enum mvpn {
            tailf:info "Address Family modifier";
          }
          enum rt-filter {
            tailf:info "Address Family modifier";
          }
          enum tunnel {
            tailf:info "Address Family modifier";
          }
          enum unicast {
            tailf:info "Address Family modifier";
          }
          enum vpls-vpws {
            tailf:info "Address Family modifier";
          }
        }
      }
      uses bgp-neighbor-address-family-grouping;
    }

    // router bgp * / neighbor-group *
    list neighbor-group {
      tailf:info "Specify a Neighbor-group";
      tailf:cli-mode-name "config-bgp-nbrgrp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      uses bgp-neighbor-grouping;
    }

    // router bgp * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-mode-name "config-bgp-nbr";
      key id;
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type string {
            tailf:info "WORD;;Neighbor tag";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      uses bgp-neighbor-grouping;
    }

    // router bgp * / socket
    container socket {
      tailf:info "set socket parameters";
      container receive-buffer-size {
        tailf:info "socket receive buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<512-131072>;;Receive socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "BGP Read buffer size in bytes";
            range "512..131072";
          }
        }
      }
      container send-buffer-size {
        tailf:info "socket send buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
      }
    }

  }

  // grouping router-bgp-grouping
  grouping router-bgp-grouping {

    // router bgp * / nsr
    leaf nsr {
      tailf:info "Enable non-stop-routing support for all neighbors";
      tailf:cli-full-command;
      type empty;
    }

    uses router-bgp-vrf-grouping;

    // router bgp * / session-group *
    list session-group {
      tailf:info "Specify a Session group";
      tailf:cli-mode-name "config-bgp-sngrp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session group name";
        }
      }

      // router bgp * / session-group * / remote-as
      leaf remote-as {
        tailf:info "Set remote AS";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;AS number in 2-byte, 4-byte asdot and asplain";
        }
      }

      // router bgp * / session-group * / ebgp-multihop
      container ebgp-multihop {
        tailf:info "Allow EBGP neighbors not on directly connected networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;maximum hop count";
          }
        }
        leaf mpls {
          tailf:info "Disable BGP MPLS forwarding";
          type empty;
        }
      }

      // router bgp * / session-group * / advertisement-interval
      container advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing updates";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-600>;;time in seconds";
            range "0..600";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;time in milliseconds";
            range "0..999";
          }
        }
      }

      // router bgp * / session-group / local-as
      container local-as {
        tailf:info "Specify a local-as number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice local-as-choice {
          case a {
            leaf inheritance-disable {
              tailf:info "Prevent local AS from being inherited from parent";
              type empty;
            }
          }
          case b {
            leaf as-number {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;AS number in 2-byte, 4-byte asdot and "+
                  "asplain";
              }
            }
            leaf no-prepend {
              tailf:info "Do not prepend local AS to announcements from "+
                "this neighbor";
              type empty;
            }
            leaf replace-as {
              tailf:info "Prepend only local AS to announcements to this "+
                "neighbor";
              type empty;
            }
            leaf dual-as {
              tailf:info "Dual-AS mode";
              type empty;
            }
          }
        }
      }

      // router bgp * / session-group * / password
      container password {
        tailf:info "Set a password";
        choice password-choice {
          leaf clear {
            tailf:info "Specifies an unencrypted password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an encrypted password will follow";
            type string {
              tailf:info "WORD;;The ENCRYPTED neighbor password string";
            }
          }
          leaf inheritance-disable {
            tailf:info "Prevent password from being inherited from parent";
            type empty;
          }
        }
      }

      // router bgp * / session-group * / description
      leaf "description" {
        tailf:info "Neighbor specific description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this neighbor";
        }
      }

      // router bgp * / session-group * / update-source
      container update-source {
        tailf:info "Source of routing updates";
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }

      // router bgp * / session-group * / session-open-mode
      leaf session-open-mode {
        tailf:info "Establish BGP session using this TCP open mode";
        type enumeration {
          enum active-only {
            tailf:info "Active only";
          }
          enum both {
            tailf:info "Prevent session-open-mode being inherited "+
              "from the parent";
          }
          enum passive-only {
            tailf:info "Passive only";
          }
        }
      }

      // router bgp * / session-group * / send-buffer-size
      leaf send-buffer-size {
        tailf:info "Set socket and BGP send buffer size";
        type uint32 {
          tailf:info "<4096-131072>;;Send socket buffer size in bytes";
        }
      }

      // router bgp * / session-group * / receive-buffer-size
      leaf receive-buffer-size {
        tailf:info "Set socket and BGP receive buffer size";
        type uint32 {
          tailf:info "<512-131072>;;Receive socket buffer size in bytes";
        }
      }
    }

    // router bgp * / vrf *
    list vrf {
      tailf:info "Specify a vrf name";
      tailf:cli-mode-name "config-bgp-vrf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VRF name - maximum length 32 characters";
        }
      }
      // router bgp * / vrf * / rd
      leaf rd {
        tailf:info "route distinguisher";
        tailf:cli-full-command;
        type union {
          type string {
            tailf:info "<1-4294967295>:<0-4294967295>;;AS number";
          }
        }
      }
      // router bgp * / vrf * / XXX
      uses router-bgp-vrf-grouping;
    }
  }

  grouping police-set-grouping {
    leaf atm-clp {
      tailf:info "Set atm cell-loss-priority bit";
      tailf:cli-full-command;
      type empty;
    }
    container cos {
      tailf:info "Set Class Of Service values";
      leaf cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf inner {
        tailf:info "COS inner value";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    leaf dei {
      tailf:info "Set DEI";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;DEI value";
        range "0..1";
      }
    }
    leaf discard-class {
      tailf:info "Set discard-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Discard Class value";
        range "0..63";
      }
    }
    container dscp {
      tailf:info "Set IP DSCP (DiffServ CodePoint)";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf tunnel {
        tailf:info "Set DSCP Tunnel(for ipsec tunnels)";
        tailf:cli-full-command;
        type dscp-type;
      }
    }
    leaf fr-de {
      tailf:info "Set FR DE value";
      tailf:cli-full-command;
      type enumeration {
        enum "1" {
          tailf:info "<1-1>;;FR DE value";
        }
      }
    }
    container mpls {
      tailf:info "Set MPLS specific values";
      container experimental {
        tailf:info "Set Experimental value";
        leaf imposition {
          tailf:info "Set Experimental value at tag imposition";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
        leaf topmost {
          tailf:info "Set Experimental value on topmost label";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
      }
    }
    container precedence {
      tailf:info "Set IP Precedence";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type precedence-type;
      }
      leaf tunnel {
        tailf:info "Set Precedence tunnel (for ipsec tunnels)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }
    leaf qos-group {
      tailf:info "Set qos-group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;QoS group value";
        range "0..63";
      }
    }
  }

  grouping police-action-grouping {
    container conform-action {
      tailf:info "Action for conforming traffic";
      tailf:cli-break-sequence-commands;
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container exceed-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container violate-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  // policy-map-class-grouping
  grouping policy-map-class-grouping {

    // policy-map * / class * / shape
    container shape {
      tailf:info "Configure shaping for this class";
      // policy-map * / class * / shape average
      container average {
        tailf:info "Average rate shaping";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        choice average-choice {
          case percent-case {
            leaf percent {
              tailf:info "Configure shape rate in percentage";
              type uint8 {
                tailf:info "<1-100>;;Shape rate as percentage of "+
                  "available bandwidth";
                range "1..100";
              }
            }
          }
          case unit-case {
            leaf rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Shape rate";
                range "1..4294967295";
              }
            }
            leaf rate-unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum bps {
                  tailf:info "Bits per second (default)";
                }
                enum cellsps {
                  tailf:info "Cells per second";
                }
                enum gbps {
                  tailf:info "Gigabits per second";
                }
                enum kbps {
                  tailf:info "Kilobits per second";
                }
                enum mbps {
                  tailf:info "Megabits per second";
                }
              }
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Excess burst size";
            range "1..4294967295";
          }
        }
        leaf burst-unit {
          tailf:cli-drop-node-name;
          type union {
            type police-burst-units-type;
            type enumeration {
              enum cells {
                tailf:info "Cells";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / bandwidth
    container bandwidth {
      tailf:info "Configure bandwidth for this class";
      container bandwidth-units {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth value";
          }
        }
        leaf "units" {
          tailf:cli-drop-node-name;
          type police-rate-units-type;
        }
      }
      leaf percent {
        tailf:info "configure a percentage bandwidth";
        type percentage-type;
      }
      container remaining {
        tailf:info "Allocate left over bandwidth";
        leaf percent {
          tailf:info "Allocate remaining bandwidth as percentage";
          type percentage-type;
        }
        leaf ratio {
          tailf:info "Allocate remaining bandwidth as a ratio";
          type uint16 {
            tailf:info "<1-1020>;;Bandwidth ratio";
            range "1..1020";
          }
        }
      }
    }

    // policy-map * / class * / police ?
    choice police-choice {

      // policy-map * / class * / police rate
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Committed Information Rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // { <value> [<units>] | percent <percentage> }
              choice rate-choice {
                case units-case {
                  leaf cir {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-incomplete-command;
                    type uint64 {
                      tailf:info "<1-4294967295>;;Committed Information Rate";
                    }
                  }
                  leaf cir-unit {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-rate-units-type;
                  }
                }
                case percent-case {
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    tailf:cli-hide-in-submode;
                    type uint8 {
                      tailf:info "<1-100>;;Committed Information Rate in "+
                        "percentage of link bandwidth";
                      range "1..100";
                    }
                  }
                }
              }
              // [ burst burst-size [burst-units] ]
              leaf burst {
                tailf:info "Burst size (BC)";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-4294967295>;;Burst size (BC)";
                  range "1..4294967295";
                }
              }
              leaf burst-units {
                when "../burst";
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              // [ peak-rate { value [units] | percent percentage } ]
              leaf peak-rate {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Peak-rate value in range "
                    +"7-10,000,000,000";
                  range "7..10000000000";
                }
              }
              leaf peak-rate-units {
                when "../peak-rate";
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-rate-units-type;
              }
              container peak-rate-percent {
                when "not(../peak-rate)" {
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                container peak-rate {
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    type percentage-type;
                  }
                }
              }
              // [ peak-burst peak-burst [burst-units] ]
              leaf peak-burst {
                tailf:info "Excess Burst size (BE)";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Excess burst size (BE)";
                }
              }
              leaf peak-burst-units {
                when "../peak-burst";
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }

      // policy-map * / class * / police <unit>
      case police-unit-case {
        container police-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            // To cover also the syntax where cir, bc and be
            // doesn't have to be explicitly specified
            tailf:info "Police traffic";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              type uint32 {
                range "8000..2000000000";
                tailf:info "<8000-2000000000>;;Bits per second";
              }
            }
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            // conform-action | exceed-action | violate-action
            uses police-action-grouping;
          }
        }
      }

    }

    // policy-map * / class * / set
    container set {
      tailf:info "Configure marking for this class";
      uses police-set-grouping;
    }

    // policy-map * / class * / priority
    container priority {
      tailf:info "Assign priority to this class";
      leaf level {
        tailf:info "Configure a priority level";
        type uint8 {
          tailf:info "<1-3>;;Priority level";
          range "1..3";
        }
      }
    }

    // policy-map * / class * / queue-limit
    container queue-limit {
      tailf:info "Configure queue-limit (taildrop threshold) for this class";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf queue-limit-value {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Max Threshold for tail drop";
          range "1..4294967295";
        }
      }
      leaf queue-limit-unit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum bytes {
            tailf:info "Bytes";
          }
          enum kbytes {
            tailf:info "Kilobytes";
          }
          enum mbytes {
            tailf:info "Megabytes";
          }
          enum ms {
            tailf:info "Milliseconds";
          }
          enum packets {
            tailf:info "Packets (default)";
          }
          enum us {
            tailf:info "Microseconds";
          }
        }
      }
    }

    // policy-map * / class * / service-policy
    container service-policy {
      tailf:info "Configure a child service policy";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf "type" {
        tailf:info "The type of policymap";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum accounting {
            tailf:info "Accounting policymap";
          }
          enum control {
            tailf:info "Control policy-map";
          }
          enum none {
            tailf:info "Untyped policymap";
          }
          enum pbr {
            tailf:info "PBR policymap";
          }
          enum performance-traffic {
            tailf:info "Realtime Application Flow Monitoring policymap";
          }
          enum qos {
            tailf:info "QoS policymap (default)";
          }
          enum redirect {
            tailf:info "Redirect policymap";
          }
          enum traffic {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of the child service policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:policy-map/name";
        }
      }
    }

    // policy-map * / class * / random-detect
    container random-detect {
      tailf:info "Enable Random Early Detection";
      // policy-map * / class * / random-detect dscp
      list dscp {
        tailf:info "DSCP based WRED (upto 8 values or ranges)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-63>;;Differentiated services codepoint value\n"+
              "af11,af12,af13,af21,af22,af23,af31,af32,af33,af41,af42,af43\n"+
              "cs1-cs7,default,ef and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      // policy-map * / class * / random-detect exp
      list exp {
        tailf:info "MPLS Experimental value based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;MPLS Experimental value"+
              "and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      // policy-map * / class * / random-detect precedence
      list precedence {
        tailf:info "Precedence based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;Precedence value\n"+
              "critical,flash,flash-override,immediate,\n"+
              "internet,network,priority,routine and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
    }
  }

  // performance-mgmt-grouping
  grouping performance-mgmt-grouping {
    container AverageCpuUsed {
      tailf:info "Average %CPU utilization";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf op {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type operator-type;
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;Threshold value";
          range "0..100";
        }
      }
      leaf percent {
        tailf:info "Specify that threshold value is percent of previous "+
          "sample";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      container rearm {
        tailf:info "Specify Rearm parameters (default - always)";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        choice rearm-choice {
          leaf toggle {
            tailf:info "Rearm after the first period when condition is not met";
            type empty;
          }
          leaf window {
            tailf:info "Rearm after the window of sampling periods";
            type uint8 {
              tailf:info "<1-100>;;Rearm window size";
              range "1..100";
            }
          }
        }
      }
    }
    leaf sample-interval {
      tailf:info "Frequency of sampling in minutes";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Frequency of samples";
        range "1..60";
      }
    }
  }


  // arp-grouping
  grouping arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf mac {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;MAC address";
          pattern "[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+";
        }
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "Encapsulation type ARPA";
          }
          enum SRP {
            tailf:info "Encapsulation type SRP";
          }
          enum SRPA {
            tailf:info "Encapsulation type SRPA";
          }
          enum SRPB {
            tailf:info "Encapsulation type SRPB";
          }
        }
      }
      leaf alias {
        tailf:info "Configure an Alias ARP entry";
        type empty;
      }
    }
  }


  // tftp-server-grouping
  grouping tftp-server-grouping {
    list tftp-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "Global ipv4 specific TFTP server commands";
          }
          enum ipv6 {
            tailf:info "Global ipv6 specific TFTP server commands";
          }
        }
      }
      leaf server {
        tailf:info "TFTP server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf homedir {
        tailf:info "Home directory for TFTP server";
        type string {
          tailf:info "WORD;;Name of home directory (e.g. disk0:)";
        }
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum number of concurrent tftp servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Set number of allowable tftp "+
              "server processes";
            range "1..2147483647";
          }
          type enumeration {
            enum no-limit {
              tailf:info "No limit to number of allowable tftp server "+
                "processes";
            }
          }
        }
      }
      leaf access-list {
        tailf:info "Access list for TFTP server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }


  // telnet-server-grouping
  grouping telnet-server-grouping {
    list telnet-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 configuration";
          }
          enum ipv6 {
            tailf:info "IPv6 configuration";
          }
        }
      }
      leaf dscp {
        tailf:info "dscp";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;dscp value";
        }
      }
      container server {
        tailf:info "Telnet server configuration commands";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf max-servers {
          tailf:info "Set number of allowable telnet sessions";
          type uint8 {
            tailf:info "<1-100>;;Set number of allowable telnet sessions";
            range "1..100";
          }
        }
        leaf access-list {
          tailf:info "Access list for telnet server";
          type string {
            tailf:info "WORD;;Name of access list";
          }
        }
      }
    }
  }


  // ntp server *
  grouping ntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type union {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Peer/server address";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;Peer/server address";
          }
        }
      }
      leaf ip-version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Specify IPv4 address or hostname";
          }
          enum ipv6 {
            tailf:info "Specify IPv6 address or host name";
          }
        }
      }

      // ntp server * version
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
          range "1..4";
        }
      }

      // ntp server * minpoll
      leaf minpoll {
        tailf:info "Configure minimum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Minimum poll rate, default 6, less than "+
            "maxpoll";
          range "4..17";
        }
      }

      // ntp server * maxpoll
      leaf maxpoll {
        tailf:info "Configure maximum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Maximum poll rate, default 10, greater than "+
            "minpoll";
          range "4..17";
        }
      }

      // ntp server * prefer
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }

      // ntp server * burst
      leaf burst {
        tailf:info "Use burst mode";
        type empty;
      }

      // ntp server * iburst
      leaf iburst {
        tailf:info "Use initial burst mode";
        type empty;
      }

      // ntp server * source
      container source {
        tailf:info "Interface for source address";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }
    }
  }


  // router static / address-family ipv4 unicast
  // router static / address-family ipv6 unicast
  grouping router-static-options-grouping {

    // router static / address-family ipv4 unicast / * bfd fast-detect
    leaf bfd {
      tailf:info "Configure BFD paramenters";
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum fast-detect {
          tailf:info "Enable Fast detection";
        }
      }
    }

    // router static / address-family ipv4 unicast / * minimum-interval
    leaf minimum-interval {
      when "../bfd";
      tailf:info "Hello interval";
      tailf:cli-optional-in-sequence;
      type uint16 {
        tailf:info "<10-10000>;;interval in milli-seconds";
        range "10..10000";
      }
    }

    // router static / address-family ipv4 unicast / * multiplier
    leaf multiplier {
      when "../bfd";
      tailf:info "Detect multiplier";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-10>;;Detect multiplier";
        range "1..10";
      }
    }

    // router static / address-family ipv4 unicast / * tag
    leaf tag {
      tailf:info "Set tag for this route";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1-4294967295>;;Set tag for this route";
      }
    }

    // router static / address-family ipv4 unicast / * permanent
    leaf permanent {
      tailf:info "Permanent route";
      tailf:cli-optional-in-sequence;
      type empty;
    }

    // router static / address-family ipv4 unicast / * vrflabel
    leaf vrflabel {
      tailf:info "VRF label";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<0-4294967295>;;VRF label";
      }
    }

    // router static / address-family ipv4 unicast / * tunnel-id
    leaf tunnel-id {
      tailf:info "Tunnel ID";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<0-4294967295>;;Tunnel ID";
      }
    }

    // router static / address-family ipv4 unicast / * description
    leaf "description" {
      tailf:info "description of the static route";
      type string {
        tailf:info "WORD;;short description of static route";
      }
    }
  }



  // router static
  // router static / vrf *
  grouping router-static-grouping {
    container address-family {
      tailf:info "Static route address family configuration subcommands";

      // router static / address-family ipv4 unicast
      container ipv4 {
        tailf:info "IPv4 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";

          // router static / address-family ipv4 unicast / *
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "net interface";
            leaf net {
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // router static / address-family ipv4 unicast / * a.b.c.d
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }

            // router static / address-family ipv4 unicast / * ?
            uses router-static-options-grouping;
          }
        }
      }

      // router static / address-family ipv6 unicast
      container ipv6 {
        tailf:info "IPv6 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";

          // router static / address-family ipv6 unicast / *
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "net interface";
            leaf net {
              type ipv6-prefix {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // router static / address-family ipv6 unicast / * X:X::X
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }

            // router static / address-family ipv6 unicast / * ?
            uses router-static-options-grouping;
          }
        }
      }
    }
  }

  // key-grouping
  grouping key-grouping {
    container key-container {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED key will follow";
          }
          enum "7" {
            tailf:info "Specifies an ENCRYPTED key will follow";
          }
        }
      }
      leaf "key" {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "0|7";
        type string {
          tailf:info "LINE;;The UNENCRYPTED key";
        }
      }
    }
  }

  // l2vpn / bridge group * / bridge-domain * / mac
  // l2vpn / bridge group * / bridge-domain * / interface * / mac
  grouping l2vpn-bridge-domain-mac-grouping {

    // l2vpn / bridge group * / bridge-domain * / mac / limit
    container limit {
      tailf:info "MAC-Limit configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-ac-mac-limit";
      leaf maximum {
        tailf:info "Number of MAC addresses after which MAC "+
          "limit action is taken";
        type uint32 {
          tailf:info "<5-512000>;;Number of MAC addresses after "+
            "which MAC limit action is taken";
          range "5..512000";
        }
      }
      leaf action {
        tailf:info "MAC address limit enforcement action";
        type enumeration {
          enum flood {
            tailf:info "Stop learning but continue flooding";
          }
          enum no-flood {
            tailf:info "Stop learning and stop flooding";
          }
          enum none {
            tailf:info "No action";
          }
          enum shutdown {
            tailf:info "Stop forwarding";
          }
        }
      }
      leaf "notification" {
        tailf:info "MAC address limit notification action";
        type enumeration {
          enum both {
            tailf:info "Generate syslog message and SNMP trap";
          }
          enum none {
            tailf:info "No notification";
          }
          enum syslog {
            tailf:info "Generate syslog message";
          }
          enum trap {
            tailf:info "Generate SNMP trap";
          }
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac / secure
    container secure {
      tailf:info "MAC Secure configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-mac-secure";
      // l2vpn / bridge group * / bridge-domain * / mac / secure / action
      leaf action {
        tailf:info "MAC secure enforcement action";
        type enumeration {
          enum none {
            tailf:info "Forward the violating packet and allow the MAC "+
              "to be relearned";
          }
          enum shutdown {
            tailf:info "Shutdown the violating bridge port";
          }
        }
      }
      // l2vpn / bridge group * / bridge-domain * / mac / secure / logging
      leaf logging {
        tailf:info "Enable Logging";
        type empty;
      }
    }

  }

  grouping interface-freqsync-quality-grouping {
    choice quality-type {
      leaf exact {
        tailf:info "Specify the exact QL value to use";
        type empty;
      }
      leaf highest {
        tailf:info "Specify the highest acceptable QL value";
        type empty;
      }
      leaf lowest {
        tailf:info "Specify the lowest acceptable QL value";
        type empty;
      }
    }
    container itu-t {
      tailf:info "ITU-T QL options";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf option {
        tailf:info "ITU-T QL options";
        tailf:cli-incomplete-command;
        type enumeration {
          enum "1" {
            tailf:info "ITU-T QL option 1";
          }
          enum "2" {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
      leaf generation {
        tailf:info "ITU-T QL option 2 generation";
        tailf:cli-incomplete-command;
        when "../option = '2'";
        type enumeration {
          enum "1" {
            tailf:info "ITU-T QL option 2, generation 1";
          }
          enum "2" {
            tailf:info "ITU-T QL option 2, generation 2";
          }
        }
      }
      leaf ql2 {
        tailf:cli-drop-node-name;
        when "../option = '2'";
        type enumeration {
          enum DUS {
            tailf:info "This signal should not be used for "+
              "synchronization";
          }
          enum PRS {
            tailf:info "ITU-T Option 2, Primary reference source";
          }
          enum SMC {
            tailf:info "ITU-T Option 2, SONET clock self timed";
          }
          enum ST2 {
            tailf:info "ITU-T Option 2, Stratum 2";
          }
          enum ST3 {
            tailf:info "ITU-T Option 2, Stratum 3";
          }
          enum ST3E {
            tailf:info "ITU-T Option 2, Stratum 3E";
          }
          enum STU {
            tailf:info "ITU-T Option 2, Synchronized - "+
              "traceability unknown";
          }
          enum TNC {
            tailf:info "ITU-T Option 2, Transit node clock";
          }
        }
      }
    }
  }

    // router hsrp / interface * / address-family ipv4 / hsrp
  grouping router-hsrp-group-grouping {

    // router hsrp / interface * / address-family ipv4 / hsrp / address
    leaf address {
      tailf:info "Enable hot standby protocol for IP";
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Hot standby IP address";
        }
        type enumeration {
          enum learn {
            tailf:info "Learn virtual IP address from peer";
          }
        }
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / preempt
    container preempt {
      tailf:info "Force active if higher priority";
      tailf:cli-delete-when-empty;
      presence true;
      leaf delay {
        tailf:info "Wait before preempting";
        type uint16 {
          tailf:info "<0-3600>;;Number of seconds to delay";
          range "0..3600";
        }
        default 0;
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / priority
    leaf priority {
      tailf:info "Priority level";
      type uint8 {
        tailf:info "<0-255>;;Priority value";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / track *
    list track {
      tailf:info "Configure tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf priority-decrement {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Priority decrement";
          range "1..255";
        }
        default 10;
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / bfd fast-detect
    container bfd {
      tailf:info "Configure BFD parameters";
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-delete-when-empty;
        presence true;
        container peer {
          tailf:info "Information about HSRP peer for BFD monitoring";
          container ipv4 {
            tailf:info "BFD peer interface IPv4 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              //NCSBUG: cli-diff-dep breaks delete of ipve-address above:
              //tailf:cli-diff-dependency "/cisco-ios-xr:interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }

  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// configuration
  /// ========================================================================

  container configuration {
    tailf:info "Configuration related settings";
    tailf:cli-explicit-exit;

    container display {
      tailf:info "Display mode";
      container interface {
        tailf:info "hardware interfaces";
        leaf slot-order {
          tailf:info "Display interfaces in the slot-order in show run output";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "WORD;;This system's network name";
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {
    tailf:info "Configure time-of-day clock";
    tailf:cli-explicit-exit;

    leaf calendar-valid {
      tailf:info "Calendar time is authoritative";
      type empty;
    }
    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;name of time zone in summer";
        }
      }
      choice summer {
        case a {
          container date {
            tailf:info "Configure absolute summer time";
          }
        }
        case b {
          leaf recurring {
            type empty;
          }
          leaf start {
            tailf:cli-drop-node-name;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to start";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            type enumeration {
              enum monday;
              enum tuesday;
              enum wednesday;
              enum thursday;
              enum friday;
              enum saturday;
              enum sunday;
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            type month-type;
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            type string {
              pattern "[0-9][0-9]:[0-9][0-9]";
            }
          }
          leaf end {
            tailf:cli-drop-node-name;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to end";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf end-day {
            tailf:cli-drop-node-name;
            type enumeration {
              enum monday;
              enum tuesday;
              enum wednesday;
              enum thursday;
              enum friday;
              enum saturday;
              enum sunday;
            }
          }
          leaf end-month {
            tailf:cli-drop-node-name;
            type month-type;
          }
          leaf end-time {
            tailf:cli-drop-node-name;
            type string {
              pattern "[0-9][0-9]:[0-9][0-9]";
            }
          }
        }
      }
    }
    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;name of time zone";
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<-23 - 23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner motd
    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner login
    container login {
      tailf:info "Set login banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }
    // banner prompt-timeout
    container prompt-timeout {
      tailf:info "Set Message for login authentication timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }
  }


  /// ========================================================================
  /// exception
  /// ========================================================================

  container exception {
    tailf:info "Coredump configuration commands";
    tailf:cli-explicit-exit;

    // exception choice ? compress ? filepath ?
    container exception-filepath {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf "choice" {
        tailf:info "Preference for the following dump location";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-3>;;Order of preference";
          range "1..3";
        }
      }
      leaf compress {
        tailf:info "Compress the dump files";
        tailf:cli-incomplete-command;
        type enumeration {
          enum off {
            tailf:info "Do not compress core files dumped on this path";
          }
          enum on {
            tailf:info "Compress core files dumped on this path";
          }
        }
      }
      container filename {
        tailf:info "Dump file name";
        tailf:cli-optional-in-sequence;
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Filename";
          }
        }
        leaf limit {
          tailf:cli-drop-node-name;
          //!!fix cleaner
          type string {
            tailf:info "lowlimit-highlimit";
          }
        }
      }
      leaf filepath {
        tailf:info "Give the dump location next";
        type string {
          tailf:info "WORD;;Protocol and directory";
        }
      }
    }

    // exception sparse
    leaf sparse {
      tailf:info "control sparse core dump";
      tailf:cli-full-command;
      type enumeration {
        enum off {
          tailf:info "Disable sparse core dump";
        }
        enum on {
          tailf:info "Enable sparse core dump by default";
        }
      }
    }

    // exception sprsize
    leaf sprsize {
      tailf:info "Switch to sparse core dump at this size";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-4095>;;Switch to sparse core dump size in MB";
        range "1..4095";
      }
    }

    // exception coresize
    leaf coresize {
      tailf:info "Only print out stack trace and create no core file "+
        "beyond this size";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4095>;;Core file size max limit in MB";
        range "1..4095";
      }
    }

    // exception pakmem
    leaf pakmem {
      tailf:info "control pakmem in core";
      tailf:cli-full-command;
      type enumeration {
        enum off {
          tailf:info "Disable dump of packet memory by default";
        }
        enum on {
          tailf:info "Dump packet memory for all process";
        }
      }
    }

  }


  /// ========================================================================
  /// cef
  /// ========================================================================

  container cef {
    tailf:info "CEF related commands";
    container load-balancing {
      tailf:info "Load balance ";
      leaf fields {
        type enumeration {
          enum L3 {}
          enum L4 {}
        }
      }
    }
  }


  /// ========================================================================
  /// fpd
  /// ========================================================================

  container fpd {
    container auto-upgrade {
      presence true;
    }
  }


  /// ========================================================================
  /// explicit-path
  /// ========================================================================

  container explicit-path {
    tailf:info "Explicit-path config commands";

    // explicit-path name *
    list name {
      tailf:cli-mode-name "config-expl-path";
      key pathname;
      leaf pathname {
        type string {
          tailf:info "WORD;;Enter name";
        }
      }

      // explicit-path name * / index *
      list index {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key index-id;
        leaf index-id {
          type uint16 {
            tailf:info "<1-65535>;;Index number";
            range "1..65535";
          }
        }
        // explicit-path name * / index * next-address
        leaf keyword {
          tailf:cli-drop-node-name;
          type enumeration {
            enum exclude-address {
              tailf:info "Specify the next address to be excluded ";
            }
            enum exclude-srlg {
              tailf:info "Specify an IP Addr to get SRLGs from for exclusion";
            }
            enum next-address {
              tailf:info "Specify the next (adjacent) address in the path";
            }
          }
        }
        // explicit-path name * / index * next-address loose
        // explicit-path name * / index * next-address strict
        leaf hop-type {
          when "../keyword = 'next-address'";
          tailf:cli-optional-in-sequence;
          tailf:cli-drop-node-name;
          type enumeration {
            enum loose {
              tailf:info "Specify the next address in the path as a loose hop";
            }
            enum strict {
              tailf:info "Specify the next address in the path as a strict hop";
            }
          }
        }
        // explicit-path name * / index * ipv4 unicast
        container ipv4 {
          tailf:info "Specify the address AFI";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          leaf unicast {
            tailf:info "Specify the address SAFI";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address (A.B.C.D)";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================

  container vrf {
    tailf:info "VRF configuration commands";
    tailf:cli-explicit-exit;

    // vrf *
    list vrf-list {
      tailf:cli-mode-name "config-vrf";
      tailf:cli-drop-node-name;
      key name;
      leaf name {
        tailf:info "WORD;;VRF name";
        type string;
      }

      // vrf * / description
      leaf "description" {
        tailf:info "A description for the VRF";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description for this VRF";
        }
      }

      // vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address;
          type string {
            tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
          }
        }
      }

      // vrf * / address-family
      container address-family {
        tailf:info "AFI/SAFI configuration";
        // vrf * / address-family ipv4 unicast
        container ipv4 {
          tailf:info "IPv4 address family";
          container unicast {
            tailf:info "Unicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            // vrf * / address-family ipv4 unicast / import
            container "import" {
              tailf:info "VRF import";
              // vrf * / address-family ipv4 unicast / import route-policy
              leaf route-policy {
                tailf:info "Use route-policy for import filtering";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:route-policy/name";
                }
              }
              // vrf * / address-family ipv4 unicast / import route-target
              container route-target {
                tailf:info "Specify import route target extended communities";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vrf-import-rt";
                uses vrf-route-target-grouping;
              }
            }
            // vrf * / address-family ipv4 unicast / export
            container export {
              tailf:info "VRF export";

              // vrf * / address-family ipv4 unicast / export route-policy
              leaf route-policy {
                tailf:info "Use route-policy for export filtering";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:route-policy/name";
                }
              }

              // vrf * / address-family ipv4 unicast / export route-target
              container route-target {
                tailf:info "Specify export route target extended communities";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vrf-export-rt";
                uses vrf-route-target-grouping;
              }
            }
            // vrf * / address-family ipv4 unicast / maximum
            container maximum {
              tailf:info "Set maximum prefix limit";
              container "prefix" {
                tailf:info "Set table's maximum prefix limit";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-all-siblings;
                }
                leaf limit {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<32-5000000>;;Maximum table's prefix limit";
                    range "32..5000000";
                  }
                }
                leaf mid-thresh {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-100>;;mid-thresh (% of max)";
                    range "1..100";
                  }
                }
              }
            }
          }
        }
        // vrf * / address-family ipv6 unicast
        container ipv6 {
          tailf:info "IPv6 address family";
          container unicast {
            tailf:info "Unicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;

            // vrf * / address-family ipv6 unicast / import
            container "import" {
              tailf:info "VRF import";

              // vrf * / address-family ipv6 unicast / import route-policy
              leaf route-policy {
                tailf:info "Use route-policy for import filtering";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:route-policy/name";
                }
              }

              // vrf * / address-family ipv6 unicast / import route-target
              container route-target {
                tailf:info "Specify import route target extended communities";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vrf-import-rt";
                uses vrf-route-target-grouping;
              }
            }

            // vrf * / address-family ipv6 unicast / export
            container export {
              tailf:info "VRF export";

              // vrf * / address-family ipv6 unicast / export route-policy
              leaf route-policy {
                tailf:info "Use route-policy for export filtering";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:route-policy/name";
                }
              }

              // vrf * / address-family ipv6 unicast / export route-target
              container route-target {
                tailf:info "Specify export route target extended communities";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vrf-export-rt";
                uses vrf-route-target-grouping;
              }
            }

            // vrf * / address-family ipv6 unicast / maximum prefix
            container maximum {
              tailf:info "Set maximum prefix limit";
              container "prefix" {
                tailf:info "Set table's maximum prefix limit";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-all-siblings;
                }
                leaf limit {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<32-5000000>;;Maximum table's prefix limit";
                    range "32..5000000";
                  }
                }
                leaf mid-thresh {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-100>;;mid-thresh (% of max)";
                    range "1..100";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    // logging trap
    leaf trap {
      tailf:info "Set syslog server logging level";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging events
    container events {
      tailf:info "Configure event monitoring parameters";
      leaf level {
        tailf:info "Log all events with equal or higher (lower level) severity";
        type severity-type;
      }
      leaf link-status {
        tailf:info "Enable or disable UP/DOWN state notifications "+
          "for all interfaces";
        type enumeration {
          enum disable {
            tailf:info "Disable state UP/DOWN notifications for "+
              "all interfaces";
          }
          enum software-interfaces {
            tailf:info "Enable state UP/DOWN notification for "+
              "software interfaces";
          }
        }
      }
      leaf threshold {
        tailf:info "Configure threshold (%) for capacity alarm";
        type uint8 {
          tailf:info "<10-100>;;Capacity alarm threshold";
        }
      }
    }

    // logging archive
    container archive {
      tailf:info "logging to a persistent device(disk/harddisk)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-logging-arch";
      leaf device {
        tailf:info "Configure the archive device";
        type string;
      }
      leaf severity {
        tailf:info "The minimum severity of log messages to archive";
        type severity-type;
      }
      leaf file-size {
        tailf:info "The maximum file size for a single log file";
        type uint32 {
          tailf:info "<1-2047>;;Size in MB";
          range "1..2047";
        }
      }
      leaf frequency {
        tailf:info "The collection interval for logs";
        type enumeration {
          enum daily {
            tailf:info "Collect log in files on a daily basis";
          }
          enum weekly {
            tailf:info "Collect log in files on a weekly basis";
          }
        }
      }
      leaf archive-size {
        tailf:info "The total size of the archive";
        type uint32 {
          tailf:info "<1-2047>;;Size in MB";
          range "1..2047";
        }
      }
      leaf archive-length {
        tailf:info "The maximum no of weeks of log to maintain";
        type uint32 {
          tailf:info "<0-4294967295>;;Number of weeks";
        }
      }
    }

    // logging monitor
    leaf monitor {
      tailf:info "Set terminal line (monitor) logging parameters";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";
      leaf "type" {
        tailf:cli-drop-node-name;
        type union {
          type uint32 {
            tailf:info "<4096-2147483647>;;Logging buffer size";
            range "4096..2147483647";
          }
          type severity-type;
        }
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum local0;
          enum local1;
          enum local2;
          enum local3;
          enum local4;
          enum local5;
          enum local6;
          enum local7;
        }
        type string;
      }
    }

    // logging host *
    list host {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type inet:host {
          tailf:info "A.B.C.D or X:X::X;;IP v4/v6 address of the logging host";
        }
      }
      leaf vrf {
        tailf:info "Set VRF option";
        type string {
          tailf:info "WORD  VPN Routing/Forwarding instance name";
        }
      }
      leaf severity {
        tailf:info "Set severity of  messages for particular remote host/vrf";
        type severity-type;
      }
    }

    // logging localfilesize
    leaf localfilesize {
      tailf:info "Set size of the local log file";
      type uint32 {
        tailf:info "<0-4294967295>;;Size of the local log file";
      }
    }

    // logging source-interface
    container source-interface {
      tailf:info "Specify interface for source address in logging"
        +" transactions";
      tailf:cli-diff-dependency "/cisco-ios-xr:interface";
      uses interface-name-grouping;
    }

    // logging cns-events
    container cns-events {
      tailf:info "Set CNS Event logging level";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf severity {
        type severity-type;
      }
    }

    // logging console
    leaf console {
      tailf:info "Set console logging parameters";
      tailf:cli-full-command;
      type union {
        type severity-type;
        type enumeration {
          enum disable {
            tailf:info "Disable logging";
          }
        }
      }
    }

    // logging count
    leaf count {
      tailf:info "Count every log message and timestamp last occurance";
      tailf:cli-full-command;
      type empty;
    }

    // logging history
    leaf history {
      tailf:info "Set history logging";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging persistent
    container persistent {
      tailf:info "Set persistent logging parameters";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-compact-syntax;
      leaf url {
        tailf:info "URL to store logging messages";
        type string;
      }
      leaf size {
        tailf:info "Set disk space for writing log messages";
        type uint32 {
          tailf:info "<16384-1024557056>;;Logging filesystem size";
          range "16384..1024557056";
        }
      }
      leaf filesize {
        tailf:info "Set size of individual log files";
        type uint32 {
          tailf:info "<8192-1024557056>;;Logging file size";
          range "8192..1024557056";
        }
      }

      leaf batch {
        tailf:info "Set batch size for writing to persistent storage";
        type uint32 {
          tailf:info "<4096-1024557056>;;Batch size for writing to "
            +"persistent storage";
          range "4096..1024557056";
        }
      }
    }

    // logging suppress
    container suppress {
      tailf:info "Configure properties for the event suppression";
      // logging suppress duplicates
      leaf duplicates {
        tailf:info "Suppress consecutive duplicate messages";
        tailf:cli-full-command;
        type empty;
      }
      // logging suppress rule *
      list rule {
        tailf:info "Configure a specified suppression rule";
        tailf:cli-mode-name "config-suppr-rule";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Rule name";
          }
        }
        list alarm {
          tailf:info "Specify alarm: Category/Group/Code combos";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "msg-category group-name msg-code";
          leaf msg-category {
            type string {
              tailf:info "WORD;;Message category of the suppressed message";
            }
          }
          leaf group-name {
            type string {
              tailf:info "WORD;;Group name of suppressed message";
            }
          }
          leaf msg-code {
            type string {
              tailf:info "WORD;;Message code of suppressed message";
            }
          }
        }
      }
      // logging suppress apply
      container apply {
        tailf:info "Apply suppression rule";
        list rule {
          tailf:info "Apply suppression rule";
          tailf:cli-mode-name "config-suppr-apply-rule";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:logging/suppress/rule/name";
            }
          }
          leaf all-of-router {
            tailf:info "Apply the rule to all of the router";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }

    // logging hostnameprefix
    leaf hostnameprefix {
      tailf:info "Hostname prefix to add on msgs to servers";
      tailf:cli-full-command;
      type string;
    }

  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";
    tailf:cli-explicit-exit;

    container alignment {
      tailf:info "Control alignment correction and logging";
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        tailf:cli-full-command;
        type empty;
      }
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        tailf:cli-full-command;
        type empty;
      }
    }
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }
    leaf compress-config {
      tailf:info "Compress the nvram configuration file";
      type empty;
      tailf:cli-full-command;
    }
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";
        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds";
          }
        }
      }
    }
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      tailf:cli-full-command;
      type empty;
    }
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      type empty;
    }
    leaf exec-callback {
      tailf:info "Enable exec callback";
      type empty;
    }
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      type empty;
    }
    leaf finger {
      tailf:info "Allow responses to finger requests";
      type empty;
    }
    container heartbeat {
      tailf:info "Enable heartbeat processing";
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          range "1..60";
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
        }
      }
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          range "0..60";
          tailf:info "<0-60>;;Interval between interrupt level tests";
        }
      }
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
          range "5..60";
        }
      }
    }
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      type empty;
    }
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      type empty;
    }
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      type empty;
    }
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      type empty;
    }
    container pad {
      tailf:info "Enable PAD commands";
      presence true;
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        type empty;
      }
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        type empty;
      }
    }
    leaf password-encryption {
      tailf:info "Encrypt system passwords";
      type empty;
    }
    container prompt {
      tailf:info "Enable mode specific prompt";
      leaf "config" {
        tailf:info "Enable configuration mode prompt";
        type empty;
      }
    }
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      type empty;
    }
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      type empty;
    }
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      type empty;
    }
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      type empty;
      tailf:cli-full-command;
    }
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      type empty;
      tailf:cli-full-command;
    }

    // service tcp-small-servers
    container tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      presence true;
      leaf max-servers {
        tailf:info "Set number of allowable TCP small servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Maximum TCP small servers";
            range "1..2147483647";
          }
          type enumeration {
            enum "no-limit" {
              tailf:info "No limit to number of allowable TCP small servers";
            }
          }
        }
      }
    }

    // service telnet-zeroidle
    leaf telnet-zeroidle {
      tailf:info "Set TCP window 0 when connection is idle";
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";
        choice log-time-choice {
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";
        choice log-time-choice {
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
        }
      }
    }

    // service udp-small-servers
    container udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      presence true;
      leaf max-servers {
        tailf:info "Set number of allowable UDP small servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Maximum UDP small servers";
            range "1..2147483647";
          }
        }
      }
    }

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related commands";
    tailf:cli-explicit-exit;

    container manager {
      tailf:info "Event Manager configuration commands";
      /// event manager directory
      container directory {
        tailf:info "Set Embedded Event Manager directory information";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        container user {
          tailf:info "Set Embedded Event Manager user directory information";
          choice emdu-choice {
            leaf policy {
              tailf:info "Set Embedded Event Manager user policy directory";
              type string;
            }
            leaf library {
              tailf:info "Set Embedded Event Manager user library directory";
              type string;
            }
          }
        }
      }
      /// event manager policy
      list policy {
        tailf:info "Register an Event Manager policy";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the policy file";
          }
        }
        leaf username {
          tailf:info "Username under whom this policy will execute";
          type string;
        }
        leaf persist-time {
          tailf:info "Time of validity (in seconds) for cached AAA "+
            "taskmap of username (default is 3600)";
          tailf:cli-break-sequence-commands;
          type union {
            type enumeration {
              enum infinite {
                tailf:info "Cached AAA taskmap of username is always "+
                  "treated valid";
              }
            }
            type uint32 {
              tailf:info "<0-4294967294>;;Integer value for this policy's "+
                "persist-time";
            }
          }
        }
        leaf "type" {
          tailf:info "The Event Manager type of this policy";
          type enumeration {
            enum system {
              tailf:info "Event Manager system policy";
            }
            enum user {
              tailf:info "Event Manager user policy";
            }
          }
        }
      }
      /// event manager environment
      list environment {
        tailf:info "Set an Embedded Event Manager global variable for "+
          "policies";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the global variable";
          }
        }
        leaf var-value {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Value of the global variable";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// domain
  /// ========================================================================

  container domain {
    tailf:info "Domain service related commands";
    tailf:cli-explicit-exit;

    // domain ipv6
    container ipv6 {
      tailf:info "Ipv6 hosts";
      list host {
        tailf:info "Add an entry to the ipv6 hostname table";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key host-name;
        leaf host-name {
          type string;
        }
        leaf-list address {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          max-elements 4;
          type string;
        }
      }
    }

    // domain lookup
    container lookup {
      tailf:info "Enable Domain Name System hostname translation";
      // domain lookup disable
      leaf disable {
        tailf:info "Disable Domain Name System hostname translation";
        tailf:cli-full-command;
        type empty;
      }
      // domain lookup source-interface
      container source-interface {
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }
    }

    // domain name
    leaf name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // domain list
    leaf "list" {
      tailf:info "Domain name to complete unqualified host names";
      type string {
        tailf:info "WORD;;A domain name";
      }
    }

    // domain name-server
    list name-server {
      tailf:info "Specify address of name server to use";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key address;
      leaf address {
        type inet:host;
      }
    }

    // domain vrf *
    list vrf {
      tailf:info "VRF name for domain services";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;VRF name";
        }
      }
      leaf name {
        tailf:info "Define the default domain name";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }
      container lookup {
        tailf:info "Enable Domain Name System hostname translation";
        tailf:cli-reset-container;
        leaf disable {
          tailf:info "Disable Domain Name System hostname translation";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// taskgroup
  /// ========================================================================

  list taskgroup {
    tailf:info "Configure task group";
    tailf:cli-mode-name "config-tg";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Taskgroup name";
      }
    }
    // taskgroup * / task
    container task {
      tailf:info "Specify a task ID to be part of this group";
      // taskgroup * / task execute *
      list execute {
        tailf:info "Specify a execute-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }
      // taskgroup * / task read *
      list read {
        tailf:info "Specify a read-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }
      // taskgroup * / task write *
      list write {
        tailf:info "Specify a write-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }
    }
    // taskgroup * / inherit
    container inherit {
      tailf:info "Inherit to include into this taskgroup";
      list taskgroup {
        tailf:info "Specify a taskgroup to inherit from";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the task group to include";
          }
        }
      }
    }
    // taskgroup * / description
    leaf "description" {
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string;
    }
  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS configuration commands";
    tailf:cli-explicit-exit;

    // radius source-interface
    container source-interface {
      tailf:info "Specify interface for source address in RADIUS packets";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-diff-dependency "/cisco-ios-xr:interface";
      uses interface-name-grouping;
      leaf vrf {
        tailf:info "VRF for this source interface configuration";
        type string {
          tailf:info "WORD;;Name of the VRF";
        }
      }
    }
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "RADIUS server definition";
    tailf:cli-explicit-exit;

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-mode-name "config-radius-host";
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type string {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }
      // radius-server host * auth-port
      leaf auth-port {
        tailf:info "UDP port for RADIUS authentication server (default is "
          +"1645)";
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<0-65535>;;Authentication port number";
          range "0..65535";
        }
      }
      // radius-server host * acct-port
      leaf acct-port {
        tailf:info "UDP port for RADIUS accounting server (default is 1646)";
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<0-65535>;;Accounting port number";
          range "0..65535";
        }
      }

      // radius-server host * / key
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        uses key-grouping;
      }
      // radius-server host * / timeout
      leaf timeout {
        tailf:info "Time to wait for this RADIUS server to reply "+
          "(overrides global timeout)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait "+
            "for server to reply";
          range "1..1000";
        }
      }
      // radius-server host * / retransmit
      leaf retransmit {
        tailf:info "Number of times a RADIUS request is re-sent to a server "+
          "(overrides global retransmit value)";
        type uint8 {
          tailf:info "<1-100>;;Retransmit value";
        }
      }
    }
  }


  /// ========================================================================
  /// usergroup
  /// ========================================================================

  list usergroup {
    tailf:info "Configure user group";
    tailf:cli-mode-name "config-ug";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:taskgroup";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Usergroup name";
      }
    }

    leaf-list taskgroup {
      tailf:info "Task group associated with this group";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;Name of the task group";
      }
    }
  }


  /// ========================================================================
  /// netconf
  /// ========================================================================

  container xnetconf {
    tailf:info "NETCONF configuration commands";
    tailf:alt-name netconf;
    tailf:cli-explicit-exit;

    container agent {
      tailf:info "NETCONF agent configuration commands";
      container tty {
        tailf:info "Enable NETCONF agent over TTY";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-netconf-tty";
        container session {
          tailf:info "Session timeout for transport agents";
          leaf timeout {
            tailf:info "Session timeout for agents";
            type uint16 {
              tailf:info "<1-1440>;;Timeout in minutes";
            }
          }
        }
        container throttle {
          tailf:info "Configuration for throttling NETCONF agent";
          leaf memory {
            tailf:info "Memory usage";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<100-600>;;Size of the memory usage in Mbytes "+
                "per session (default 300 Mbytes)";
              range "100..600";
            }
          }
          leaf process-rate {
            tailf:info "Process rate";
            type uint16 {
              tailf:info "<1000-30000>;;Number of tags to process per sec";
              range "1000..30000";
            }
          }
        }
      }
      leaf ssh {
        tailf:info "Enable NETCONF agent over SSH connection";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// nsr
  /// ========================================================================

  container nsr {
    tailf:info "Global NSR configuration commands";
    tailf:cli-explicit-exit;

    leaf process-failures {
      tailf:info "Recovery action for Process failures on active RP/DRP";
      type enumeration {
        enum switchover {
          tailf:info "Switch over to standby RP/DRP to maintain NSR";
        }
      }
    }
  }


  /// ========================================================================
  /// ftp
  /// ========================================================================

  container ftp {
    tailf:info "Global FTP configuration commands";
    tailf:cli-explicit-exit;

    container client {
      tailf:info "FTP client configuration commands";
      // ftp client passive
      leaf passive {
        tailf:info "Connect using passive mode";
        type empty;
      }
      // ftp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in FTP connections";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// icmp
  /// ========================================================================

  container icmp {
    tailf:info "ICMP options";
    tailf:cli-explicit-exit;

    container ipv4 {
      tailf:info "IPv4 specific";
      container source {
        tailf:info "source address selection policy";
        // icmp ipv4 source rfc
        leaf rfc {
          tailf:info "Enable RFC compliance for source address selection";
          tailf:cli-full-command;
          type empty;
        }
        // icmp ipv4 source vrf
        leaf vrf {
          tailf:info "Enable Strct VRF source address selection";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Go into NTP submode";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // ntp max-associations
    leaf max-associations {
      tailf:info "Set maximum number of associations";
      type uint32 {
        tailf:info "<0-4294967295>;;Number of associations";
      }
    }

    // ntp server *
    container server {
      tailf:info "Configure NTP server";
      uses ntp-server-grouping;
      // ntp server vrf *
      list vrf {
        tailf:info "Specify non-default VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        uses ntp-server-grouping;
      }
    }

    // ntp access-group *
    list access-group {
      tailf:info "Control NTP access";
      tailf:cli-suppress-list-no;
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key "type name";
      leaf "type" {
        type enumeration {
          enum peer {
            tailf:info "Provide full access";
          }
          enum query-only {
            tailf:info "Allow only control queries";
          }
          enum serve {
            tailf:info "Provide server and query access";
          }
          enum serve-only {
            tailf:info "Provide only server access";
          }
        }
      }
      leaf name {
        tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        tailf:cli-diff-dependency "/cisco-ios-xr:ipv6/access-list/named-acl/name";
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
      }
      leaf vrf {
        tailf:info "Specify non-default VRF";
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Non-default VRF of peer";
        }
      }
      leaf version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Configure IPv4 access";
          }
          enum ipv6 {
            tailf:info "Configure IPv6 access";
          }
        }
      }
    }

    // ntp master
    leaf master {
      tailf:info "Choose a refclock as master clock for NTP";
      tailf:cli-full-command;
      type uint16;
    }

    // ntp source
    container source {
      tailf:info "Configure default interface";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-diff-dependency "/cisco-ios-xr:interface";
      uses interface-name-grouping;
    }

    // ntp update-calendar
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// telnet
  /// ========================================================================

  container telnet {
    tailf:info "Global Telnet configuration commands";
    tailf:cli-explicit-exit;

    // telnet ipv4 client source-interface
    container ipv4 {
      tailf:info "IPv4 configuration";
      container client {
        tailf:info "Telnet client configuration commands";
        container source-interface {
          tailf:info "Source interface for telnet sessions";
          tailf:cli-diff-dependency "/cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
    }

    // telnet ipv6 client source-interface
    container ipv6 {
      tailf:info "IPv6 configuration";
      container client {
        tailf:info "Telnet client configuration commands";
        container source-interface {
          tailf:info "Source interface for telnet sessions";
          tailf:cli-diff-dependency "/cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
    }

    // telnet *
    uses telnet-server-grouping;

    // telnet vrf *
    list vrf {
      tailf:info "VRF name for telnet server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
      key name;
      leaf name {
        type vrf-type;
      }
      uses telnet-server-grouping;
    }
  }


  /// ========================================================================
  /// alias
  /// ========================================================================

  list alias {
    tailf:info "Create an alias for entity";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-reset-container;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Alias name";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE  Alias body with optional parameters e.g,(name) "+
          "show $name";
      }
    }
  }


  /// ========================================================================
  /// bfd
  /// ========================================================================

  container bfd {
    tailf:info "Global BFD configuration commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-bfd";
    tailf:cli-explicit-exit;

    // bfd / echo
    container echo {
      tailf:info "Configure BFD echo parameters";
      leaf disable {
        tailf:info "Disable BFD echo mode";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }

    // bfd / trap
    container trap {
      tailf:info "Configure BFD trap parameters";
      container singlehop {
        tailf:info "Configure BFD mode";
        leaf pre-mapped {
          tailf:info "Configure BFD trap pre-mapped";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// tftp
  /// ========================================================================

  container tftp {
    tailf:info "Global TFTP configuration commands";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl";
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    // tftp client
    container client {
      tailf:info "TFTP client configuration commands";
      // tftp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        uses interface-name-grouping;
      }
    }

    // tftp *
    uses tftp-server-grouping;

    // tftp vrf *
    list vrf {
      tailf:info "VRF name for tftp server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of VRF";
        }
      }
      uses tftp-server-grouping;
    }
  }


  /// ========================================================================
  /// nv
  /// ========================================================================

  container nv {
    tailf:info "Network Virtualisation configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-nV";
    tailf:cli-explicit-exit;

    // nv / optical
    container optical {
      tailf:cli-add-mode;
      list satellite {
        tailf:info "Satellite configuration";
        key name;
        leaf name {
          tailf:info "Satellite ID";
          type uint32;
        }
        container ipv6 {
          leaf address {
            type inet:ipv6-address;
          }
        }
        leaf username {
          type string;
        }
        leaf password {
          type string;
        }
        container trunk {
          list slot {
            key slot-number;
            leaf slot-number {
              type uint32;
            }
            leaf port {
              type uint32;
            }
            leaf local-port {
              type string; //FIXME: interface name as interface-grouping
            }
          }
        }
      }
    }

    // nv / controller
    container controller {
      list dwdm {
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        key id;
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
          }
        }

        leaf admin-state {
          type enumeration {
            enum in-service;
            enum maintenance;
            enum out-of-service;
          }
        }

        leaf description {
          tailf:cli-multi-value;
          type string;
        }

        container g709 {
          tailf:cli-add-mode;
          leaf fec {
            type enumeration {
              enum high-gain;
              enum disable;
              enum enhanced;
              enum standard;
            }
          }
        }

        container proactive {
          tailf:cli-add-mode;
          container revert {
            container threshold {
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                type uint8 {
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  range "3..9";
                }
              }
            }
            leaf window {
              type uint32;
            }
          }
          container trigger {
            container threshold {
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                type uint8 {
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  range "3..9";
                }
              }
            }
            leaf window {
              type uint32;
            }
          }
        }

        leaf transmit-power {
          type int16 {
            range "-190..10";
          }
        }

        leaf transmit-shutdown {
          type empty;
        }

        container wavelength {
          tailf:cli-compact-syntax;
          leaf channel-number {
            tailf:cli-drop-node-name;
            type uint32;
          }
          leaf frequency {
            type uint32;
          }
          leaf update {
            type uint32;
          }
        }
      }

      // HundredGigE
      list HundredGigE {
        tailf:cli-allow-join-with-key;

        key id;
        leaf id {
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
          }
        }

        leaf admin-state {
          type enumeration {
            enum in-service;
            enum maintenance;
            enum out-of-service;
          }
        }
      }
    }

    // nv / satellite *
    list satellite {
      tailf:info "ICPE satellite configuration";
      tailf:cli-mode-name "config-satellite";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<100-65534>;;Satellite ID";
          range "100..65534";
        }
      }
      leaf "type" {
        tailf:info "Satellite type";
        type string {
          tailf:info "WORD;;Satellite type";
        }
      }
      container ipv4 {
        tailf:info "IPv4 address";
        leaf address {
          tailf:info "IPv4 address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";
    tailf:cli-explicit-exit;

    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
    }

    container secret {
      tailf:info "Assign the privileged level secret (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf "type" {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  list username {
    tailf:info "Configure user name";
    tailf:cli-mode-name "config-un";
    tailf:cli-explicit-exit;

    key name;
    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    // username * / group *
    list group {
      tailf:info "User group in which this user will be a member of";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the user group";
        }
      }
    }

    // username * / password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf "password" {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }

    // username * / privilege
    leaf privilege {
      tailf:info "Set user privilege level";
      type uint8 {
        tailf:info "<0-15>;;User privilege level";
        range "0..15";
      }
    }

    // username * / secret
    container secret {
      //FIXME: Model as choice
      tailf:info "Specify the secure password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;The user password string";
        }
      }
    }

  }


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "TACACS+ server definition";
    tailf:cli-explicit-exit;

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS+ server";
      tailf:cli-compact-syntax;
      tailf:cli-mode-name "config-tacacs-host";
      key "name port";
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D  IP address of TACACS+ server";
        }
      }
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        tailf:cli-expose-key-name;
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum 0 {
              tailf:info "Specifies that an UNENCRYPTED key will follow";
            }
            enum 7 {
              tailf:info "Specifies that an encrypted key will follow";
            }
          }
        }
        leaf "key" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
          }
        }
      }
    }

    // tacacs-server key
    container "key" {
      tailf:info "Set TACACS+ encryption key";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED key will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted key will follow";
          }
        }
      }
      leaf "key" {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
    }

  }


  /// ========================================================================
  /// tacacs
  /// ========================================================================

  container tacacs {
    tailf:info "TACACS+ configuration commands";
    tailf:cli-explicit-exit;

    // tacacs source-interface
    container source-interface {
      tailf:info "Specify interface for source address in TACACS+ packets";
      tailf:cli-diff-dependency "/cisco-ios-xr:interface";
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      uses interface-name-grouping;
      leaf vrf {
        tailf:info "VRF for this source interface configuration";
        type string {
          tailf:info "WORD;;Name of the VRF";
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-explicit-exit;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions."
        +" (Disables OLD commands.)";
      tailf:cli-full-command;
      type empty;
    }

    // aaa group
    container group {
      tailf:info "AAA group definitions";
      container server {
        tailf:info "AAA Server group definitions";
        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }
          container server {
            tailf:info "Specify a RADIUS server";
            list name {
              tailf:info "WORD;;Name of radius server";
              key name;
              leaf name {
                type string {
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:aaa/group/server/radius/name";
                }
              }
            }
            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of"
                    +" RADIUS server";
                }
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server"
                  +" (default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }

              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server"
                  +" (default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }
          container ip {
            tailf:info "Internet Protocol config commands";
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                type string {
                  tailf:info "WORD;;Table name";
                }
              }
            }
          }
        }
        // aaa group server tacacs+ *
        list tacacs {
          tailf:alt-name "tacacs+";
          tailf:info "tacacs+  TACACS+ server-group definition";
          tailf:cli-mode-name "config-sg-tacacs";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
          leaf-list server {
            tailf:info "Specify a TACACS+ server";
            tailf:cli-list-syntax;
            type inet:host {
              tailf:info "Hostname or A.B.C.D IP address or "+
                "Hostname of TACACS+ server";
            }
          }
          leaf vrf {
            tailf:info "VRF to which this server group belongs to";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Name of the VRF";
            }
          }
        }
      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";
      // aaa authentication login
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named authentication list (max 31 characters,"
              +"longer will be rejected).";
            length "1..31";
          }
        }
        leaf local {
          tailf:info "Use local username authentication.";
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        leaf none {
          tailf:cli-full-command;
          tailf:info "NO authentication.";
          type empty;
        }
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";

      // aaa authorization commands *
      list commands {
        tailf:info "For EXEC (shell) commands";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf group {
          tailf:info "Use server-group.";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        leaf local {
          tailf:info "Use local database.";
          type empty;
        }
        leaf none {
          tailf:info "No authorization (always succeeds).";
          tailf:cli-full-command;
          type empty;
        }
      }
      // aaa authorization exec
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf group {
          tailf:info "Use server-group.";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        leaf local {
          tailf:info "Use local database.";
          type empty;
        }
        leaf none {
          tailf:info "No authorization (always succeeds).";
          tailf:cli-full-command;
          type empty;
        }
      }
      // aaa authorization eventmanager
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf group {
          tailf:info "Use server-group.";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        leaf local {
          tailf:info "Use local database.";
          type empty;
        }
        leaf none {
          tailf:info "No authorization (always succeeds).";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";
      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf notice {
          tailf:cli-drop-node-name;
          type enumeration {
            enum start-stop {
              tailf:info "start and stop records";
            }
            enum stop-only {
              tailf:info "stop records only";
            }
          }
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }
      // aaa accounting system *
      list system {
        tailf:info "For System events";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf start-stop {
          tailf:info "start and stop records";
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }
      // aaa accounting network *
      list network {
        tailf:info "For network services (such as IKE, PPP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf notice {
          tailf:cli-drop-node-name;
          type enumeration {
            enum start-stop {
              tailf:info "start and stop records";
            }
            enum stop-only {
              tailf:info "stop records only";
            }
          }
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }
      // aaa accounting commands *
      list commands {
        tailf:info "For EXEC (shell) commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf notice {
          tailf:cli-drop-node-name;
          type enumeration {
            enum start-stop {
              tailf:info "start and stop records";
            }
            enum stop-only {
              tailf:info "stop records only";
            }
          }
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }
    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-full-command;
      type enumeration {
        enum common {
          tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }

    // aaa default-taskgroup
    leaf default-taskgroup {
      tailf:info "Default taskgroup to be used for remote authentication";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the taskgroup to be used";
      }
    }
  }


  /// ========================================================================
  /// cdp
  /// ========================================================================

  container cdp {
    tailf:info "Enable CDP, or configure global CDP subcommands";
    presence true;
    tailf:cli-display-separated;

    // cdp timer
    leaf timer {
      tailf:info "Specify the rate at which CDP packets are sent (in sec)";
      type uint8 {
        tailf:info "<5-254>;;Rate at which CDP packets are sent (in sec)";
        range "5..254";
      }
    }
  }


  /// ========================================================================
  /// tcp
  /// ========================================================================

  container tcp {
    tailf:info "Global TCP configuration commands";
    tailf:cli-explicit-exit;

    // tcp mss
    leaf mss {
      tailf:info "Set the TCP initial maximum segment size";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<68-10000>;;TCP initial maximum segment size";
        range "68..10000";
      }
    }

    // tcp selective-ack
    leaf selective-ack {
      tailf:info "Enable TCP selective-ACK";
      type empty;
    }


    // tcp path-mtu-discovery
    container path-mtu-discovery {
      tailf:info "Enable Path MTU Discovery on new TCP connections";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf age-timer {
        type union {
          type uint8 {
            tailf:info "<10-30>;;Aging time (in minutes)";
          }
          type enumeration {
            enum infinite {
              tailf:info "Disable Path MTU aging timer";
            }
          }
        }
      }
    }

    // tcp timestamp
    leaf timestamp {
      tailf:info "Enable TCP timestamp option";
      type empty;
    }

    // tcp directory
    container directory {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf directory {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Place debug files in this directory";
        }
      }
      leaf files {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum debug files";
        type uint16 {
          tailf:info "<1-10000>;;Maximum debug files";
        }
      }
      leaf size {
        tailf:info "Set maximum file size";
        type uint32 {
          tailf:info "<1024-4294967295>;;Maximum file size in bytes";
          range "1024..4294967295";
        }
      }
    }

    // tcp window-size
    leaf window-size {
      tailf:info "TCP receive window size";
      type uint32 {
        tailf:info "<2048-65535>;;Window size (bytes)";
      }
    }

  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Line subcommands";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl/name";
    tailf:cli-diff-dependency "/cisco-ios-xr:ipv6/access-list/named-acl/name";

    // line console
    container console {
      tailf:info "console template";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      uses line-grouping;
    }

    // line default
    container "default" {
      tailf:info "default template";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      uses line-grouping;
    }

    // line template *
    list template {
      tailf:info "user defined template";
      tailf:cli-mode-name "config-line";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of template to configure";
        }
      }
      uses line-grouping;
    }
  }


  /// ========================================================================
  /// vty-pool
  /// ========================================================================

  container vty-pool {
    tailf:info "VTY Pools";
    tailf:cli-explicit-exit;

    container "default" {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses vty-pool-grouping;
    }
    container eem {
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      uses vty-pool-grouping;
    }
    list pool-name-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key pool-name;
      leaf pool-name {
        type string;
        tailf:cli-disallow-value "(eem|default)";
      }
      uses vty-pool-grouping;
    }
  }


  /// ========================================================================
  /// aps
  /// ========================================================================

  container aps {
    tailf:info "Configure SONET Automatic Protection Switching (APS)";
    tailf:cli-explicit-exit;

    list group {
      tailf:info "APS group to configure";
      tailf:cli-mode-name "config-aps";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Group number";
          range "1..255";
        }
      }
      container timers {
        tailf:info "Set APS W-P communication timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf hello {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Hello timer in seconds (default 1)";
            range "1..255";
          }
        }
        leaf hold {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Hold timer in seconds (default 3)";
            range "1..255";
          }
        }
      }
      list channel {
        tailf:info "Assign a channel to an APS group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands  {
          tailf:cli-reset-siblings;
        }
        key "id location";
        leaf id {
          type uint8 {
            tailf:info "<0-1>;;Channel number (0 = Protect, 1 = Working)";
            range "0..1";
          }
        }
        leaf location {
          type enumeration {
            enum local {
              tailf:info "Channel assignment to a local port";
            }
          }
        }
        leaf preconfigure {
          tailf:info "Specify a preconfig";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf sonet {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "SONET;;SONET/SDH Port controller(s)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  container platform {
    tailf:info "platform specific configuration";
    tailf:cli-explicit-exit;

    // platform ip
    container ip {
      tailf:info "ip keyword";
      container cef {
        tailf:info "cef keyword";
        leaf load-sharing {
          tailf:info "load balancing";
          type enumeration {
            enum dst-only {
              tailf:info "load balancing algorithm to include"
                +" destination IP/L4 port";
            }
            enum full {
              tailf:info "default load balancing algorithm to include"
                +" src/dst IPs/L4 ports";
            }
            enum ip-only {
              tailf:info "load balancing algorithm to include src/dst IP";
            }
          }
        }
      }
    }
    container qos {
      tailf:info "qos keyword";
      leaf "qos-10g-only" {
        tailf:alt-name "10g-only";
        tailf:info "qos pure 10G mode";
        type empty;
      }
      list protocol {
        tailf:info "protocol keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key proto;
        leaf proto {
          type enumeration {
            enum isis;
            enum eigrp;
            enum ldp;
            enum ospf;
            enum rip;
            enum bgp;
            enum hsrp;
            enum bfd;
            enum ospfv3;
            enum bgpv2;
            enum ripng;
            enum neigh-discover;
            enum wlccp;
            enum rsvp;
            enum rsvpv6;
            enum arp;
            enum gre {
              tailf:info "gre (ipv4 and ipv6)";
            }
            enum mpls {
              tailf:info "mpls packet";
            }
          }
        }

        choice proto-choice {
          leaf pass-through {
            tailf:info "pass-through keyword";
            type empty;
          }
          container police {
            tailf:info "police keyword";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-sequence-commands;
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<32000-128000000000>;;Target Bit Rate (bits"
                  +" per second) "
                  +"(postfix k, m, g optional; decimal point allo";
                range "32000..128000000000";
              }
            }

            leaf burst {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2000000000>;;Normal burst bytes";
                range "1..2000000000";
              }
            }
          }
          container precedence {
            tailf:info "change ip-precedence(used to map the dscp to"
              +" cos value)";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-sequence-commands;
            leaf cos {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;new cos value";
                range "0..7";
              }
            }
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<32000-128000000000>;;Target Bit Rate"
                  +" (bits per second) "
                  +"(postfix k, m, g optional; decimal point allo";
                range "32000..128000000000";
              }
            }
            leaf burst {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2000000000>;;Normal burst bytes";
                range "1..2000000000";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  container control-plane {
    tailf:info "Configure Control Plane";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-ctrl";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    // control-plane / management-plane
    container management-plane {
      tailf:info "Configure management plane protection";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpp";

      // control-plane / management-plane / inband
      container inband {
        tailf:info "Configure an inband interface/protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpp-inband";

        // control-plane / management-plane / inband / interface *
        list interface {
          tailf:info "Configure an inband interface";
          tailf:cli-mode-name "config-mpp-inband-xxx";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          list allow {
            tailf:info "Allow a protocol on this interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key proto;
            leaf proto {
              type control-plane-proto;
            }
          }
          // control-plane / management-plane / inband / interface * / ..
          // .. allow all peer
          container allow-peer {
            tailf:cli-drop-node-name;
            list allow {
              tailf:info "Allow a protocol on this interface";
              tailf:cli-mode-name "config-xxx-peer";
              key "proto peer";
              leaf proto {
                type control-plane-proto;
              }
              leaf peer {
                type enumeration {
                  enum peer {
                    tailf:info "Configure peer address on this interface";
                  }
                }
              }
              container address {
                tailf:info "Configure peer address on this interface";
                // address ipv4 *
                list ipv4 {
                  tailf:info "Configure peer IPv4 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix";
                  leaf "prefix" {
                    type union {
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Enter IPv4 address";
                      }
                      type ipv4-prefix {
                        tailf:info "A.B.C.D/length;;Enter IPv4 address "+
                          "with prefix";
                      }
                    }
                  }
                }
                // address ipv6 *
                list ipv6 {
                  tailf:info "Configure peer IPv6 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix";
                  leaf "prefix" {
                    type union {
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Enter IPv6 address";
                      }
                      type ipv6-prefix {
                        tailf:info "X:X::X/length;;Enter IPv6 address with "+
                          "prefix";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // control-plane / management-plane / out-of-band
      container out-of-band {
        tailf:info "Configure an out-of-band interface/protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpp-outband";

        // control-plane / management-plane / out-of-band / interface *
        list interface {
          tailf:info "Configure an outband interface";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          list allow {
            tailf:info "Allow a protocol on this interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key proto;
            leaf proto {
              type control-plane-proto;
            }
          }
          container allow-peer {
            tailf:cli-drop-node-name;
            list allow {
              tailf:info "Allow a protocol on this interface";
              key "proto peer";
              leaf proto {
                type control-plane-proto;
              }
              leaf peer {
                type enumeration {
                  enum peer {
                    tailf:info "Configure peer address on this interface";
                  }
                }
              }
              container address {
                tailf:info "Configure peer address on this interface";
                list ipv6 {
                  tailf:info "Configure peer IPv6 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix";
                  leaf prefix {
                    type union {
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Enter IPv6 address";
                      }
                      type ipv6-prefix {
                        tailf:info "X:X::X/length;;Enter IPv6 address "+
                          "with prefix";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";
    tailf:cli-explicit-exit;

    // no ip domain-lookup
    container domain-lookup {
      tailf:info "Enable IP Domain Name System hostname translation";
      leaf do-lookup {
        tailf:cli-drop-node-name;
        type boolean;
        tailf:cli-boolean-no;
        default true;
      }
      leaf nsap {
        tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
        type empty;
      }
    }

    // ip domain-name
    leaf domain-name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";
      leaf nd {
        tailf:info "Sun's Network Disk protocol";
        type empty;
      }
      leaf sdns {
        tailf:info "Network Security Protocol";
        type empty;
      }
      leaf spanning-tree {
        tailf:info "Use transparent bridging to flood UDP broadcasts";
        type empty;
      }
      leaf turbo-flood {
        tailf:info "Fast flooding of UDP broadcasts";
        type empty;
      }
      leaf udp {
        tailf:info "Packets to a specific UDP port";
        type empty;
      }


    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      leaf secure-server {
        tailf:info "Enable https server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      container ssm {
        tailf:info "Configure Source Specific Multicast";
        choice ssm-choice {
          leaf default {
            tailf:info "Use 232/8 group range for SSM";
            type empty;
          }
          leaf range {
            tailf:info "ACL for group range to be used for SSM";
            type union {
              type uint8 {
                tailf:info "<1-99>;;Access list number";
                range "1..99";
              }
              type string {
                tailf:info "WORD;;IP named access list";
              }
            }
          }
        }
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";
      container vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding"
          +" instance";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf dest {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination prefix";
          }
        }
        leaf dest-mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination prefix mask";
          }
        }
        choice vrf-choice {
          leaf forwarding-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Forwarding router's address";
            }
          }
          leaf GigabitEthernet {
            tailf:info "GigabitEthernet IEEE 802.3z";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type string {
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:interface/GigabitEthernet/id";
            }
          }
        }
      }
    }

    // ip multicast-routing
    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      presence true;
      tailf:cli-display-separated;
      leaf-list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        container route-limit {
          tailf:info "Maximum number of multicast routes";
          tailf:cli-sequence-commands  {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf nr-routes {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;number of routes";
              range "1..2147483647";
            }
          }
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Threshold at which to"
                +" generate warning message";
              range "1..2147483647";
            }
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";
      leaf logging {
        tailf:info "Configure logging for SSH";
        type enumeration {
          enum events {
            tailf:info "Log SSH events";
          }
        }
      }
      leaf version {
        tailf:info "Specify protocol version to be supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }
    }

  }


  /// ========================================================================
  /// ipv4
  /// ========================================================================

  container ipv4 {
    tailf:info "Global IPv4 configuration commands";
    tailf:cli-explicit-exit;

    // ipv4 access-list
    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      // ipv4 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv4-acl";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;User selected string identifying this "+
              "access list";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-2147483644>;;Sequence number for this entry";
            }
          }

          // FIXME: create better data model for this, probably a choice along
          // the lines of
          // choice rule-choice {
          //   container permit {
          //   }
          //   container deny {
          //   }
          //   container remark {
          //   }
          // }

          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forward\n"+
                "remark;;Comment for access list";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }

    // ipv4 unnumbered
    container unnumbered {
      tailf:info "Enable IPv4 processing without an explicit address";
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";
        container traffic-eng {
          tailf:info "IPv4 commands for MPLS Traffic Engineering";
          tailf:cli-diff-dependency "/cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
    }

    // ipv4 virtual
    container virtual {
      tailf:info "IPv4 virtual address for management interfaces options";
      container address-src {
        tailf:cli-drop-node-name;
        container address {
          leaf use-as-src-addr {
            tailf:info "Use as default src address on sourced packets?";
            type empty;
          }
        }
      }
      container address {
        tailf:info "IPv4 virtual address for management interfaces";
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "IP subnet mask  IPv4 address/prefix or "+
                "IPv4 address and Mask";
            }
          }
        }
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "Select VRF for which the virtual ip address is "+
                "configured";
            }
          }
          list address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address mask";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              type inet:ipv4-address {
                tailf:info "IP subnet mask  IPv4 address/prefix or "+
                  "IPv4 address and Mask";
              }
            }
          }
        }
      }
    }

    // ipv4 conflict-policy
    leaf conflict-policy {
      tailf:info "ipv4 address conflict algorithm selection";
      tailf:cli-full-command;
      type enumeration {
        enum highest-ip {
          tailf:info "Keeps the highest ip address in the conflict set UP";
        }
        enum longest-prefix {
          tailf:info "Keeps the longest prefix match in the conflict set UP";
        }
        enum static {
          tailf:info "Keeps the existing interface UP across new address "+
            "configs";
        }
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";
    tailf:cli-explicit-exit;

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 access-list
    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      // ipv6 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;User selected string identifying this "+
              "access list";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          //FIXME: bug: id is not required on ios-xr.
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-2147483644>;;Sequence number for this entry";
            }
          }

          // FIXME: create better data model for this, probably a choice along
          // the lines of
          // choice rule-choice {
          //   container permit {
          //   }
          //   container deny {
          //   }
          //   container remark {
          //   }
          // }

          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forward\n"+
                "remark;;Comment for access list";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }

    // ipv6 multicast
    container multicast {
      tailf:info "Configure multicast related commands";
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff"
                +" delay in milliseconds";
              range "200..65535";
            }
          }
          leaf max-backoff-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff"
                +" delay in milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }
      }
    }

  }


  /// ========================================================================
  /// frequency
  /// ========================================================================

  container frequency {
    tailf:info "Frequency Synchronization configuration";
    tailf:cli-explicit-exit;

    container synchronization {
      tailf:info "Frequency Synchronization configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-freqsync";

      // frequency synchronization / quality
      container quality {
        tailf:info "Quality level option selection";
        container itu-t {
          tailf:info "ITU-T QL options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf option {
            tailf:info "ITU-T QL options";
            type enumeration {
              enum "1" {
                tailf:info "ITU-T QL option 1";
              }
              enum "2" {
                tailf:info "ITU-T QL option 2";
              }
            }
          }
          leaf generation {
            tailf:info "ITU-T QL option 2 generation";
            when "../option = '2'";
            type enumeration {
              enum "1" {
                tailf:info "ITU-T QL option 2, generation 1";
              }
              enum "2" {
                tailf:info "ITU-T QL option 2, generation 2";
              }
            }
          }
        }
      }

      // frequency synchronization /  clock-interface
      container clock-interface {
        tailf:info "Clock interface configuration";
        leaf timing-mode {
          tailf:info "Clock interface timing mode";
          type enumeration {
            enum independent {
              tailf:info "Use the line interfaces for clock-interface output,"+
                " which is not looped back to the clock-interface input";
            }
            enum system {
              tailf:info "Use the system's selected timing source for "+
                "clock-interface output";
            }
          }
        }
      }

      // frequency synchronization / system
      container system {
        tailf:info "System timing configuration";
        leaf timing-mode {
          tailf:info "System timing mod";
          type enumeration {
            enum clock-only {
              tailf:info "Use only clock-interfaces for system timing";
            }
            enum line-only {
              tailf:info "Use only line-interfaces for system timing";
            }
          }
        }
      }

      // frequency synchronization / log selection
      container log {
        tailf:info "Logging options";
        leaf selection {
          tailf:info "Selection logging options";
          type enumeration {
            enum changes {
              tailf:info "Log selection changes";
            }
            enum errors {
              tailf:info "Log selection errors";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// error-disable
  /// ========================================================================

  container error-disable {
    tailf:info "Configure error-disable";
    container recovery {
      tailf:info "Configure auto-recovery";
      container cause {
        tailf:info "Configure auto-recovery for a specific cause";
        // error-disable recovery cause udld-timeout
        container udld-timeout {
          tailf:info "Used when all UDLD neigbors on the link have timed out";
          tailf:cli-delete-when-empty;
          presence true;
          leaf interval {
            tailf:info "Configure an interval for the auto-recovery period";
            type uint32 {
              tailf:info "<30-1000000>;;Specify an interval for the "+
                "auto-recovery period in seconds";
              range "30..1000000";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";
    tailf:cli-explicit-exit;

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      type enumeration {
        enum client {
          tailf:info "Set the device to client mode.";
        }
        enum off {
          tailf:info "Set the device to off mode.";
        }
        enum server {
          tailf:info "Set the device to server mode.";
        }
        enum transparent {
          tailf:info "Set the device to transparent mode.";
        }
      }
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "Global ARP configuration for Static and Alias ARP entries";
    tailf:cli-explicit-exit;

    // arp *
    uses arp-grouping;

    // arp vrf *
    list vrf {
      tailf:info "vrf;;Specify a non-default VRF";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VRF name";
        }
      }
      uses arp-grouping;
    }
  }


  /// ========================================================================
  /// cinetd
  /// ========================================================================

  container cinetd {
    tailf:info "Global Cisco inetd configuration commands";
    tailf:cli-explicit-exit;

    leaf rate-limit {
      tailf:info "Cisco inetd rate-limit of service requests";
      type uint8 {
        tailf:info "<1-100>;;Number of service requests accepted per "+
          "second (default 1)";
        range "1..100";
      }
    }
  }


  /// ========================================================================
  /// xml
  /// ========================================================================

  container xxml {
    tailf:info "Configuration for XML related services";
    tailf:alt-name xml;
    tailf:cli-explicit-exit;

    container tty-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:info "Enable default agent for XML requests";
        tailf:cli-incomplete-no;
        container tty {
          tailf:info "Enable tty agent for XML requests";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-xml-tty";
          container iteration {
            tailf:info "Iterator of the xml response";
            leaf off {
              tailf:info "Turn off the xml response iterator";
              type empty;
            }
          }
          leaf ipv4 {
            tailf:info "IPv4 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }
          leaf ipv6 {
            tailf:info "IPv6 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }
        }
      }
    }

    container other-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:cli-add-mode;
        leaf ipv4 {
          type enumeration {
            enum enable;
            enum disable;
          }
        }
        leaf ipv6 {
          type enumeration {
            enum enable;
            enum disable;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// switch
  /// ========================================================================

  container "switch" {
    tailf:info "Configure switch command";
    tailf:cli-explicit-exit;

    container virtual {
      tailf:info "Virtual switch configuration mode";
      list domain {
        tailf:info "Virtual switch domain";
        key id;

        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Virtual switch domain number";
            range "1..255";
          }
        }
        leaf mac-address {
          tailf:info "router mac address scheme";
          type union {
            type string {
              tailf:info "H.H.H;;Manually set router mac address";
            }
            type enumeration {
              enum use-virtual {
                tailf:info "Use mac-address range reserved for"
                  +" Virtual Switch System ";
              }
            }
          }
        }
        container switch {
          tailf:info "Configure switch command";
          leaf mode {
            type enumeration {
              enum virtual;
            }
          }
          list nr {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-2>;;Virtual switch number";
                range "1..2";
              }
            }
            leaf location {
              tailf:info "Virtual switch location";
              type string {
                tailf:info "WORD;;Virtual switch location string. If you "
                  +"include spaces, you must enclose your entry in "
                  +"quotes (\"\").";
              }
            }
            leaf priority {
              tailf:info "Virtual switch priority";
              type uint8 {
                tailf:info "<1-255>;;Virtual switch priority value";
                range "1..255";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// key
  /// ========================================================================

  container "key" {
    tailf:info "Key management";
    tailf:cli-explicit-exit;

    // key chain *
    list chain {
      tailf:info "Key-chain management";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Key-chain name";
        }
      }

      // key chain * / key *
      list "key" {
        tailf:info "Configure a key";
        tailf:cli-full-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-2147483647>;;Key identifier";
            range "0..2147483647";
          }
        }

        // key chain * / key * / accept-lifetime
        container accept-lifetime {
          tailf:info "Set accept lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf local {
            tailf:info "Specify time in local timezone";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "hh:mm:ss;;Time to start";
              pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            type month-type;
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-31>;;Day of the month to start";
              range "1..31";
            }
          }
          leaf start-year {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1993-2035>;;Year to start";
              range "1993..2035";
            }
          }

          choice stop-choice {
            case duration {
              leaf duration {
                tailf:info "Set key lifetime duration";
                type uint32 {
                  tailf:info "<1-2147483646>;;Seconds";
                  range "1..2147483646";
                }
              }
            }
            case stop-time {
              leaf stop-time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm:ss;;Time to stop";
                  pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
                }
              }
              leaf stop-month {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum Jan;
                  enum Feb;
                  enum Mar;
                  enum Apr;
                  enum May;
                  enum Jun;
                  enum Jul;
                  enum Aug;
                  enum Sep;
                  enum Oct;
                  enum Nov;
                  enum Dec;
                }
              }
              leaf stop-day {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-31>;;Day of the month to stop";
                  range "1..31";
                }
              }
              leaf stop-year {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1993-2035>;;Year to stop";
                  range "1993..2035";
                }
              }
            }
            case infinite {
              leaf infinite {
                tailf:info "Never expires";
                type empty;
              }
            }
          }
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "Configure a key value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf password {
            tailf:info "Encrypted key string ";
            type string {
              tailf:info "WORD;;The HIDDEN user password string "
                +"(Maximum 162 characters)";
            }
          }
        }

        // key chain * / key * / send-lifetime
        container send-lifetime {
          tailf:info "Set send lifetime of key";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf local {
            tailf:info "Specify time in local timezone";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "hh:mm:ss;;Time to start";
              pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            type month-type;
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-31>;;Day of the month to start";
              range "1..31";
            }
          }
          leaf start-year {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1993-2035>;;Year to start";
              range "1993..2035";
            }
          }

          choice stop-choice {
            case duration {
              leaf duration {
                tailf:info "Set key lifetime duration";
                type uint32 {
                  tailf:info "<1-2147483646>;;Seconds";
                  range "1..2147483646";
                }
              }
            }
            case stop-time {
              leaf stop-time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm:ss;;Time to stop";
                  pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
                }
              }
              leaf stop-month {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum Jan;
                  enum Feb;
                  enum Mar;
                  enum Apr;
                  enum May;
                  enum Jun;
                  enum Jul;
                  enum Aug;
                  enum Sep;
                  enum Oct;
                  enum Nov;
                  enum Dec;
                }
              }
              leaf stop-day {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-31>;;Day of the month to stop";
                  range "1..31";
                }
              }
              leaf stop-year {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1993-2035>;;Year to stop";
                  range "1993..2035";
                }
              }
            }
            case infinite {
              leaf infinite {
                tailf:info "Never expires";
                type empty;
              }
            }
          }
        }

        // key chain * / key * / cryptographic-algorithm
        leaf cryptographic-algorithm {
          tailf:info "Choose cryptographic algorithm";
          type enumeration {
            enum HMAC-MD5 {
              tailf:info "Configure HMAC-MD5 as cryptographic algorithm";
            }
            enum HMAC-SHA1-12 {
              tailf:info "Configure HMAC-SHA1-12 as cryptographic algorithm";
            }
            enum HMAC-SHA1-20 {
              tailf:info "Configure HMAC-SHA1-20 as cryptographic algorithm";
            }
            enum MD5 {
              tailf:info "Configure MD5 as cryptographic algorithm";
            }
            enum SHA-1 {
              tailf:info "Configure SHA-1-20 as cryptographic algorithm";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dhcp
  /// ========================================================================

  container dhcp {
    tailf:info "Dynamic Host Configuration Protocol";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    // dhcp ipv4
    container ipv4 {
      tailf:info "Configure IPv4 DHCP";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-dhcpv4";

      // dhcp ipv4 / profile *
      list profile {
        tailf:info "Create or enter a profile";
        tailf:cli-mode-name "config-dhcpv4-profile";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf "type" {
          type enumeration {
            enum relay {
              tailf:info "Create or enter relay profile";
            }
            enum proxy {
              tailf:info "Create or enter proxy profile";
            }
            enum server {
              tailf:info "Create or enter server profile";
            }
            enum snoop {
              tailf:info "Create or enter snoop profile";
            }
          }
        }

        // dhcp ipv4 / profile * / helper-address
        list helper-address {
          tailf:info "Specify the server address to relay packets";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Server address";
            }
          }
          leaf vrf {
            tailf:info "Specify server VRF";
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
        }
      }

      // dhcp ipv4 / interface *
      list interface {
        tailf:info "Assign a profile to interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf "type" {
          type enumeration {
            enum proxy {
              tailf:info "Assign a proxy profile to interface";
            }
            enum relay {
              tailf:info "Assign a relay profile to interface";
            }
            enum server {
              tailf:info "Assign a server profile to interface";
            }
          }
        }
        leaf profile {
          tailf:info "Enter profile name";
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }
    }

    // dhcp ipv6
    container ipv6 {
      tailf:info "Configure IPv6 DHCP";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-dhcpv6";

      // dhcp ipv6 / interface *
      list interface {
        tailf:info "Enable IPv6 DHCP on an interface";
        tailf:cli-mode-name "config-dhcpv6-if";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf "type" {
          type enumeration {
            enum proxy {
            }
            enum relay {
              tailf:info "Act as an IPv6 DHCP stateless relay agent";
            }
            enum server {
              tailf:info "Act as an IPv6 DHCP server";
            }
          }
        }

        // dhcp ipv6 / interface * profile
        leaf profile {
          tailf:info "Create or enter a profile";
          type string {
            tailf:info "WORD;;Enter profile Name";
          }
        }

        // dhcp ipv6 / interface * / destination
        leaf destination {
          when "../type = 'relay'" {
            tailf:dependency "../type";
          }
          tailf:info "Configure relay destination";
          type inet:ipv6-address {
            tailf:info "X:X::X%zone;;IPv6 address";
          }
        }
      }

      // dhcp ipv6 / profile *
      list profile {
        tailf:info "Create or enter a profile";
        tailf:cli-mode-name "config-dhcpv6-profile";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf "type" {
          type enumeration {
            enum relay {
              tailf:info "Create or enter relay profile";
            }
            enum proxy {
              tailf:info "Create or enter proxy profile";
            }
            enum server {
              tailf:info "Create or enter server profile";
            }
            enum snoop {
              tailf:info "Create or enter snoop profile";
            }
          }
        }

        // dhcp ipv6 / profile * / helper-address
        list helper-address {
          tailf:info "Configure relay destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type inet:ipv6-address {
              tailf:info "X:X::X%zone;;IPv6 address";
            }
          }
          leaf vrf {
            tailf:cli-prefix-key;
            type string;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// diagnostic
  /// ========================================================================

  container diagnostic {
    tailf:info "Configure diagnostic information";
    tailf:cli-explicit-exit;

    /// diagnostic bootup
    container bootup {
      tailf:info "Configure diagnostic for bootup";
      leaf level {
        tailf:info "Select diagnostic level";
        type enumeration {
          enum complete {
            tailf:info "Complete level";
          }
          enum minimal {
            tailf:info "Minimal level";
          }
        }
      }
    }

    /// diagnostic monitor
    container monitor {
      leaf syslog {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "SNMP configuration subcommands";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl/name";
    tailf:cli-diff-dependency "/cisco-ios-xr:ipv6/access-list/named-acl/name";

    // snmp-server ifmib
    container ifmib {
      tailf:info "IF-MIB configuration commands";
      // snmp-server ifmib ifalias
      container ifalias {
        tailf:info "Modify parameters for ifAlias object";
        leaf long {
          tailf:info "Enable support for ifAlias values longer than "+
            "64 characters";
          type empty;
        }
      }
      // snmp-server ifmib stats
      container stats {
        tailf:info "Modify IF-MIB statistics parameters";
        leaf cache {
          tailf:info "Get cached interface statistics";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // snmp-server ifindex
    leaf ifindex {
      tailf:info "Enable ifindex persistence";
      tailf:cli-full-command;
      type enumeration {
        enum persist {
          tailf:info "Persist interface indices";
        }
      }
    }

    // snmp-server engineID
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";

      // snmp-server engineID local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
        }
      }

      // snmp-server engineID remote *
      list remote {
        tailf:info "engineID of the remote agent";
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip-address;
        leaf ip-address {
          type string {
            tailf:info "A.B.C.D or X:X::X;;IP address of remote "+
              "SNMP notification host";
          }
        }
        leaf engine-id {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
        leaf udp-port {
          tailf:info "The remote notification host's UDP port number";
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }
    }

    // snmp-server host *
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        type string {
          tailf:info "A.B.C.D or X:X::X;;IP address of SNMP notification host";
        }
      }
      leaf informs {
        tailf:info "Send Inform messages to this host";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf traps {
        tailf:info "Send Trap messages to this host";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 1 {
            tailf:info "WORD  Use 1 for SNMPv1";
          }
          enum 2c {
            tailf:info "WORD;;Use 2c for SNMPv2c";
          }
          enum 3 {
            tailf:info "WORD;;Use 3 for SNMPv3";
          }
        }
      }
      leaf security-level {
        when "../version = 3" {
          tailf:dependency "../version";
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum auth {
            tailf:info "Using authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Using noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Using authPriv Security Level";
          }
        }
      }
      leaf enc {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum clear {
            tailf:info "Save the community string in encrypted form";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED community string";
          }
        }
      }
      leaf community-string {
        tailf:cli-drop-node-name;
        mandatory true;
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      leaf udp-port {
        tailf:info "udp port to which notifications should be sent";
        tailf:cli-optional-in-sequence;
        type uint16;
      }
    }

    // snmp-server ipv4
    container ipv4 {
      tailf:info "Mark the dscp/precedence bit for ipv4 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      // snmp-server community * / view
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }
      // snmp-server community * / RO
      // snmp-server community * / RW
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      // snmp-server community * / SDROwner
      // snmp-server community * / SystemOwner
      choice owner-choice {
        leaf SDROwner {
          tailf:info "SDR Owner permissions for MIB Objects";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf SystemOwner {
          tailf:info "System Owner permissions for MIB objects";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      // snmp-server community * / <access-list>
      leaf access-list {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Access-list";
        }
      }
    }

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-5000>;;Queue length (default 100)";
        range "1..5000";
      }
    }

    // snmp-server contact
    leaf "contact" {
      tailf:info "Text for mib Object sysContact";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;identification of the contact person for this "+
          "managed node";
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib Object sysLocation";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";
      tailf:cli-diff-dependency "/cisco-ios-xr:interface";
      uses interface-name-grouping;
    }

    // snmp-server overload-control
    container overload-control {
      tailf:info "Set overload-control params for handling incoming "+
        "messages in critical processing mode";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf drop-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-300>;;Overload drop time (in seconds) for incoming "+
            "queue (default 1 sec)";
          range "0..300";
        }
      }
      leaf throttle-rate {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-1000>;;Overload throttle rate for incoming "+
            "queue (default 500 msec)";
          range "0..1000";
        }
      }
    }

    // snmp-server mroutemib
    container mroutemib {
      tailf:info "Configurations related to IPMROUTE-MIB";
      leaf send-all-vrf {
        tailf:info "enable sending all vrf interface info for "+
          "cIpMRouteInterfaceTable";
        type empty;
      }
    }

    // snmp-server mibs cbqosmib cache
    container mibs {
      tailf:info "MIB for configurations";
      container cbqosmib {
        tailf:info "Configure CBQoSMIB parameters";
        container cache {
          tailf:info "Enable CBQoSMIB stats data caching";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-cbqosmibcache";
          container refresh {
            tailf:info "Cache refresh interval";
            leaf time {
              tailf:info "Cache refresh time in seconds ";
              type uint16 {
                tailf:info "<5-60>;;Refresh time in secs";
                range "5..60";
              }
            }
          }
          container service-policy {
            tailf:info "Maximum number of service policies to cache the "+
              "statistics for";
            leaf count {
              tailf:info "Number of service-policy stats";
              type uint16 {
                tailf:info "<1-5000>;;Number of service-policys";
                range "1..5000";
              }
            }
          }
        }
      }
    }

    // snmp-server trap
    container trap {
      tailf:info "MIB trap configurations";
      leaf link {
        tailf:info "Link up/down trap configuration";
        tailf:cli-full-command;
        type enumeration {
          enum ietf {
            tailf:info "Set the varbind of linkupdown trap to the RFC "+
              "specified varbinds (default cisco)";
          }
        }
      }
    }

    // snmp-server user *
    list user {
      tailf:info "Define a user who can access the SNMP engine";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key username;
      leaf username {
        type string {
          tailf:info "WORD;;Name of the user";
        }
      }

      leaf groupname {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Group to which the user belongs";
        }
      }
      leaf version {
        tailf:cli-drop-node-name;
        type enumeration {
          enum v1 {
            tailf:info "user using the v1 security model";
          }
          enum v2c {
            tailf:info "user using the v2c security model";
          }
          enum v3 {
            tailf:info "user using the v3 security model";
          }
        }
      }
      container auth {
        when "../version = 'v3'";
        tailf:info "authentication parameters for the user";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        // auth { md5 | sha } { clear | encrypted } auth-password
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum md5 {
              tailf:info "Use HMAC MD5 algorithm for authentication";
            }
            enum sha {
              tailf:info "Use HMAC SHA algorithm for authentication";
            }
          }
        }
        choice password-choice {
          leaf auth-password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                "authentication password";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                "authentication password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED authentication password";
            }
          }
        }
        // [ priv { 3des | aes aes-bit-encryption | des56 }
        // { clear | encrypted } priv-password ]
        container priv {
          tailf:info "encryption parameters for the user";
          tailf:cli-optional-in-sequence;
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice priv-level {
            leaf "threedes" {
              tailf:alt-name "3des";
              tailf:info "Use 168 bit 3DES algorithm for encryption";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf aes {
              tailf:info "AES - Advanced Encryption Standard.";
              tailf:cli-incomplete-command;
              type enumeration {
                enum "128" {
                  tailf:info "Use AES 128 bit encryption";
                }
                enum "192" {
                  tailf:info "Use AES 192 bit encryption";
                }
                enum "256" {
                  tailf:info "Use AES 256 bit encryption";
                }
              }
            }
            leaf des56 {
              tailf:info "Use 56 bit DES algorithm for encryption";
              tailf:cli-incomplete-command;
              type empty;
            }
          }
          choice password-choice {
            leaf priv-password {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                  "privacy password";
              }
            }
            leaf clear {
              tailf:info "Specifies an UNENCRYPTED password will follow";
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                  "privacy password";
              }
            }
            leaf encrypted {
              tailf:info "Specifies an ENCRYPTED password will follow";
              type string {
                tailf:info "LINE;;The ENCRYPTED privacy password";
              }
            }
          }
        }
      }

      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;Access-list name";
        }
      }

      choice owner-choice {
        leaf SDROwner {
          tailf:info "SDR Owner permissions for MIB Objects";
          type empty;
        }
        leaf SystemOwner {
          tailf:info "System Owner permissions for MIB objects";
          type empty;
        }
      }
    }

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key view-name;
      leaf view-name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      list oid-list {
        tailf:cli-suppress-mode;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key oid-tree;
        leaf oid-tree {
          type string {
            tailf:info "WORD;;MIB view family name";
          }
        }
        leaf viewmode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum excluded {
              tailf:info "MIB family is excluded from the view";
            }
            enum included {
              tailf:info "MIB family is included in the view";
            }
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      choice version-choice {
        leaf v1 {
          tailf:info "group using the v1 security model";
          type empty;
        }
        leaf v2c {
          tailf:info "group using the v2c security model";
          type empty;
        }
        leaf v3 {
          tailf:info "group using the User Security Model (SNMPv3)";
          type enumeration {
            enum auth {
              tailf:info "group using the authNoPriv Security Level";
            }
            enum noauth {
              tailf:info "group using the noAuthNoPriv Security Level";
            }
            enum priv {
              tailf:info "group using authPriv Security Level";
            }
          }
        }
      }

      leaf read {
        tailf:cli-break-sequence-commands;
        type string {
          length "1..64";
        }
      }

      leaf write {
        type string {
          length "1..64";
        }
      }

      leaf notify {
        type string {
          length "1..64";
        }
      }

      leaf context {
        type string;
      }

      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "v1|v2c|v3|read|write|notify|context";
        type string {
          length "1..64";
        }
      }
    }

    // snmp-server interface *
    container interface {
      tailf:info "Enter the SNMP interface configuration commands";
      list subset {
        tailf:info "Add configuration for an interface subset";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;The interface subset number";
          }
        }
        leaf regular-expression {
          tailf:info "Interfaces matching regular expression";
          type string {
            tailf:info "WORD;;Regular expression to match ifName";
          }
        }
        leaf "notification" {
          tailf:info "Allow an SNMP notification type";
          type enumeration {
            enum linkupdown {
              tailf:info "SNMP linkUp and linkDown notifications";
            }
          }
        }
      }
    }

    // snmp-server chassis-id
    leaf chassis-id {
      tailf:info "String to uniquely identify this chassis";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Unique ID string";
      }
    }

    // snmp-server traps
    container traps {
      tailf:info "Enable SNMP traps";
      // snmp-server traps bfd
      leaf bfd {
        tailf:info "Enable BFD traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps bgp
      container bgp {
        tailf:info "Enable BGP4-MIB and CISCO-BGP4-MIB traps";
        tailf:cli-delete-when-empty;
        presence true;
        leaf cbgp2 {
          tailf:info "Enable CISCO-BGP4-MIB v2 traps";
          type empty;
        }
      }
      // snmp-server traps bridgemib
      leaf bridgemib {
        tailf:info "Enable SNMP Trap for Bridge MIB";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps config
      leaf "config" {
        tailf:info "Enable SNMP config traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps copy-complete
      leaf copy-complete {
        tailf:info "Enable CISCO-CONFIG-COPY-MIB ccCopyCompletion traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps ds3
      leaf ds3 {
        tailf:info "Enable SNMP Cisco DS3 traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps entity
      leaf entity {
        tailf:info "Enable SNMP entity traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps entity-state
      container entity-state {
        tailf:info "Enable SNMP entity-state traps";
        leaf operstatus {
          tailf:info "Enable entity oper status enable notification";
          tailf:cli-full-command;
          type empty;
        }
        leaf switchover {
          tailf:info "Enable entity state switchover notifications";
          tailf:cli-full-command;
          type empty;
        }
      }
      // snmp-server traps entity-redundancy
      container entity-redundancy {
        tailf:info "Enable SNMP CISCO-ENTITY-REDUNDANCY-MIB traps";
        leaf all {
          tailf:info "Enable all CISCO-ENTITY-REDUNDANCY-MIB traps";
          type empty;
        }
      }
      // snmp-server traps ethernet
      container ethernet {
        tailf:info "Enable SNMP Ethernet traps";
        leaf cfm {
          tailf:info "Enable traps for 802.1ag Connectivity Fault Management";
          tailf:cli-full-command;
          type empty;
        }
        leaf oam {
          tailf:info "Enable link-oam traps";
          tailf:cli-full-command;
          type enumeration {
            enum events {
              tailf:info "Enable all OAM event traps";
            }
          }
        }
      }
      // snmp-server traps flash
      container flash {
        tailf:info "Enable  flash-mib traps";
        leaf insertion {
          tailf:info "Enable ciscoFlashDeviceInsertedNotif";
          tailf:cli-full-command;
          type empty;
        }
        leaf removal {
          tailf:info "Enable ciscoFlashDeviceRemovedNotif";
          tailf:cli-full-command;
          type empty;
        }
      }
      // snmp-server traps fru-ctrl
      leaf fru-ctrl {
        tailf:info "Enable SNMP entity FRU control traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps hsrp
      leaf hsrp {
        tailf:info "Enable SNMP hsrp traps";
        type empty;
      }
      // snmp-server traps ipsec
      container ipsec {
        tailf:info "Enable SNMP IPSec traps";
        container tunnel {
          tailf:info "Enable SNMP IPsec Tunnel traps";
          leaf stop {
            tailf:info "Enable SNMP IPsec Tunnel Stop trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf start {
            tailf:info "Enable SNMP IPsec Tunnel Start trap";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      // snmp-server traps isakmp
      container isakmp {
        tailf:info "Enable SNMP ISAKMP traps";
        container tunnel {
          tailf:info "Enable SNMP ISAKMP Tunnel traps";
          leaf stop {
            tailf:info "Enable SNMP ISAKMP Tunnel Stop trap";
            tailf:cli-full-command;
            type empty;
          }
          leaf start {
            tailf:info "Enable SNMP ISAKMP Tunnel Start trap";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      // snmp-server traps l2vpn
      container l2vpn {
        tailf:info "Enable L2VPN traps";
        leaf all {
          tailf:info "Enable all L2VPN traps";
          type empty;
        }
        leaf cisco {
          tailf:info "Cisco format including extra varbinds (default IETF)";
          type empty;
        }
        leaf vc-down {
          tailf:info "Enable VC down traps";
          type empty;
        }
        leaf vc-up {
          tailf:info "Enable VC up traps";
          type empty;
        }
      }
      // snmp-server traps mpls
      container mpls {
        tailf:info "Enable SNMP MPLS traps";
        container frr {
          tailf:info "Enable MPLS FRR traps";
          leaf all {
            tailf:info "Enable all MPLS FRR MIB traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf protected {
            tailf:info "Enable MPLS FRR tunnel protected traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf unprotected {
            tailf:info "Enable MPLS FRR tunnel unprotected traps";
            tailf:cli-full-command;
            type empty;
          }
        }
        // snmp-server traps mpls ldp
        container ldp {
          tailf:info "Enable MPLS LDP traps";
          leaf down {
            tailf:info "Enable MPLS LDP session down traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf threshold {
            tailf:info "Enable MPLS LDP threshold traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf up {
            tailf:info "Enable MPLS LDP session up traps";
            tailf:cli-full-command;
            type empty;
          }
        }
        // snmp-server traps mpls l3vpn
        container l3vpn {
          tailf:info "Enable MPLS L3VPN traps";
          leaf all {
            tailf:info "Enable all MPLS L3VPN traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf vrf-up {
            tailf:info "Enable VRF up traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf vrf-down {
            tailf:info "Enable VRF down traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf  max-threshold-cleared {
            tailf:info "Enable max-threshold cleared traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf max-threshold-exceeded {
            tailf:info "Enable max-threshold exceeded traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf mid-threshold-exceeded {
            tailf:info "Enable mid-threshold exceeded traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf max-threshold-reissue-notif-time {
            tailf:info "Time interval (secs) for re-issuing max-threshold "+
              "notification";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-2147483647>;;Time interval in seconds";
              range "0..2147483647";
            }
          }
        }
        // snmp-server traps mpls traffic-eng
        container traffic-eng {
          tailf:info "Enable MPLS TE traps";
          leaf up {
            tailf:info "Enable MPLS TE tunnel up traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf down {
            tailf:info "Enable MPLS TE tunnel down traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf cisco {
            tailf:info "MPLS TE tunnel traps in Cisco format (default ietf)";
            type empty;
          }
          container p2mp {
            tailf:info "Enable MPLS TE P2MP traps";
            leaf down {
              tailf:info "Enable MPLS TE P2MP tunnel destination down traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf up {
              tailf:info "Enable MPLS TE P2MP tunnel destination up traps";
              tailf:cli-full-command;
              type empty;
            }
          }
          leaf reroute {
            tailf:info "Enable MPLS TE tunnel reroute traps";
            tailf:cli-full-command;
            type empty;
          }
          leaf reoptimize {
            tailf:info "Enable MPLS TE tunnel reoptimize traps";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      // snmp-server traps msdp
      container msdp {
        tailf:info "Enable SNMP MSDP traps";
        leaf peer-state-change {
          tailf:info "Enable Peer state change trap";
          tailf:cli-full-command;
          type empty;
        }
      }
      // snmp-server traps ntp
      leaf ntp {
        tailf:info "Enable SNMP Cisco Ntp traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps ospf
      container ospf {
        tailf:info "Enable SNMP ospf traps";
        // snmp-server traps ospf lsa
        container lsa {
          leaf lsa-maxage {
            type empty;
          }
          leaf lsa-originate {
            type empty;
          }
        }
        // snmp-server traps ospf errors
        container errors {
          leaf bad-packet {
            type empty;
          }
          leaf authentication-failure {
            type empty;
          }
          leaf config-error {
            type empty;
          }
          leaf virt-bad-packet {
            type empty;
          }
          leaf virt-authentication-failure {
            type empty;
          }
          leaf virt-config-error {
            type empty;
          }
        }
        // snmp-server traps ospf retransmit
        container retransmit {
          leaf packets {
            type empty;
          }
          leaf virt-packets {
            type empty;
          }
        }
        // snmp-server traps ospf state-change
        container state-change {
          tailf:info "Enable SNMP traps for ospf state change";
          leaf if-state-change {
            type empty;
          }
          leaf neighbor-state-change {
            tailf:info "Enable SNMP traps for ospf neighbor state change";
            tailf:cli-full-command;
            type empty;
          }

          leaf virtif-state-change {
            type empty;
          }
          leaf virtneighbor-state-change {
            type empty;
          }
        }
      }
      // snmp-server traps otn
      leaf otn {
        tailf:info "Enable SNMP Cisco otn traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps isis
      container isis {
        tailf:info "Enable SNMP isis traps";
        choice isis-traps-choice {
          leaf all {
            tailf:info "Enable all IS-IS traps";
            type empty;
          }
          leaf-list traps {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type enumeration {
              enum adjacency-change {
                tailf:info "isisAdjacencyChange";
              }
              enum area-mismatch {
                tailf:info "isisAreaMismatch";
              }
              enum attempt-to-exceed-max-sequence {
                tailf:info "isisAttemptToExceedMaxSequence";
              }
              enum authentication-failure {
                tailf:info "isisAuthenticationFailure";
              }
              enum authentication-type-failure {
                tailf:info "isisAuthenticationTypeFailure";
              }
              enum corrupted-lsp-detected {
                tailf:info "isisCorruptedLSPDetected";
              }
              enum database-overload {
                tailf:info "isisDatabaseOverload";
              }
              enum id-len-mismatch {
                tailf:info "isisIDLenMismatch";
              }
              enum lsp-error-detected {
                tailf:info "isisLSPErrorDetected";
              }
              enum lsp-too-large-to-propagate {
                tailf:info "isisLSPTooLargeToPropagate";
              }
              enum manual-address-drops {
                tailf:info "isisManualAddressDrops";
              }
              enum max-area-addresses-mismatch {
                tailf:info "isisMaxAreaAddressesMismatch";
              }
              enum orig-lsp-buff-size-mismatch {
                tailf:info "isisOrigLSPBuffSizeMismatch";
              }
              enum own-lsp-purge {
                tailf:info "isisOwnLSPPurge";
              }
              enum protocols-supported-mismatch {
                tailf:info "isisProtocolsSupportedMismatch";
              }
              enum rejected-adjacency {
                tailf:info "isisRejectedAdjacency";
              }
              enum sequence-number-skip {
                tailf:info "isisSequenceNumberSkip";
              }
              enum version-skew {
                tailf:info "isisVersionSkew";
              }
            }
          }
        }
      }
      // snmp-server traps pim
      container pim {
        tailf:info "Enable SNMP PIM traps";
        leaf interface-state-change {
          tailf:info "Enable interface state change trap";
          tailf:cli-full-command;
          type empty;
        }
        leaf invalid-message-received {
          tailf:info "Enable invalid message received trap";
          tailf:cli-full-command;
          type empty;
        }
        leaf neighbor-change {
          tailf:info "Enable neighbor change trap";
          tailf:cli-full-command;
          type empty;
        }
        leaf rp-mapping-change {
          tailf:info "Enable rp mapping change trap";
          tailf:cli-full-command;
          type empty;
        }
      }
      // snmp-server traps rf
      leaf rf {
        tailf:info "Enable SNMP RF-MIB traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps rsvp
      container rsvp {
        tailf:info "Enable RSVP MIB traps";
        leaf all {
          tailf:info "Enable all RSVP MIB traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf new-flow {
          tailf:info "Enable RSVP new_flow traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf lost-flow {
          tailf:info "Enable RSVP lost_flow traps";
          tailf:cli-full-command;
          type empty;
        }
      }
      // snmp-server traps sensor
      leaf sensor {
        tailf:info "Enable SNMP entity sensor traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps sonet
      leaf sonet {
        tailf:info "Enable SNMP Cisco Sonet traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps snmp
      container snmp {
        tailf:info "Enable SNMPv2-MIB traps";
        tailf:cli-display-separated;
        presence true;
        leaf coldstart {
          tailf:info "Enable SNMPv2-MIB coldStart trap";
          tailf:cli-full-command;
          type empty;
        }
        leaf linkup {
          tailf:info "Enable SNMPv2-MIB linkUp traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf linkdown {
          tailf:info "Enable SNMPv2-MIB linDownp traps";
          tailf:cli-full-command;
          type empty;
        }
        leaf warmstart {
          tailf:info "Enable SNMPv2-MIB warmStart trap";
          tailf:cli-full-command;
          type empty;
        }
        leaf authentication {
          tailf:info "Enable SNMPv2-MIB authenticationFailure trap";
          tailf:cli-full-command;
          type empty;
        }
      }
      // snmp-server traps syslog
      leaf syslog {
        tailf:info "Enable SNMP syslog traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps system
      leaf system {
        tailf:info "Enable SNMP SYSTEMMIB-MIB traps";
        tailf:cli-full-command;
        type empty;
      }
      // snmp-server traps vpls
      container vpls {
        tailf:info "Enable VPLS traps";
        leaf all {
          tailf:info "Enable all VPLS traps";
          type empty;
        }
        leaf "status" {
          tailf:info "Enable VPLS Status traps";
          type empty;
        }
        leaf full-clear {
          tailf:info "Enable VPLS Full Clear traps";
          type empty;
        }
        leaf full-raise {
          tailf:info "Enable VPLS Full Raise traps";
          type empty;
        }
      }
      // snmp-server traps vrrp
      container vrrp {
        tailf:info "Enable VRRP traps";
        leaf events {
          tailf:info "Enable all VRRP event traps";
          type empty;
        }
      }
      // snmp-server traps *
      list traps-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string;
        }
      }
    }

}


  /// ========================================================================
  /// srlg
  /// ========================================================================

  container srlg {
    tailf:info "SRLG configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    presence true;
  }


  /// ========================================================================
  /// monitor-session
  /// ========================================================================

  list monitor-session {
    tailf:info "Monitor-session configuration commands";
    tailf:cli-mode-name "config-mon";
    tailf:cli-explicit-exit;

    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Session Name";
      }
    }
    container destination {
      tailf:info "Specify the destination that traffic should be "+
        "replicated to";
      choice destination-choice {
        leaf pseudowire {
          tailf:info "Specify a pseudowire";
          type empty;
        }
        container interface {
          tailf:info "Specify a destination interface";
          tailf:cli-diff-dependency "/cisco-ios-xr:interface";
          uses interface-name-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    // spanning-tree extend
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion "
          +"of the bridge id (PVST & Rapid PVST only)";
        type empty;
      }
    }

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Multiple spanning tree configuration";
      list "range" {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "WORD;;MST instance range, example: 0-3,5,7-9";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }
      container configuration {
        tailf:cli-add-mode;
        tailf:info "Enter MST configuration submode";
        leaf name {
          tailf:info "Set configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }
      }
    }

    // spanning-tree portfast
    leaf portfast {
      tailf:info "Spanning tree portfast options";
      type enumeration {
        enum disable {
          tailf:info "Disable portfast for this interface";
        }
        enum edge {
          tailf:info "Enable portfast edge on the interface";
        }
        enum network {
          tailf:info "Enable portfast network on the interface";
        }
      }
    }

    // spanning-tree mstag *
    list mstag {
      tailf:info "Configure MST Access Gateway";
      tailf:cli-mode-name "config-mstag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }
      // spanning-tree mstag * / interface *
      list interface {
        tailf:cli-mode-name "config-mstag-if";
        key ifname;
        leaf ifname {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf name {
          tailf:info "Configuration name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }
        leaf port-id {
          tailf:info "Interface Port ID.";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-4095>;;Interface Port ID.";
            range "1..4095";
          }
        }
        leaf bridge-id {
          tailf:info "Set the Bridge ID this port should use";
          tailf:cli-full-command;
          type string {
            tailf:info "H.H.H;;MAC address";
            pattern "[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+";
          }
        }
        list instance {
          tailf:info "Enable and Configure an instance on this interface.";
          tailf:cli-mode-name "config-mstag-if-inst";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MSTI ID";
              range "0..4094";
            }
          }
          container cost {
            tailf:info "Cost of this port on this MSTI.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cost-value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
            leaf startup-value {
              tailf:info "Set the cost of this port on this MSTI to be used "+
                "during pre-empt delay";
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
          }
          leaf-list vlan-ids {
            tailf:info "Assign ranges of VLANs to the specified MSTI.";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
            }
          }
          container root-id {
            tailf:info "Set the Bridge ID of the root for this instance";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf root-id-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "H.H.H;;MAC address";
                pattern "[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+";
              }
            }
            leaf startup-value {
              tailf:info "Set the Bridge ID to be used during pre-empt delay";
              type string {
                tailf:info "H.H.H;;MAC address";
                pattern "[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+";
              }
            }
          }
          container priority {
            tailf:info "MSTI Priority.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the MSTI Priority to be used during "+
                "pre-empt delay";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
          }
          container root-priority {
            tailf:info "Priority of the root for this instance.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the priority of the root for this instance "+
                "to be used during pre-empt delay";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
          }
        }
      }
    }

    // spanning-tree repag *
    list repag {
      tailf:info "Configure REP Access Gateway";
      tailf:cli-mode-name "config-repag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }
      // spanning-tree repag * / interface *
      list interface {
        tailf:cli-mode-name "config-repag-if";
        key ifname;
        leaf ifname {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Interchassis redundancy configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-redundancy";
    tailf:cli-explicit-exit;

    container iccp {
      tailf:info "configure iccp parameter";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-redundancy-iccp";
      list group {
        tailf:info "group configuration";
        tailf:cli-mode-name "config-redundancy-iccp-group";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;Enter group number";
            range "1..4294967295";
          }
        }
        container mlacp {
          tailf:info "Multi-chassis Link Aggregation Control Protocol "+
            "commands";
          leaf node {
            tailf:info "Set mLACP node ID to use in this ICCP Group";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-7>;;Unique node ID in the ICCP Group for this "+
                "system.";
              range "0..7";
            }
          }
          container system {
            tailf:info "Set the default system parameters for LACP bundles";
            leaf mac {
              tailf:info "The LACP System ID to be used in this ICCP Group.";
              tailf:cli-full-command;
              type string {
                tailf:info "H.H.H;;Unique ID for this system. "+
                  "Any non-zero value is permitted.";
              }
            }
            leaf priority {
              tailf:info "Set the LACP system priority to be used in "+
                "this ICCP Group.";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>  Priority for this system. "+
                  "Lower value is higher priority.";
                range "1..65535";
              }
            }
          }
        }
        container member {
          tailf:info "configure ICCP members";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-redundancy-group-iccp-member";
          leaf neighbor {
            tailf:info "configure interchassis group ICCP members";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;neighbor ip address";
            }
          }
        }
        container isolation {
          tailf:info "Set the isolation parameters";
          leaf recovery-delay {
            tailf:info "Specify delay before clearing isolation "+
              "condition after recovery from failure";
            type uint16 {
              tailf:info "<30-300>;;Recovery delay in seconds.";
              range "30..300";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ssh
  /// ========================================================================

  container ssh {
    tailf:info "Secure Shell configuration";
    tailf:cli-explicit-exit;

    // ssh client
    container client {
      tailf:info "Provide SSH client service";
      container source-interface {
        tailf:info "Source interface for ssh client sessions";
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }
    }

    // ssh server
    container server {
      tailf:info "Provide SSH server service";
      leaf dscp {
        tailf:info "Cisco ssh server DSCP";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;DSCP value range";
          range "0..63";
        }
      }
      leaf logging {
        tailf:info "Enable ssh server logging";
        tailf:cli-full-command;
        type empty;
      }
      container netconf {
        tailf:info "start ssh service for netcon";
        tailf:cli-delete-when-empty;
        presence true;
        leaf port {
          tailf:info "start ssh service on port";
          type uint16 {
            tailf:info "<1-65535>;;port number on which ssh service to be "+
              "started for netconf";
          }
        }
      }
      leaf rate-limit {
        tailf:info "Cisco sshd rate-limit of service requests";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-600>;;Limit in term of number of request per minute"+
            "(default 60)";
          range "1..600";
        }
      }
      leaf session-limit {
        tailf:info "Cisco sshd session-limit of service requests";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-1024>;;Number of allowable concurrent incoming "+
            "ssh sessions";
          range "1..1024";
        }
      }
      leaf v2 {
        tailf:info "Cisco sshd force protocol version 2 only";
        tailf:cli-full-command;
        type empty;
      }
      // ssh server vrf *
      list vrf {
        tailf:info "Cisco sshd VRF name";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter vrf name";
          }
        }
        container ipv6 {
          tailf:info "IPv6 access list for ssh server";
          leaf access-list {
            tailf:info "Configure IPv6 access-list";
            type string {
              tailf:info "WORD;;Name of IPv6 access list - Max 32 characters";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
            }
          }
        }
      }
    }

    // ssh timeout
    leaf timeout {
      tailf:info "Set timeout value for SSH";
      type uint8 {
        tailf:info "<5-120>;;Timeout value between 5-120 seconds";
        range "5..120";
      }
    }
  }


  /// ========================================================================
  /// ipsla
  /// ========================================================================

  container ipsla {
    tailf:info "IPSLA configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:key/chain";

    leaf key-chain {
      tailf:info "Use MD5 authentication for IPSLA control message";
      tailf:cli-full-command;
      type string;
    }
    container responder {
      tailf:info "IPSLA responder configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ipsla-resp";
      presence true;
    }
  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container performance-mgmt {
    tailf:info "Performance Management configuration & operation subcommands";
    tailf:cli-explicit-exit;

    // performance-mgmt thresholds
    container thresholds {
      tailf:info "Configure thresholds for collected data";
      container node {
        tailf:info "Configure thresholds for node";
        container cpu {
          tailf:info "Configure thresholds for cpu";
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-threshold-cpu";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
        container process {
          tailf:info "Configure thresholds for process";
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-threshold-proc";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
      }
    }

    // performance-mgmt apply
    container apply {
      tailf:info "Start data collection and/or threshold monitoring";
      container thresholds {
        tailf:info "Start threshold monitoring using a defined template";
        container node {
          tailf:info "Perform threshold monitoring for node";
          container cpu {
            tailf:info "Perform threshold checking for CPU";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf location {
              tailf:cli-incomplete-command;
              type string;
            }
            leaf template {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Specify an existing template for "+
                  "threshold checking";
              }
            }
          }
          container process {
            tailf:info "Perform threshold checking for process";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf location {
              tailf:cli-incomplete-command;
              type string;
            }
            leaf template {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Specify an existing template for "+
                  "threshold checking";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "Vlan commands";
    tailf:cli-explicit-exit;

    // vlan internal
    container internal {
      tailf:info "internal VLAN";
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          tailf:info "internal VLAN allocation policy";
          type enumeration {
            enum ascending {
              tailf:info "Allocate internal VLAN in ascending order";
            }
            enum descending {
              tailf:info "Allocate internal VLAN in descending order";
            }
          }
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter ";
        type uint16 {
          tailf:info "<0-5000>;;Maximum number of packets logged per second";
          range "0..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan *
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "WORD;;ISL VLAN IDs 1-4094";
          range "1..4094";
        }
      }
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "WORD;;The ascii name for the VLAN";
        }
      }
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:info "Global LLDP configuration subcommands";
    tailf:cli-explicit-exit;
    presence true;

    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint16 {
        tailf:info "<0-65535>;;Length  of time  (in sec) that receiver"
          +" must keep this packet ";
        range "0..65535";
      }
    }
    leaf reinit {
      tailf:info "Delay (in sec) for LLDP initialization on any interface";
      type uint8 {
        tailf:info "<2-5>;;Specify the delay (in secs) for LLDP to initialize";
        range "2..5";
      }
    }
    leaf run {
      tailf:info "Enable LLDP";
      type empty;
    }
    leaf timer {
      tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
      type uint16 {
        tailf:info "<5-65534>;;Rate at which LLDP packets are sent (in sec)";
        range "5..65534";
      }
    }
  }


  /// ========================================================================
  /// switch-fabric
  /// ========================================================================

  container switch-fabric {
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    list service-policy {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the service policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:policy-map/name";
        }
      }
    }
  }


  /// ========================================================================
  /// lpts
  /// ========================================================================

  container lpts {
    tailf:info "lpts configuration commands";
    tailf:cli-explicit-exit;

    container pifib {
      tailf:info "pre-ifib configuration commands";
      container hardware {
        tailf:info "hardware configuration commands";
        // lpts pifib hardware police
        container police {
          tailf:info "ingress policers configuration command";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pifib-policer-global";
          uses lpts-grouping;
          list location {
            tailf:info "Location Specification";
            tailf:cli-mode-name "config-pifib-policer-per-node";
            key node-id;
            leaf node-id {
              type string {
                tailf:info "WORD;;Enter Location";
              }
            }
            uses lpts-grouping;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// hw-module
  /// ========================================================================

  container hw-module {
    tailf:info "Configure h/w module";
    tailf:cli-explicit-exit;

    container qos {
      container pol-gran {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf granularity {
          tailf:cli-drop-node-name;
          type uint8 {
            range "8..64";
          }
        }
        leaf location {
          type string;
        }
      }
      container queue-auto-defrag {
        container disable {
          list location {
            key id;
            leaf id {
              type string {
                // node-id
              }
            }
          }
        }
      }
      container account {
        container layer2 {
          container encapsulation {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice encapsulation-choice {
              leaf arpa {
                type empty;
              }
              leaf dot1q {
                type empty;
              }
              leaf "length" {
                type uint8 {
                  range "1..50";
                }
              }
            }
            leaf location {
              type string {
                // node-idx
              }
            }
          }
        }
      }
      container multicast {
        leaf location {
          type string {
            // node-id
          }
        }
      }
    }
    container pse {
      container allocate {
        container tcam {
          list location {
            key id;
            leaf id {
              type string {
                // node-id
              }
            }
            list region {
              key "name num";
              leaf name {
                type string;
              }
              leaf num {
                type uint32;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-exit-command "end-class-map";
    key name;
    leaf name {
      tailf:cli-disallow-value "end-class-map";
      type string {
        tailf:info "WORD;;class-map name";
      }
    }

    // class-map * / prematch
    leaf prematch {
      tailf:cli-prefix-key;
      tailf:cli-drop-node-name;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under "+
            "this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this "+
            "classmap";
        }
      }
      default match-all;
    }

    // class-map * / description
    leaf "description" {
      tailf:info "Class-Map description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 "+
          "characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate match criteria";
        uses class-map-match-grouping;
      }
    }

    // Note: rename is action and not needed
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure a policymap";
    tailf:cli-mode-name "config-pmap";
    tailf:cli-exit-command "end-policy-map" {
      tailf:info "End policy map configuration";
    }
    tailf:cli-diff-dependency "/cisco-ios-xr:class-map";
    key name;
    leaf name {
      tailf:cli-disallow-value "end-policy-map";
      type string {
        tailf:info "WORD;;Name of the policymap";
      }
    }

    // policy-map * / class
    container class {
      tailf:info "Class map";
      // policy-map * / class *
      list class-ref {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-pmap-c";
        tailf:cli-full-command;
        key map;
        leaf map {
          tailf:cli-disallow-value "class-default";
          type string {
            tailf:info "WORD;;Name of class";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:class-map/name";
          }
        }
        uses policy-map-class-grouping;
      }
      // policy-map * / class class-default
      list class-default {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-pmap-c";
        tailf:cli-full-command;
        key map;
        leaf map {
          type enumeration {
            enum class-default {
              tailf:info "The default class";
            }
          }
        }
        uses policy-map-class-grouping;
      }
    }

    // policy-map * / description
    leaf "description" {
      tailf:info "Set description for this policy-map";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description for this policy-map";
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Global Crypto configuration command";
  }


  /// ========================================================================
  /// flow
  /// ========================================================================

  container flow {
    tailf:info "Configure a flexible flow object";
    tailf:cli-explicit-exit;

    // flow exporter-map *
    list exporter-map {
      tailf:info "Configure a flow exporter map";
      tailf:cli-mode-name "config-fem";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Exporter map name - maximum 32 characters";
        }
      }

      // flow exporter-map * / version v9
      container version {
        tailf:info "Specify export version parameters";
        container v9 {
          tailf:info "Use version 9 export format";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-fem-ver";
          container template {
            tailf:info "Specify template export parameters";
            leaf timeout {
              tailf:info "Specify custom timeout for the template";
              type uint32 {
                tailf:info "<1-604800>;Timeout value in seconds";
              }
            }
          }
        }
      }

      // flow exporter-map * / dscp
      leaf dscp {
        tailf:info "Specify DSCP value for export packets";
        type uint8 {
          tailf:info "<0-63>;;Differentiated services codepoint value";
        }
      }

      // flow exporter-map * / transport udp
      container transport {
        tailf:info "Specify the transport protocol for export packets";
        leaf udp {
          tailf:info "Use UDP as transport protocol";
          type uint16 {
            tailf:info "<1024-65535>;;Destination UDP port value";
            range "1024..65535";
          }
        }
      }

      // flow exporter-map * / source
      container source {
        tailf:info "Source interface";
        tailf:cli-diff-dependency "/cisco-ios-xr:interface";
        uses interface-name-grouping;
      }

      // flow exporter-map * / destination
      container destination {
        tailf:info "Export destination configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "Hostname or A.B.C.D  Destination IP address";
          }
        }
        leaf vrf {
          tailf:info "Configure VRF to be used for reaching export "+
            "destination";
          type vrf-type;
        }
      }
    }

    // flow monitor-map *
    list monitor-map {
      tailf:info "Configure a flow monitor map";
      tailf:cli-mode-name "config-fmm";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Monitor map name - maximum 32 characters";
        }
      }

      // flow monitor-map * / record
      container record {
        tailf:info "Specify a flow record map name";
        // flow monitor-map * / record ipv4
        container ipv4 {
          tailf:info "IPv4 raw record format";
          presence true;
          choice record-ipv4-choice {
            leaf peer-as {
              tailf:info "Record peer AS";
              type empty;
            }
            leaf destination-tos {
              tailf:info "IPv4 Destination Based NetFlow Accounting TOS";
              type empty;
            }
          }
        }
        // flow monitor-map * / record ipv6
        container ipv6 {
          tailf:info "IPv6 raw record format";
          presence true;
          leaf peer-as {
            tailf:info "Record peer AS";
            type empty;
          }
        }
      }

      // flow monitor-map * / exporter
      leaf exporter {
        tailf:info "Specify flow exporter map name";
        type string {
          tailf:info "WORD;;Exporter map name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:flow/exporter-map/name";
        }
      }

      // flow monitor-map * / cache
      container cache {
        tailf:info "Specify flow cache attributes";
        container timeout {
          tailf:info "Specify the flow cache timeouts";
          leaf active {
            tailf:info "Specify the active flow timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// sampler-map
  /// ========================================================================

  list sampler-map {
    tailf:info "Configure a sampler map";
    tailf:cli-mode-name "config-sm";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Sampler map name - maximum 32 characters";
      }
    }

    // sampler-map * / random
    container random {
      tailf:info "Use random mode for sampling packets";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-packets {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;Number of packets to be sampled "+
              "in the sampling interval";
          }
        }
      }
      leaf out-of {
        tailf:info "Sample one packet out of";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf sampling-interval {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-65535>;;Sampling interval in units of packets";
          range "1..65535";
        }
      }
    }
  }


  /// ========================================================================
  /// clock-interface
  /// ========================================================================

  container clock-interface {
    tailf:info "Clock interface configuration commands";
    tailf:cli-explicit-exit;

    // clock-interface sync *
    list sync {
      tailf:info "Synchronization clock interface";
      tailf:cli-mode-name "config-clock-if";
      key "id location";
      leaf id {
        type uint32 {
          tailf:info "<0-4294967295>;;Clock interface port number";
        }
      }

      // clock-interface sync * / shutdown
      leaf shutdown {
        tailf:info "Disable the SyncE Port";
        type empty;
      }

      // clock-interface sync * / location
      leaf location {
        tailf:info "Specify the clock interface location";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }

      // clock-interface sync * / port-parameters
      container port-parameters {
        tailf:info "clock port parameter setting";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-clk-parms";
        container bits-input {
          tailf:info "BITS RX interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum 2m {
                tailf:info "2m mode";
              }
              enum 64k-input-only {
                tailf:info "64k-input-only mode";
              }
              enum e1 {
                tailf:info "e1 mode";
              }
              enum t1 {
                tailf:info "t1 mode";
              }
            }
          }
          leaf mode1 {
            tailf:cli-drop-node-name;
            type enumeration {
              enum d4 {
                tailf:info "d4 mode";
              }
              enum esf {
                tailf:info "esf mode";
              }
              enum crc-4 {
                tailf:info "crc4 mode";
              }
              enum non-crc-4 {
                tailf:info "non-crc-4 mode";
              }
            }
          }
          leaf mode2 {
            tailf:cli-drop-node-name;
            type union {
              type enumeration {
                enum ami {
                  tailf:info "ami mode";
                }
                enum b8zs {
                  tailf:info "b8zs mode";
                }
              }
              type string {
                // placeholder for more
              }
            }
          }
        }
      }

      // clock-interface sync * / frequency
      container frequency {
        tailf:info "Frequency Synchronization configuration";

        // clock-interface / frequency synchronization
        container synchronization {
          tailf:info "Frequency Synchronization configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-clk-freqsync";
          container selection {
            tailf:info "Selection configuration commands";
            leaf "input" {
              tailf:info "Enable this source for selection";
              type empty;
            }
          }
          leaf priority {
            tailf:info "Source priority";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-254>;;Source priority";
              range "1..254";
            }
          }
          leaf wait-to-restore {
            tailf:info "Set the wait-to-restore time";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-12>;;Wait-to-restore time, in minutes";
              range "0..12";
            }
          }
          container quality {
            tailf:info "Quality level configuration";
            container receive {
              tailf:info "Adjust the received quality level";
              container exact {
                tailf:info "Specify the exact QL value to use";
                container itu-t {
                  tailf:info "ITU-T QL options";
                  container option {
                    tailf:info "ITU-T QL options";
                    choice option-choice {
                      leaf one {
                        tailf:alt-name "1";
                        tailf:info "ITU-T QL option 1";
                        tailf:cli-full-command;
                        type enumeration {
                          enum DNU {
                            tailf:info "This signal should not be used for "+
                              "synchronization";
                          }
                          enum PRC {
                            tailf:info "ITU-T Option 1: Primary reference clock";
                          }
                          enum SEC {
                            tailf:info "ITU-T Option 1: SONET equipment clock";
                          }
                          enum SSU-A {
                            tailf:info "ITU-T Option 1: Type I or V slave clock";
                          }
                          enum SSU-B {
                            tailf:info "ITU-T Option 1: Type IV slave clock";
                          }
                        }
                      }
                      container two {
                        tailf:alt-name "2";
                        tailf:info "ITU-T QL option 2";
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands {
                          tailf:cli-reset-siblings;
                        }
                        leaf generation {
                          tailf:info "ITU-T QL option 2 generation";
                          type enumeration {
                            enum "1" {
                              tailf:info "ITU-T QL option 2, generation 1";
                            }
                            enum "2" {
                              tailf:info "ITU-T QL option 2, generation 2";
                            }
                          }
                        }
                        leaf "value" {
                          tailf:cli-drop-node-name;
                          type enumeration {
                            enum DUS {
                              tailf:info "This signal should not be used for synchronization";
                            }
                            enum PRS {
                              tailf:info "ITU-T Option 2, Primary reference source";
                            }
                            enum SMC {
                              tailf:info "ITU-T Option 2, SONET clock self timed";
                            }
                            enum ST2 {
                              tailf:info "ITU-T Option 2, Stratum 2";
                            }
                            enum ST3 {
                              tailf:info "ITU-T Option 2, Stratum 3";
                            }
                            enum ST3E {
                              tailf:info "ITU-T Option 2, Stratum 3E" +
                                " (Generation 2 only)";
                            }
                            enum ST4 {
                              tailf:info "ITU-T Option 2, Stratum 4 freerun";
                            }
                            enum STU {
                              tailf:info "ITU-T Option 2, Synchronized "+
                                "- traceability unknown";
                            }
                            enum TNC {
                              tailf:info "ITU-T Option 2, Transit node clock" +
                                " (Generation 2 only)";
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";
    tailf:cli-explicit-exit;

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
      leaf autodiscovery {
        tailf:info "Multipoint autodiscovery configuration mode";
        tailf:cli-hide-in-submode;
        type empty;
      }
      container vpn {
        tailf:info "VPN configuration";
        leaf id {
          tailf:info "VPN id";
          type uint32 {
            tailf:info "<1-4294967295>;;VPN id value";
            range "1..4294967295";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// auto
  /// ========================================================================

  container auto {
    tailf:info "Configure Automation";
    tailf:cli-explicit-exit;

    // auto qos
    leaf qos {
      tailf:info "Configure AutoQoS";
      type enumeration {
        enum default {
          tailf:info "Configure AutoQoS Default";
        }
      }
    }
  }


  /// =================================1======================================
  /// ethernet-services
  /// ========================================================================

  container ethernet-services {
    tailf:info "Ethernet related services";
    tailf:cli-explicit-exit;

    // ethernet-services access-list *
    list access-list {
      tailf:cli-mode-name "config-es-acl";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
          length "1..32";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number for this entry";
            range "1..2147483646";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "deny;;Specify packets to reject\n"+
              "permit;;Specify packets to forward\n"+
              "remark;;Comment for access list";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Select an interface to configure";
    tailf:cli-explicit-exit;

    uses interface-grouping;

    container preconfigure {
      tailf:info "Specify a preconfig";
      uses interface-grouping;
    }
  }


  /// ========================================================================
  /// controller
  /// ========================================================================

  container controller {
    tailf:info "Controller configuration subcommands";
    tailf:cli-explicit-exit;

    // controller dwdm *
    list dwdm {
      tailf:info "DWDM controller(s)";
      tailf:cli-allow-join-with-key;
      key id;
      leaf id {
        type string {
          tailf:info "dwdm Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }

      // controller dwdm * / proactive
      leaf proactive {
        tailf:info "Enable Proactive Protection Feature";
        type empty;
      }

      // controller dwdm * / wavelength
      container wavelength {
        tailf:info "Configure ITU Channel, Wavelength and Frequency";
        choice wave-length-choice {
          leaf channel-number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-89";
              range "1..100";
            }
          }
          leaf frequency {
            tailf:info "Configure Frequency and Map to ITU Channel";
            type uint16 {
              tailf:info "<19115-19610>;;Enter 5-digit Frequency data; "+
                "e.g. 19580 for 195.8 THz";
              range "19115..19610";
            }
          }
        }
      }

        // controller dwdm * / admin-state
      leaf admin-state {
        tailf:info "Configure the transport admin state of the controller: "+
          "in-service, out-of-service or maintenance";
        type enumeration {
          enum in-service {
            tailf:info "change the admin-state to In-service (IS)";
          }
          enum maintenance {
            tailf:info "change the admin-state to Out-of-service-Maintenance "+
              "(OOS-MT)";
          }
          enum out-of-service {
            tailf:info "change the admin-state to Out-of-service (OOS)";
          }
        }
      }
    }

    // controller MgmtMultilink *
    list MgmtMultilink {
      tailf:info "Controller for the management of multilink interfacess";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-mgmtmultilink";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port "+
            "format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      // controller MgmtMultilink * / bundle *
      list bundle {
        tailf:info "Configure a multilink bundle interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-999999999>;;Bundle Id";
          }
        }
      }
    }

    // controller T1 *
    list T1 {
      tailf:info "T1 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-t1";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port"+
            "format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      // controller T1 * / framing
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum esf {
            tailf:info "esf framing: default";
          }
          enum sf {
            tailf:info "sf framing mode";
          }
        }
      }
      // controller T1 * / channel-group *
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name "config-t1-channel_group";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-23>;;channel group number";
            range "0..23";
          }
        }
        // controller T1 * / channel-group * / speed
        leaf speed {
          tailf:info "speed of the ds0 channel";
          tailf:cli-full-command;
          type enumeration {
            enum "56" {
              tailf:info "56 Kbits";
            }
            enum "64" {
              tailf:info "64 Kbits";
            }
          }
        }
        // controller T1 * / channel-group * / timeslots
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) "+
              "from 1 to 24. (:) indicates individual timeslot and (-) "+
              "represent range";
          }
        }
      }
      // controller T1 * / clock
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }
    }

    // controller T3 *
    list T3 {
      tailf:info "T3 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-t3";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port"+
            "format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      // controller T3 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }
      // controller T3 * / delay
      container delay {
        leaf trigger {
          tailf:info "trigger time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-60000>;;time in msec to soak before declaring "+
              "the alarm";
            range "0..60000";
          }
        }
      }
      // controller T3 * / clock
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }
    }

    // controller sonet *
    list sonet {
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-sonet";
      key id;
      leaf id {
        type string {
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      // controller sonet * / description
      leaf "description" {
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string;
      }
      // controller sonet * / ais-shut
      leaf ais-shut {
        tailf:cli-full-command;
        type empty;
      }
      // controller sonet * / framing
      leaf framing {
        tailf:cli-full-command;
        type enumeration {
          enum sdh {
          }
          enum sonet {
          }
        }
      }
      // controller sonet * / sts *
      list sts {
        tailf:cli-mode-name "config-stsPath";
        key id;
        leaf id {
          type uint32;
        }
        leaf width {
          type uint32;
        }
        leaf mode {
          type string;
        }
        container delay {
          leaf trigger {
            type uint32;
          }
        }
      }
      // controller sonet * / threshold
      container threshold {
        leaf sf-ber {
          tailf:cli-full-command;
          type uint8 {
          }
        }
      }
      // controller sonet * / clock
      container clock {
        leaf source {
          type enumeration {
            enum internal {
            }
            enum line {
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  container l2vpn {
    tailf:info "Configure l2vpn commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-l2vpn";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";
    presence true;

    // l2vpn / pw-status
    container pw-status {
      tailf:info "Configure PW status";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable PW status";
        type empty;
      }
    }

    // l2vpn / logging
    container logging {
      tailf:info "Configure l2vpn logging commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-log";
      tailf:cli-delete-when-empty;
      presence true;

      // l2vpn / logging / pseudowire
      container pseudowire {
        tailf:info "Enable pseudowire logging";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "status" {
          type empty;
        }
      }
    }

    // l2vpn / load-balancing
    container load-balancing {
      tailf:info "Global L2VPN Load Balancing";
      leaf flow {
        tailf:info "Enable Flow based load balancing";
        type enumeration {
          enum src-dst-ip {
            tailf:info "Use source and destination IP addresses for hashing";
          }
          enum src-dst-mac {
            tailf:info "Use source and destination MAC addresses for hashing";
          }
        }
      }
    }

    // l2vpn / pw-class *
    list pw-class {
      tailf:info "Pseudowire class template";
      tailf:cli-mode-name "config-l2vpn-pwc";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }
      container encapsulation {
        tailf:info "Pseudowire encapsulation";
        // l2vpn / pw-class * / encapsulation l2tpv3
        container l2tpv3 {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-l2vpn-pwc-l2tpv3";
          // l2vpn / pw-class * / encapsulation l2tpv3 / protocol l2tpv3
          leaf protocol {
            tailf:info "Set the dynamic pseudowire signaling protocol";
            type enumeration {
              enum l2tpv3 {
                tailf:info "Set L2TPv3 as the signaling protocol for "
                  +"this pseudowire class";
              }
            }
          }
          // l2vpn / pw-class * / encapsulation l2tpv3 / ttl
          leaf ttl {
            tailf:info "Set the Time To Live (TTL)";
            type uint8 {
              tailf:info "<1-255>;;TTL value";
              range "1..255";
            }
          }
        }
        // l2vpn / pw-class * / encapsulation mpls
        container mpls {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-l2vpn-pwc-mpls";
          // l2vpn / pw-class * / encapsulation mpls / control-word
          leaf control-word {
            tailf:info "Enable Control word";
            type empty;
          }
          // l2vpn / pw-class * / encapsulation mpls / protocol ldp
          container protocol {
            tailf:info "Set the dynamic pseudowire signaling protocol";
            leaf ldp {
              tailf:info "Set LDP as the signaling protocol for this "+
                "pseudowire class";
              type empty;
            }
          }
          // l2vpn / pw-class * / encapsulation mpls / transport-mode
          container transport-mode {
            tailf:info "Remote transport mode";
            choice transport-mode-choice {
              leaf ethernet {
                tailf:info "Ethernet port mode";
                type empty;
              }
              container vlan {
                tailf:info "Vlan tagged mode";
                tailf:cli-delete-when-empty;
                presence true;
                leaf passthrough {
                  tailf:info "passthrough incoming tags";
                  type empty;
                }
              }
            }
          }
          // l2vpn / pw-class * / encapsulation mpls / ipv4 source
          container ipv4 {
            tailf:info "Set the local source IPv4 address";
            leaf source {
              tailf:info "The local source IPv4 address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;The source address";
              }
            }
          }
        }
      }
    }

    // l2vpn / xconnect
    container xconnect {
      tailf:info "Configure cross connect commands";

      // l2vpn / xconnect group *
      list group {
        tailf:info "Specify the group the cross connects belong to";
        tailf:cli-mode-name "config-l2vpn-xc";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the cross connects group";
          }
        }

        // l2vpn / xconnect group * / mp2mp *
        list mp2mp {
          tailf:info "Specify the MP2MP instance name";
          tailf:cli-mode-name "config-l2vpn-xc-mp2mp";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the MP2MP instance";
            }
          }
          container autodiscovery {
            tailf:info "Enable auto-discovery in this MP2MP";
            container bgp {
              tailf:info "Enable BGP auto-discovery in this MP2MP";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad";
              leaf rd {
                tailf:info "route distinguisher";
                type string;
              }
            }
          }
        }

        // l2vpn / xconnect group * / p2p *
        list p2p {
          tailf:info "Configure point to point cross connect commands";
          tailf:cli-mode-name "config-l2vpn-xc-p2p";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the point to point cross connect";
            }
          }

          // l2vpn / xconnect group * / p2p * / interface
          list interface {
            tailf:info "Specify the attachment circuit";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / monitor-session
          leaf monitor-session {
            tailf:info "Specify the monitor session";
            type string {
              tailf:info "WORD;;Name of the monitor session";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:monitor-session/name";
            }
          }

          // l2vpn / xconnect group * / p2p * / neighbor *
          list neighbor {
            tailf:info "Specify the peer to cross connect";
            tailf:cli-mode-name "config-l2vpn-xc-p2p-pw";
            key "address pw-id";
            leaf address {
              type string {
                tailf:info "IP address of the peer";
              }
            }
            leaf pw-id {
              tailf:info "Specify the pseudowire id";
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudowire ID";
              }
            }
            leaf ip-version {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ipv4 {
                  tailf:info "Specify IPv4 address or hostname";
                }
                enum ipv6 {
                  tailf:info "Specify IPv6 address or host name";
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / mpls
            container mpls {
              tailf:info "MPLS L2VPN PW command";
              container static {
                tailf:info "MPLS L2VPN static settings";
                container label {
                  tailf:info "MPLS L2VPN static labels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf local {
                    tailf:info "Local pseudowire label";
                    tailf:cli-incomplete-command;
                    type uint16 {
                      tailf:info "<4017-15999>;;Local pseudowire label";
                      range "4017..15999";
                    }
                  }
                  leaf remote {
                    tailf:info "Remote pseudowire label";
                    type uint32 {
                      tailf:info "<16-1048575>;;Remote pseudowire label";
                      range "16..1048575";
                    }
                  }
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / pw-class
            leaf pw-class {
              tailf:info "PW class template name to use for this XC";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Pseudowire-class name";
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / l2tp
            container l2tp {
              tailf:info "L2TP PW";
              container static {
                tailf:info "L2TP PW static";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-l2tp";
                container local {
                  tailf:info "L2TP PW static local";
                  container cookie {
                    tailf:info "L2TP PW static local cookie settings";
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf size {
                      tailf:info "L2TP PW static local cookie size settings";
                      type enumeration {
                        enum 0 {
                          tailf:info "The cookie size is zero bytes";
                        }
                        enum 4 {
                          tailf:info "The cookie size is four bytes";
                        }
                        enum 8 {
                          tailf:info "The cookie size is eight bytes";
                        }
                      }
                    }
                    container "value" {
                      tailf:info "The value of the cookie";
                      tailf:cli-sequence-commands;
                      tailf:cli-compact-syntax;
                      tailf:cli-flatten-container;
                      when "../size != 0";
                      leaf value-1 {
                        tailf:cli-drop-node-name;
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                        }
                      }
                      leaf value-2 {
                        tailf:cli-drop-node-name;
                        when "../../size != 4";
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                        }
                      }
                    }
                  }
                }
                container remote {
                  tailf:info "L2TP PW static remote";
                  container cookie {
                    tailf:info "L2TP PW static remote cookie settings";
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf size {
                      tailf:info "L2TP PW static remote cookie size settings";
                      type enumeration {
                        enum 0 {
                          tailf:info "The cookie size is zero bytes";
                        }
                        enum 4 {
                          tailf:info "The cookie size is four bytes";
                        }
                        enum 8 {
                          tailf:info "The cookie size is eight bytes";
                        }
                      }
                    }
                    container "value" {
                      tailf:info "The value of the cookie";
                      tailf:cli-sequence-commands;
                      tailf:cli-compact-syntax;
                      tailf:cli-flatten-container;
                      when "../size != 0";
                      leaf value-1 {
                        tailf:cli-drop-node-name;
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                        }
                      }
                      leaf value-2 {
                        tailf:cli-drop-node-name;
                        when "../../size != 4";
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                        }
                      }
                    }
                  }
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / source
            leaf source {
              tailf:info "Source address of PW";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Source IPv6 address of PW";
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / backup
            container backup {
              tailf:info "Backup pseudowire for the cross connect";
              list neighbor {
                tailf:info "Specify the peer to cross connect";
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-backup";
                key "address pw-id";
                leaf address {
                  type string {
                    tailf:info "IP address of the peer";
                  }
                }
                leaf pw-id {
                  tailf:info "Specify the pseudowire id";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Pseudowire ID";
                  }
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / bridge group *
    container bridge {
      tailf:info "Configure bridge commands";

      list group {
        tailf:info "Specify the group the bridge belongs to";
        tailf:cli-mode-name "config-l2vpn-bg";
        key group-name;
        leaf group-name {
          type string {
            tailf:info "WORD;;Name of the bridge group";
          }
        }

        // l2vpn / bridge group * / bridge-domain *
        list bridge-domain {
          tailf:info "Configure bridge domain";
          tailf:cli-mode-name "config-l2vpn-bg-bd";
          key bridge-domain-name;
          leaf bridge-domain-name {
            type string;
          }

          // l2vpn / bridge group * / bridge-domain * / interface *
          list interface {
            tailf:info "Assign interface to bridge domain";
            tailf:cli-mode-name "config-l2vpn-bg-bd-ac";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / mac
            container mac {
              tailf:info "MAC configuration commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-ac-mac";
              uses l2vpn-bridge-domain-mac-grouping;
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / storm-control
            container storm-control {
              tailf:info "Storm Control";
              container broadcast {
                tailf:info "Broadcast Storm Control";
                leaf pps {
                  tailf:info "Set the storm control pps";
                  type uint32 {
                    tailf:info "<1-160000>;;storm control pps value";
                    range "1..160000";
                  }
                }
              }
              container multicast {
                tailf:info "Multicast Storm Control";
                leaf pps {
                  tailf:info "Set the storm control pps";
                  type uint32 {
                    tailf:info "<1-160000>;;storm control pps value";
                    range "1..160000";
                  }
                }
              }
              container unknown-unicast {
                tailf:info "Unknown-unicast Storm Control";
                leaf pps {
                  tailf:info "Set the storm control pps";
                  type uint32 {
                    tailf:info "<1-160000>;;storm control pps value";
                    range "1..160000";
                  }
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / igmp
            container igmp {
              tailf:info "IGMP protocol";
              container snooping {
                tailf:info "Set the snooping profile";
                leaf profile {
                  tailf:info "Attach a IGMP profile";
                  type string {
                    tailf:info "WORD;;IGMP Snooping profile name";
                  }
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / neighbor *
          list neighbor {
            tailf:info "Specify the peer to cross connect";
            tailf:cli-mode-name "config-l2vpn-bg-bd-pw";
            key "address pw-id";
            leaf address {
              type string {
                tailf:info "IP address of the peer";
              }
            }
            leaf pw-id {
              tailf:info "Specify the pseudowire id";
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudowire ID";
                range "1..4294967295";
              }
            }
            container mpls {
              tailf:info "MPLS L2VPN PW command";
              container static {
                tailf:info "MPLS L2VPN static settings";
                container label {
                  tailf:info "MPLS L2VPN static labels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf local {
                    tailf:info "Local pseudowire label";
                    tailf:cli-incomplete-command;
                    type uint16 {
                      tailf:info "<4017-15999>;;Local pseudowire label";
                      range "4017..15999";
                    }
                  }
                  leaf remote {
                    tailf:info "Remote pseudowire label";
                    type uint32 {
                      tailf:info "<16-1048575>;;Remote pseudowire label";
                      range "16..1048575";
                    }
                  }
                }
              }
            }
            leaf pw-class {
              tailf:info "PW class template name to use for this pseudowire";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Pseudowire-class name";
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / mac
          container mac {
            tailf:info "MAC configuration commands";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-bg-bd-mac";
            uses l2vpn-bridge-domain-mac-grouping;
            // l2vpn / bridge group * / bridge-domain * / mac / withdraw
            container withdraw {
              tailf:info "MAC withdraw";
              leaf state-down {
                tailf:info "MAC withdraw sent on bridge port down";
                type empty;
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / mtu
          leaf mtu {
            tailf:info "Maximum transmission unit (payload) for this "+
              "Bridge Domain";
            type uint16 {
              tailf:info "<46-65535>;;Maximum transmission unit size "+
                "(payload) in bytes";
              range "46..65535";
            }
          }

          // l2vpn / bridge group * / bridge-domain * / routed
          container routed {
            tailf:info "Bridge domain L3 interface";
            list interface {
              tailf:info "Assign interface to bridge domain";
              key name;
              leaf name {
                type string {
                  tailf:info "BVI;;Bridge-Group Virtual Interface";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / vfi *
          list vfi {
            tailf:info "Specify the virtual forwarding interface name";
            tailf:cli-mode-name "config-l2vpn-bg-bd-vfi";
            key name;
            leaf name {
              tailf:info "WORD;;Name of the Virtual Forwarding Interface";
              type string;
            }
            // l2vpn / bridge group * / bridge-domain * / vfi * / vpn-id
            leaf vpn-id {
              tailf:info "VPN Identifier (VPN ID)";
              type uint32 {
                tailf:info "<1-65535>;;Value of the VPN ID";
                range "1..65535";
              }
            }
            // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp
            container autodiscovery {
              tailf:info "Enable auto-discovery in this VFI";
              container bgp {
                tailf:info "Enable BGP auto-discovery in this VFI";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad";
                leaf rd {
                  tailf:info "route distinguisher";
                  type string;
                }
                // l2vpn / bridge group * / bridge-domain * / vfi * /
                //    autodiscovery bgp / route-target *
                list route-target {
                  tailf:info "Route Target";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Route Target";
                    }
                  }
                  leaf as-number {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;AS number in 2-byte, 4-byte asdot and "+
                        "IP address";
                    }
                  }
                }
                container signaling-protocol {
                  tailf:info "Enable signaling protocol for this VFI";
                  container ldp {
                    tailf:info "Enable LDP signaling protocol for this VFI";
                    tailf:cli-add-mode;
                    tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad-sig";
                    presence true;
                  }
                }
              }
            }
            // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor *
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-pw";
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// extcommunity-set
  /// ========================================================================

  container extcommunity-set {
    tailf:info "Define an extended community set";

    list rt {
      tailf:info "BGP Route Target (RT) extended community";
      tailf:cli-mode-name "config-ext";
      tailf:cli-reset-container;
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Route Target type extcommunity set name";
        }
      }
      list set {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key "value";
        leaf "value" {
          tailf:cli-multi-word-key;
          tailf:cli-disallow-value "end-set|abort|exit";
          type string;
        }
      }
    }
  }


  /// ========================================================================
  /// rd-set
  /// ========================================================================

  list rd-set {
    tailf:info "Define a BGP VPN route-distinguisher set";
    tailf:cli-mode-name "config-rd";
    tailf:cli-reset-container;
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Route Distinguisher set name";
      }
    }

    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key "value";
      leaf "value" {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-set|abort|exit";
        type string;
      }
    }
  }


  /// ========================================================================
  /// prefix-set
  /// ========================================================================

  list prefix-set {
    tailf:info "Define a prefix set";
    tailf:cli-mode-name "config-pfx";
    tailf:cli-reset-container;
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Prefix setname";
      }
    }

    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key "value";
      leaf "value" {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-set|abort|exit";
        type string;
      }
    }
  }


  /// ========================================================================
  /// as-path-set
  /// ========================================================================

  list as-path-set {
    tailf:info "Define an AS-path set";
    tailf:cli-mode-name "config-as";
    tailf:cli-reset-container;
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;AS-path set name";
      }
    }

    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key "value";
      leaf "value" {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-set|abort|exit";
        type string;
      }
    }
  }


  /// ========================================================================
  /// community-set
  /// ========================================================================

  list community-set {
    tailf:info "Define a community set";
    tailf:cli-mode-name "config-comm";
    tailf:cli-reset-container;
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Community set name";
      }
    }

    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key "value";
      leaf "value" {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-set|abort|exit";
        type string;
      }
    }
  }


  /// ========================================================================
  /// route-policy
  /// ========================================================================

  list route-policy {
    tailf:info "Define a route policy";
    tailf:cli-mode-name "config-rpl";
    tailf:cli-delete-when-empty;
    tailf:cli-exit-command "end-policy";
    tailf:cli-full-command;
    tailf:cli-reset-container;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Route Policy name";
      }
    }

    leaf "value" {
      tailf:cli-drop-node-name;
      type string;
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    /// router static
    // router static
    container static {
      tailf:info "Static route configuration subcommands";
      tailf:cli-add-mode;
      uses router-static-grouping;

      // router static / vrf *
      list vrf {
        tailf:info "VRF Static route configuration subcommands";
        tailf:cli-mode-name "config-static-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-static-grouping;
      }
    }

    /// router igmp
    // router igmp
    container igmp {
      tailf:info "IPv4 Address Family";
      tailf:cli-add-mode;
      presence true;

      // router igmp / explicit-tracking
      container explicit-tracking {
        tailf:info "IGMPv3 explicit host tracking";
        presence true;
      }

      // router igmp / interface *
      list interface {
        tailf:info "IGMP interface configuration subcommands";
        tailf:cli-mode-name "config-igmp-default-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router igmp / interface * / version
        leaf version {
          tailf:info "IGMP version";
          type uint8 {
            tailf:info "<1-3>;;version number";
          }
        }

        // router igmp / interface * / router
        leaf router {
          tailf:info "Enable/Disable Router side functionality in IGMP";
          type enumeration {
            enum disable {
              tailf:info "Disable Router side functionality in IGMP";
            }
            enum enable {
              tailf:info "Enable Router side functionality in IGMP";
            }
          }
        }

        // router igmp / interface * / join-group *
        list join-group {
          tailf:info "IGMP join multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          choice source-choice {
            leaf source-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Source address to include";
              }
            }
            leaf exclude {
              tailf:info "Exclude the only following source address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Source address to exclude";
              }
            }
          }
        }
      }

      // router igmp / vrf *
      list vrf {
        tailf:info "VRF configs";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        leaf access-group {
          tailf:info "IGMP group access group";
          type string {
            tailf:info "WORD;;IP Named Standard Access list";
          }
        }
      }
    }

    /// router isis
    // router isis
    container isis {
      tailf:info "ISO IS-IS";
      tailf:cli-incomplete-command;
      // router isis *
      list tag {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-isis";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }

        // router isis * / set-overload-bit
        container set-overload-bit {
          tailf:info "Signal other routers not to use us in SPF";
          tailf:cli-display-separated;
          presence true;

          // router isis * / set-overload-bit
          list level-list {
            tailf:info "Set overload-bit for one level only";
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-2>;;Level";
                range "1..2";
              }
            }
            leaf on-startup {
              tailf:cli-prefix-key;
              type union {
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise "
                    +"ourself as overloaded after reboot";
                  range "5..86400";
                }
                type enumeration {
                  enum wait-for-bgp {
                    tailf:info "Let BGP decide when to unset the overload bit";
                  }
                }
              }
            }
            container advertise {
              tailf:info "If overload-bit set advertise the following "+
                "types of IP prefixes";
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "If overload-bit set advertise IP prefixes "+
                  "learned from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "If overload-bit set advertise IP prefixes "+
                  "learned from another ISIS level";
                type empty;
              }
            }
          }

          // router isis * / set-overload-bit suppress
          container suppress {
            tailf:info "If overload-bit set, suppress the following "
              +"types of IP prefixes";
            tailf:cli-compact-syntax;
            leaf external {
              tailf:info "If overload-bit set, don't advertise IP "
                +"prefixes learned from other protocols";
              type empty;
            }
            leaf interlevel {
              tailf:info "If overload-bit set, don't advertise IP "
                +"prefixes learned from another ISIS level";
              type empty;
            }
          }
        }

        // router isis * / is-type
        leaf is-type {
          tailf:info "IS Level for this routing process (OSI only)";
          type enumeration {
            enum level-1 {
              tailf:info "Act as a station router only";
            }
            enum level-1-2 {
              tailf:info "Act as both a station router and an area router";
            }
            enum level-2-only {
              tailf:info "Act as an area router only";
            }
          }
        }

        // router isis * / net *
        list net {
          tailf:info "A Network Entity Title for this process (OSI only)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type string {
              tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
            }
          }
        }

        // router isis * / nsf
        container nsf {
          tailf:info "Non-stop forwarding";
          choice nsf-choice {
            container advertise {
              tailf:info "Send information to neighbors";
              leaf holdtime {
                tailf:info "Adjust holdtime advertised in IIH when RR set";
                type uint16 {
                  tailf:info "<5-3600>;;Seconds";
                  range "5..3600";
                }
              }
            }
            leaf cisco {
              tailf:info "Checkpoint method";
              type empty;
            }
            leaf ietf {
              tailf:info "IETF method";
              type empty;
            }
            container interface {
              tailf:info "Interface properties";
              leaf wait {
                tailf:info "Maximum time to wait for interface up";
                type uint8 {
                  tailf:info "<1-60>;;Seconds";
                  range "1..60";
                }
              }
            }
            leaf interval {
              tailf:info "Minimum required stable interval between restarts";
              type uint16 {
                tailf:info "<0-1440>;;Minutes";
                range "0..1440";
              }
            }
            container t3 {
              tailf:info "Time to set overload-bit if LSPDB "
                +"synchronization not completed (T3 expiration)";
              choice t3-choice {
                leaf adjacency {
                  tailf:info "Use minimum advertised adjacency holdtime"
                    +" for NSF T3 timeout";
                  type empty;
                }
                leaf manual {
                  tailf:info "Manually configure NSF T3 timeout";
                  type uint16 {
                    tailf:info "<5-3600>;;Seconds";
                    range "5..3600";
                  }
                }
              }
            }
          }
        }

        // router isis * / log
        container log {
          tailf:info "Log changes in adjacency state";
          container adjacency {
            tailf:info "Enable logging of adjacency state";
            leaf changes {
              tailf:info "Enable logging adjacency state changes";
              type empty;
            }
          }
          container pdu {
            tailf:info "Enable PDU logging";
            leaf drops {
              tailf:info "Enable logging PDU drops";
              type empty;
            }
          }
        }

        // router isis * / lsp-gen-interval
        container lsp-gen-interval {
          tailf:info "System and Pseudonode LSP generation "+
            "scheduling parameters";
          leaf maximum-wait {
            type uint16 {
              range "1..65535";
            }
          }
          leaf initial-wait {
            type uint16 {
              range "1..65535";
            }
          }
          leaf secondary-wait {
            type uint16 {
              range "1..65535";
            }
          }
        }

        // router isis * / lsp-refresh-interval
        leaf lsp-refresh-interval {
          tailf:info "Set LSP refresh interval";
          type uint16 {
            range "1..65535";
          }
        }

        // router isis * / lsp-password
        container lsp-password {
          tailf:info "Configure the area password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf auth-type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
              }
              enum text {
                tailf:info "Use cleartext password authentication";
              }
            }
          }
          leaf enc-type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum clear {
                tailf:info "Specifies an unencrypted password will follow";
              }
              enum encrypted {
                tailf:info "Specifies an encrypted password will follow";
              }
            }
          }
          choice password-choice {
            leaf password {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;The unencrypted (clear text) LSP/SNP password";
              }
            }
            leaf keychain {
              tailf:info "Specifies a Key Chain name will follow";
              type string {
                tailf:info "WORD;;The Key Chain name";
              }
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:key/chain/name";
              }
            }
          }
          leaf level {
            tailf:cli-break-sequence-commands;
            tailf:info "Set lsp-password for one level only";
            type uint8 {
              tailf:info "<1-2>;;Set lsp-password for LSPs/SNPs "+
                "at this level only";
              range "1..2";
            }
          }
          leaf send-only  {
            tailf:info "Authenticate outgoing LSPs/SNPs only";
            type empty;
          }
          leaf snp {
            tailf:info "Specify SNP packets authentication mode";
            type empty;
          }
        }

        // router isis * / max-lsp-lifetime
        leaf max-lsp-lifetime {
          tailf:info "Set maximum LSP lifetime";
          type uint16 {
            tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
            range "1..65535";
          }
        }

        // router isis * / address-family
        container address-family {
          tailf:info "Enter the IS-IS address-family "+
            "configuration submode";
          uses router-isis-address-family-grouping;
        }

        // router isis * / interface *
        list interface {
          tailf:info "Enter the IS-IS interface configuration submode";
          tailf:cli-mode-name "config-isis-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          leaf interface-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum active {
              }
              enum passive {
                tailf:info "Do not establish adjacencies over this interface";
              }
              enum suppressed {
                tailf:info "Do not advertise connected prefixes of "+
                  "this interface";
              }
              enum shutdown {
                tailf:info "Shutdown IS-IS on this interface";
              }
            }
          }

          // router isis / interface * / circuit-type
          leaf circuit-type {
            tailf:info "Configure circuit type for interface";
            type enumeration {
              enum level-1 {
                tailf:info "Form level-1 adjacencies only";
              }
              enum level-1-2 {
                tailf:info "Form level-1 and level-2 adjacencies";
              }
              enum level-2-only {
                tailf:info "Form level-2 adjacencies only";
              }
            }
          }

          // router isis / interface * / bfd
          container bfd {
            tailf:info "Configure BFD parameters";
            leaf fast-detect {
              tailf:info "Enable Fast detection";
              tailf:cli-full-command;
              type enumeration {
                enum ipv4 {
                  tailf:info "Address Family";
                }
                enum ipv6 {
                  tailf:info "Address Family";
                }
                enum disable {
                }
              }
            }
            leaf minimum-interval {
              tailf:info "Hello interval";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<15-30000>;;hello interval in milli-seconds";
              }
            }
            leaf multiplier {
              tailf:info "Detect multiplier";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<2-50>;;Detect multiplier";
              }
            }
          }

          // router isis / interface * / point-to-point
          leaf point-to-point {
            tailf:info "Treat active LAN interface as point-to-point";
            tailf:cli-full-command;
            type empty;
          }

          // router isis / interface * / hello-padding
          leaf hello-padding {
            tailf:info "Add padding to IS-IS hello packets";
            tailf:cli-full-command;
            type enumeration {
              enum disabled {
                tailf:info "Disable hello-padding";
              }
              enum enabled {
                tailf:info "Enable hello-padding during adjacency "+
                  "formation only";
              }
            }
          }

          // router isis / interface * / hello-password
          container hello-password {
            tailf:info "Configure the IIH password";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            choice authentication-choice {
              leaf keychain {
                tailf:info "Specifies a Key Chain name will follow";
                tailf:cli-optional-in-sequence;
                tailf:cli-disallow-value "keychain|accept|hmac-md5|text|clear|encrypted";
                type string {
                  tailf:info "WORD;;The Key Chain name";
                }
                //tailf:non-strict-leafref {
                //path "/cisco-ios-xr:key/chain/name"; // keychain ISIS
                //}
              }
              leaf accept {
                tailf:info "Use password for incoming authentication only";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf text {
                tailf:info "Use cleartext password authentication";
                tailf:cli-optional-in-sequence;
                type empty;
              }
            }
            choice password-choice {
              leaf clear {
                when "not(../keychain)" {
                  tailf:dependency "../keychain";
                }
                tailf:info "Specifies an unencrypted password will follow";
                type string {
                  tailf:info "WORD;;The unencrypted (clear text) hello password";
                }
              }
              leaf encrypted {
                when "not(../keychain)" {
                  tailf:dependency "../keychain";
                }
                tailf:info "Specifies an encrypted password will follow";
                type string {
                  tailf:info "WORD;;The encrypted hello password";
                }
              }
              leaf password {
                when "not(../keychain)" {
                  tailf:dependency "../keychain";
                }
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "keychain|accept|hmac-md5|text"+
                  "|clear|encrypted|level|send-only";
                type string {
                  tailf:info "WORD;;The unencrypted (clear text) hello password";
                }
              }
            }
            leaf level {
              tailf:info "Set hello-password for one level only";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;Set hello-password for IIHs at this level only";
                range "1..2";
              }
            }
            leaf send-only {
              tailf:info "Do not require authentication of incoming IIHs";
              type empty;
            }
          }

          // router isis / interface * / link-down
          container link-down {
            tailf:info "Configure interface down event parameters";
            leaf fast-detect {
              tailf:info "Enable high priority detection";
              type empty;
            }
          }

          // router isis / interface * / address-family
          container address-family {
            tailf:info "Enter the IS-IS interface address-family "+
              "configuration submode";
            uses router-isis-address-family-grouping;
          }
        }

        // router isis * / authentication
        container authentication {
          tailf:info "ISIS authentication for LSPs";
          container key-chain {
            tailf:info "Authentication key-chain";

            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ref {
              tailf:cli-drop-node-name;
              type string {
              }
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:key/chain/name";
              }
            }
            leaf level {
              tailf:cli-drop-node-name;
              type enumeration {
                enum level-1 {
                  tailf:info "ISIS authentication for level-1";
                }
                enum level-2 {
                  tailf:info "ISIS authentication for level-2";
                }
              }
            }
          }
          container mode {
            tailf:info "Authentication mode";
            choice mode-choice {
              container md5 {
                tailf:info "Keyed message digest";
                presence true;
                leaf level {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum level-1 {
                      tailf:info "ISIS authentication for level-1";
                    }
                    enum level-2 {
                      tailf:info "ISIS authentication for level-2";
                    }
                  }
                }
              }

              container text {
                tailf:info "Clear text password";
                presence true;
                leaf level {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum level-1 {
                      tailf:info "ISIS authentication for level-1";
                    }
                    enum level-2 {
                      tailf:info "ISIS authentication for level-2";
                    }
                  }
                }
              }
            }
          }
          //  send-only  Authentication send only, receive ignore
        }

        // router isis * / metric-style
        leaf metric-style {
          tailf:info "Use old-style (ISO 10589) or new-style packet formats";
          type enumeration {
            enum narrow {
              tailf:info "Use old style of TLVs with narrow metric";
            }
            enum transition {
              tailf:info "Send and accept both styles of TLVs "
                +"during transition";
            }
            enum wide {
              tailf:info "Use new style of TLVs to carry wider metric";
            }
          }
        }

        // router isis * / bfd
        container bfd {
          tailf:info "BFD configuration commands";
          leaf all-interfaces {
            tailf:info "Enable BFD on all interfaces";
            type empty;
          }
          leaf check-ctrl-plane-failure {
            tailf:info "BFD check control plane failure";
            type empty;
          }
        }

        // router isis * / mpls
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";
          leaf ldp {
            tailf:info "routing protocol commands for MPLS LDP";
            type enumeration {
              enum "sync" {
                tailf:info "Configure LDP-IGP Synchronization";
              }
            }
          }
          // router isis * / mpls traffic-eng
          container traffic-eng {
            tailf:info "routing protocol commands for MPLS Traffic Engineering";
            leaf level-1 {
              tailf:info "Run MPLS TE on IS-IS level 1 only";
              type empty;
            }
            leaf level-2 {
              tailf:info "Run MPLS TE on IS-IS level 2 only";
              type empty;
            }
            leaf multicast-intact {
              tailf:info "MPLS TE and PIM interaction";
              type empty;
            }
            leaf router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              type empty;
            }
            leaf scanner {
              tailf:info "Timer parameters for TE database";
              type empty;
            }
          }
        }
      }
    }

    /// router ospf *
    // router ospf *
    list ospf {
      tailf:info "OSPF configuration subcommands";
      tailf:cli-mode-name "config-ospf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for this OSPF process";
        }
      }

      uses router-ospf-grouping;

      // router ospf * / mpls
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";
        container traffic-eng {
          tailf:info "Routing protocol commands for MPLS Traffic Engineering";
          container router-id {
            tailf:info "Traffic Engineering stable IP address for system";
            tailf:cli-diff-dependency "/cisco-ios-xr:interface";
            uses interface-name-grouping;
          }
        }
        container ldp {
          tailf:info "Configure LDP parameters";
          leaf sync {
            tailf:info "Enable LDP IGP synchronization";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // router ospf * / vrf *
      list vrf {
        tailf:info "Enter the OSPF vrf configuration submode";
        tailf:cli-mode-name "config-ospf-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name for this OSPF vrf";
          }
        }
        // router ospf * / vrf * / ?
        uses router-ospf-grouping;
      }
    }

    /// router ospfv3 *
    // router ospfv3 *
    list ospfv3 {
      tailf:info "IPv6 Open Shortest Path First protocol (OSPFv3)";
      tailf:cli-mode-name "config-ospfv3";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for this OSPFv3 process";
        }
      }

      uses router-ospfv3-grouping;

      // router ospfv3 * / vrf *
      list vrf {
        tailf:info "Enter the OSPFv3 vrf configuration submode";
        tailf:cli-mode-name "config-ospfv3-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name for this OSPFv3 vrf";
          }
        }
        // router ospfv3 * / vrf * / ?
        uses router-ospfv3-grouping;
      }

    }

    /// router bgp *
    // router bgp *
    container bgp {
      tailf:info "BGP configuration subcommand";

      // router bgp *
      list bgp-no-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp";
        key id;
        leaf id {
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern "[0-9]+\.[0-9]+";
            }
          }
        }
        uses router-bgp-grouping;
      }

      // router bgp * instance
      list bgp-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp";
        key "id instance";
        leaf id {
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern "[0-9]+\.[0-9]+";
            }
          }
        }
        leaf instance {
          tailf:cli-expose-key-name;
          type string;
        }
        uses router-bgp-grouping;
      }
    }

    /// router mld
    // router mld
    container mld {
      tailf:info "IPv6 address family";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mld";
      list interface {
        tailf:info "MLD interface configuration subcommands";
        tailf:cli-mode-name "config-mld-default-if";
        key name;
        leaf name {
          type string;
        }
        leaf router {
          tailf:info "Enable/Disable Router side functionality in MLD";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable Router side functionality in MLD";
            }
            enum disable {
              tailf:info "Disable Router side functionality in MLD";
            }
          }
        }
      }
      leaf version {
        tailf:info "MLD version";
        type uint8 {
          tailf:info "<1-2>;;version number";
          range "1..2";
        }
      }
    }

    /// router pim
    // router pim
    container pim {
      tailf:info "PIM configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pim";

      // router pim / address-family ipv4
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Enter ipv4 Address Family command mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pim-default-ipv4";

          // router pim / address-family ipv4 / hello-interval
          leaf hello-interval  {
            tailf:info "Inherited by all interfaces : Hello interval in seconds";
            type uint16 {
              tailf:info "<1-3600>;;Hello interval in seconds";
              range "1..3600";
            }
          }

          // router pim / address-family ipv4 / auto-rp
          container auto-rp {
            tailf:info "Auto-RP Commands";
            container listen {
              tailf:info "RP discovery through AUTORP protocol";
              leaf disable {
                tailf:info "Disable RP discovery through the AUTORP protocol";
                type empty;
              }
            }
          }

          // router pim / address-family ipv4 / rp-address *
          list rp-address {
            tailf:info "Configure Rendezvous Point";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key name;
            leaf name {
              type inet:host {
                tailf:info "IP name or address of Rendezvous Point";
              }
            }
            leaf group-access-list {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "WORD;;Access list of groups that should map "+
                  "to given RP";
              }
            }
            leaf override {
              tailf:info "Static RP config overrides auto-rp and BSR";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf bidir {
              tailf:info "Specify keyword bidir to configure a bidir RP";
              type empty;
            }
          }

          // router pim / address-family ipv4 / spt-threshold
          container spt-threshold {
            tailf:info "Configure threshold for switching to SPT on last-hop";
            container infinity {
              tailf:info "Always stay on shared-tree";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf group-list {
                tailf:info "Only stay on the shared-tree for specified groups";
                type string {
                  tailf:info "WORD;;Access-list of threshold limited groups";
                }
              }
            }
          }

          // router pim / address-family ipv4 / neighbor-check-on-recv
          container neighbor-check-on-recv {
            tailf:info "Check for PIM neighbor before rcv'ing control messages";
            leaf enable {
              tailf:info "Enable this feature";
              type empty;
            }
          }

          // router pim / address-family ipv4 / neighbor-check-on-send
          container neighbor-check-on-send {
            tailf:info "Check for PIM neighbor before sending control messages";
            leaf enable {
              tailf:info "Enable this feature";
              type empty;
            }
          }

          // router pim / address-family ipv4 / nsf lifetime
          container nsf {
            tailf:info "Configure Non-stop forwarding (NSF) options"+
              "(cisco-support)";
            leaf lifetime {
              tailf:info "Override default maximum lifetime for PIM NSF mode";
              type uint16 {
                tailf:info "<10-600>;;Maximum time for PIM NSF mode in seconds";
                range "10..600";
              }
            }
          }

          // router pim / address-family ipv4 / log neighbor
          container log {
            tailf:info "Enable PIM logging";
            container neighbor {
              tailf:info "Enable PIM neighbor logging";
              leaf changes {
                tailf:info "Enable PIM neighbor state logging";
                type empty;
              }
            }
          }

          // router pim / address-family ipv4 / interface *
          list interface {
            tailf:info "PIM interface configuration subcommands";
            tailf:cli-mode-name "config-pim-ipv4-if";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // router pim / address-family ipv4 / interface * / bfd
            container bfd {
              tailf:info "Configure BFD parameters";

              // router pim / address-family ipv4 / interface * / bfd minimum-interval
              leaf minimum-interval {
                tailf:info "Hello interval";
                type uint32 {
                  tailf:info "<15-30000>;;hello interval in milli-seconds";
                  range "15..30000";
                }
              }

              // router pim / address-family ipv4 / interface * / bfd fast-detect
              container fast-detect {
                tailf:info "Enable Fast detection";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence true;
                leaf disable {
                  tailf:info "Prevent bfd settings from being inherited "+
                    "from the parent";
                  type empty;
                }
              }

              // router pim / address-family ipv4 / interface * / bfd multiplier
              leaf multiplier {
                tailf:info "Detect multiplier";
                type uint8 {
                  tailf:info "<2-50>;;Detect multiplier";
                  range "2..50";
                }
              }
            }
          }
        }

        // router pim / address-family ipv6
        container ipv6 {
          tailf:info "Enter ipv6 Address Family command mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mcast-default-ipv6";
          list interface {
            tailf:info "PIM interface configuration subcommands";
            tailf:cli-mode-name "config-pim-ipv6-if";
            key name;
            leaf name {
              type string;
            }
            leaf enable {
              tailf:info "Enable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
          }
          leaf neighbor-check-on-recv {
            tailf:info "Check for PIM neighbor before rcv'ing control "+
              "messages";
            tailf:cli-full-command;
            type enumeration {
              enum enable {
                tailf:info "Enable this feature";
              }
            }
          }
          leaf neighbor-check-on-send {
            tailf:info "Check for PIM neighbor before sending control "+
              "messages";
            tailf:cli-full-command;
            type enumeration {
              enum enable {
                tailf:info "Enable this feature";
              }
            }
          }
        }
      }
    }

    /// router vrrp
    // router vrrp
    container vrrp {
      tailf:info "VRRP configuration subcommands";
      tailf:cli-add-mode;

      // router vrrp / interface *
      list interface {
        tailf:cli-mode-name "config-vrrp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router vrrp / interface * / bfd
        container bfd {
          tailf:info "Configure BFD parameters";

          // router vrrp / interface * / bfd minimum-interval
          leaf minimum-interval {
            tailf:info "Hello interval";
            type uint16 {
              tailf:info "<15-30000>;;hello interval in milli-seconds";
              range "15..30000";
            }
          }

          // router vrrp / interface * / bfd multiplier
          leaf multiplier {
            tailf:info "Detect multiplier";
            type uint8 {
              tailf:info "<2-50>;;Detect multiplier";
              range "2..50";
            }
          }
        }

        // router vrrp / interface * / address-family ipv4
        container address-family {
          tailf:info "VRRP address family";

          container ipv4 {
            tailf:info "IPv4 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrrp-address-family";

            // router vrrp / interface * / address-family ipv4 / vrrp *
            list vrrp {
              tailf:cli-mode-name "config-vrrp-virtual-router";
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-255>;;VRID Virtual Router Identifier";
                  range "1..255";
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / priority
              leaf priority {
                tailf:info "Set priority level";
                tailf:cli-full-command;
                type uint8 {
                  tailf:info "<1-254>;;Priority value";
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / preempt
              container preempt {
                tailf:info "Preempt Master router if higher priority";
                choice preempt-choice {
                  leaf delay {
                    tailf:info "Wait before preempting";
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-3600>;;Number of seconds to delay";
                      range "1..3600";
                    }
                  }
                  leaf disable {
                    tailf:info "Disable preemption";
                    type empty;
                  }
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / timer
              container timer {
                tailf:info "Set advertisement timer";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                choice timer-choice {
                  leaf time-value {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-255>;;Advertisement time in seconds";
                    }
                  }
                  leaf msec {
                    tailf:info "Configure in milliseconds";
                    tailf:cli-incomplete-command;
                    type uint16 {
                      tailf:info "<100-3000>;;Advertisement time in "+
                        "milliseconds (100-3000)";
                    }
                  }
                }
                leaf force {
                  tailf:info "Force the configured values to be used "+
                    "(required for msec)";
                  type empty;
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / track *
              container track {
                tailf:info "Track an item, reducing priority if it goes down";
                list interface {
                  tailf:info "Track an interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Interface Name";
                    }
                  }
                  leaf priority {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-254>;;Priority decrement";
                      range "1..254";
                    }
                  }
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / address *
              list address {
                tailf:info "Enable VRRP and specify IP address(es)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key ip;
                leaf ip {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;VRRP IPv4 address";
                  }
                }
                leaf secondary {
                  tailf:info "Set Secondary VRRP IP address";
                  type empty;
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / bfd
              container bfd {
                tailf:info "Configure BFD parameters";
                container fast-detect {
                  tailf:info "Enable Fast detection";
                  container peer {
                    tailf:info "Information about VRRP peer for BFD monitoring";
                    leaf ipv4 {
                      tailf:info "BFD peer interface IPv4 address";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;VRRP BFD remote interface IP address";
                      }
                    }
                  }
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / text-authentication
              leaf text-authentication {
                tailf:info "Set plain text authentication string";
                type string {
                  tailf:info "WORD;;Authentication password, 8 chars max";
                  length "1..8";
                }
              }
            }
          }
        }
      }
    }

    /// router hsrp
    // router hsrp
    container hsrp {
      tailf:info "HSRP configuration subcommands";
      tailf:cli-add-mode;

      // router hsrp / interface *
      list interface {
        tailf:cli-mode-name "config-hsrp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router hsrp / interface * / address-family ipv4
        container address-family {
          tailf:info "HSRP address family";
          container ipv4 {
            tailf:info "IPv4 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-hsrp-ipv4";

            // router hsrp / interface * / address-family ipv4 / hsrp
            container hsrp {
              tailf:info "HSRP group configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-hsrp-gp";
              uses router-hsrp-group-grouping;
            }

            // router hsrp / interface * / address-family ipv4 / hsrp *
            container hsrp-version1-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                uses router-hsrp-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp version 2
            container hsrp-version2 {
              tailf:cli-drop-node-name;
              container hsrp {
                tailf:info "HSRP group configuration";
                list version {
                  tailf:cli-mode-name "config-hsrp-gp";
                  key version;
                  leaf version {
                    type enumeration {
                      enum "2" {}
                    }
                  }
                  uses router-hsrp-group-grouping;
                }
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp * version 2
            container hsrp-version2-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key "id version";
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                leaf version {
                  tailf:info "HSRP version";
                  tailf:cli-expose-key-name;
                  type uint8 {
                    tailf:info "<2>;;HSRP version number";
                    range "2";
                  }
                }
                uses router-hsrp-group-grouping;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// rsvp
  /// ========================================================================

  container rsvp {
    tailf:info "Global RSVP configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    // rsvp / interface *
    list interface {
      tailf:info "Enable RSVP on an interface";
      tailf:cli-mode-name "config-rsvp-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // rsvp / interface * / bandwidth
      container bandwidth {
        tailf:info "Configure RSVP bandwidth parameters";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf total-reservable {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Total reservable bandwidth "+
              "(in Kbps, Mbps or Gbps)";
          }
        }
        leaf total-reservable-unit {
          when "../total-reservable" {
            tailf:dependency "../total-reservable";
          }
          tailf:cli-drop-node-name;
          type enumeration {
            enum Gbps {
              tailf:info "BW in Gbps";
            }
            enum Kbps {
              tailf:info "BW in Kbps (Default)";
            }
            enum Mbps {
              tailf:info "BW in Mbps";
            }
          }
        }
      }

      // rsvp / interface * / signalling
      container signalling {
        tailf:info "Configure RSVP signalling parameters";
        leaf dscp {
          tailf:info "Set DSCP for RSVP signalling messages";
          type uint8 {
            tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
            range "0..63";
          }
        }
      }

    }

    // rsvp / signalling
    container signalling {
      tailf:info "Configure global RSVP signalling parameters";
      container graceful-restart {
        tailf:info "Configure RSVP Graceful-Restart parameters";
        tailf:cli-delete-when-empty;
        presence true;
      }
    }

    // rsvp / authentication
    container authentication {
      tailf:info "Configure RSVP authentication parameters";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-rsvp-auth";
      container key-source {
        tailf:info "Specify key-source for authenticating RSVP "+
          "signalling messages";
        leaf key-chain {
          tailf:info "Use key-chain to authenticate RSVP signalling messages";
          type string {
            tailf:info "WORD;;Name of key-chain";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";
    tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl";

    // mpls label
    container label {
      tailf:info "Label properties";
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        type enumeration {
          enum ldp {
            tailf:info "Use LDP (default)";
          }
          enum tdp {
            tailf:info "Use TDP";
          }
        }
      }
      container "range" {
        tailf:info "Label range";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16-524287>;;Minimum label value for"
              +" dynamic label range";
            range "16..524287";
          }
        }

        leaf max {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<11000-524287>;;Maximum label value"
              +" for dynamic label range";
            range "11000..524287";
          }
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ldp";

      // mpls ldp / router-id
      leaf router-id {
        tailf:info "Configure router Id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address to be used";
        }
      }

      // mpls ldp / discovery
      container discovery {
        tailf:info "Configure discovery parameters";

        // mpls ldp / discovery instance-tlv
        container instance-tlv {
          tailf:info "Control support for Neighbor instance TLV in "+
            "Hello messages";
          leaf disable {
            tailf:info "Disable transmit and receive processing for TLV";
            tailf:cli-full-command;
            type empty;
          }
        }

        // mpls ldp / discovery hello
        container hello {
          tailf:info "LDP Link Hellos";
          leaf holdtime {
            tailf:info "Hello holdtime";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds)";
              range "1..65535";
            }
          }
        }

        container targeted-hello {
          tailf:info "LDP Targeted Hellos";
          container accept {
            tailf:info "Accept and respond to targeted hellos";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf from {
              tailf:info "IP Access list to specify acceptable targeted "+
                "hello sources";
              type string {
                tailf:info "WORD;;access-list";
              }
            }
          }
        }
      }

      // mpls ldp / graceful-restart
      container graceful-restart {
        tailf:info "Configure graceful restart feature";
        tailf:cli-delete-when-empty;
        presence true;
      }

      // mpls ldp / holdtime
      leaf holdtime {
        tailf:info "Configure session holdtime";
        type uint16 {
          tailf:info "<15-65535>;;Time (seconds)";
        }
      }

      // mpls ldp / session
      container session {
        tailf:info "Configure session parameters";
        container protection {
          tailf:info "Configure session protection parameters";
          presence true;
        }
      }

      // mpls ldp / neighbor
      container neighbor {
        tailf:info "Configure neighbor parameters";
        container password {
          tailf:info "Configure password for MD5 authentication "+
            "for all neighbors";
          choice password-choice {
            leaf clear {
              tailf:info "Specifies an unencrypted password will follow";
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
              }
            }
            leaf encrypted {
              tailf:info "Specifies an encrypted password will follow";
              type string {
                tailf:info "WORD;;The ENCRYPTED neighbor password string";
              }
            }
          }
        }
      }

      // mpls ldp / igp
      container igp {
        tailf:info "Configure IGP related parameters";
        container sync {
          tailf:info "Configure LDP-IGP synchronization parameters";
          container delay {
            tailf:info "Configure sync up delay after session up";
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<5-300>;;Interface sync-up delay (seconds)";
                range "5..300";
              }
            }
          }
        }
      }

      // mpls ldp / nsr
      leaf nsr {
        tailf:info "Configure Non-Stop Routing";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp / password
      container password {
        tailf:info "Configure LDP MD5 password";
        //  fallback  Specifies a fallback password will follow
        container option {
          tailf:info "LDP password options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf sequence-nr {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-32767>;;Sequence number of the"
                +" LDP password option";
              range "1..32767";
            }
          }
          leaf "for" {
            tailf:info "IP access-list specifying control on LDP peers";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; "
                +"name or number (1-99)";
            }
          }
          leaf enc-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum 7 {
                tailf:info "Specifies a HIDDEN password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
            }
          }
        }
        container required {
          tailf:info "MD5 password is required for the peer";
          tailf:cli-reset-container;
          presence true;
          leaf for {
            tailf:info "IP access-list specifying control on LDP peers";
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; "
                +"name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp / label
      container label {
        tailf:info "Configure label allocation, advertisement, and acceptance";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-lbl";
        // mpls ldp / label / allocate
        container allocate {
          tailf:info "Configure label allocation control";
          leaf "for" {
            tailf:info "Limit label allocation to a set of prefixes";
            type string;
          }
        }
        // mpls ldp / label / advertise
        container advertise {
          tailf:info "Configure outbound label advertisement control";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-lbl-advt";
          leaf disable {
            tailf:info "Disable label advertisement to all peers for all "+
              "prefixes";
            tailf:cli-full-command;
            type empty;
          }
          leaf "for" {
            tailf:info "Prefix centric outbound label filtering";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;IP access-list name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp / log
      container log {
        tailf:info "Configure logging of LDP events";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-log";
        leaf neighbor {
          tailf:info "Neighbor events";
          tailf:cli-full-command;
          type empty;
        }
        leaf graceful-restart {
          tailf:info "Graceful Restart events";
          type empty;
        }
        leaf session-protection {
          tailf:info "Session Protection events";
          type empty;
        }
        leaf nsr {
          tailf:info "NSR synchronization events";
          tailf:cli-full-command;
          type empty;
        }
      }

      // mpls ldp / interface *
      list interface {
        tailf:info "Enable LDP on an interface and enter interface submode";
        tailf:cli-mode-name "config-ldp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
      }
    }

    // mpls oam
    container oam {
      tailf:info "OAM configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-oam";
      container echo {
        tailf:info "Echo request attributes";
        leaf disable-vendor-extension {
          tailf:info "Disable sending vendor extension TLV with echo req";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mpls static
    container static {
      tailf:info "Configure static MPLS forwarding";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls-static";

      // mpls static / ipv4 *
      list ipv4 {
        tailf:info "Configure MPLS static IPv4 imposition";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key "address mask interface";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 mask";
          }
        }
        leaf interface {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf nexthop {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of next hop router";
          }
        }
        choice label-choice {
          leaf label {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<16-1048575>;;Outgoing label";
            }
          }
          leaf ipv4-explicit-null  {
            tailf:info "IPv4 explicit null";
            type empty;
          }
          leaf ipv6-explicit-null {
            tailf:info "IPv6 explicit null";
            type empty;
          }
          container pop {
            tailf:cli-compact-syntax;
            tailf:info "Pop label";
            presence true;
            choice pop-choice {
              leaf labelled {
                tailf:info "Pop label to MPLS only";
                type empty;
              }
              leaf unlabelled {
                tailf:info "Pop label to non-MPLS only";
                type empty;
              }
            }
          }
        }
      }

      // mpls static / interface *
      list interface {
        tailf:info "Enable MPLS Static on an interface";
        key name;
        tailf:cli-suppress-mode;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }

      // mpls static / address-family ipv4 unicast
      container address-family {
        tailf:info "Configure Address Family and its parameters";
        list ipv4 {
          tailf:info "Configure IPv4 Address Family parameters";
          tailf:cli-mode-name "config-mpls-static-af";
          tailf:cli-full-command;
          key af-modifier;
          leaf af-modifier {
            type enumeration {
              enum unicast {
                tailf:code-name "ipv4_unicast";
                tailf:info "Unicast";
              }
            }
          }
          // mpls static / address-family ipv4 * / local-label *
          list local-label {
            tailf:info "Configure local label assignment and forwarding";
            tailf:cli-mode-name "config-mpls-static-af-lbl";
            tailf:cli-incomplete-command;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint32 {
                tailf:info "<16-1048575>;;Label value";
                range "16..1048575";
              }
            }
            leaf allocate {
              tailf:info "Label Allocation Option";
              tailf:cli-hide-in-submode;
              type empty;
            }
            leaf per-prefix {
              tailf:info "For a given prefix";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;IPv4 Prefix";
              }
            }
            container forward {
              tailf:cli-break-sequence-commands;
              tailf:info "Configure forwarding rewrites";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-mpls-static-af-lbl-fwd";
              list "path" {
                tailf:info "Configure cross-connect path parameters";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-1>;;Path count";
                  }
                }
                leaf nexthop {
                  tailf:info "nexthop";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Interface name";
                  }
                }
                leaf nexthop-address {
                  tailf:cli-optional-in-sequence;
                  tailf:cli-incomplete-command;
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Next-hop IPv4 address";
                  }
                }
                leaf out-label {
                  tailf:info "output label";
                  type union {
                    type uint32 {
                      tailf:info "<16-1048575>;;Output MPLS label value";
                      range "16..1048575";
                    }
                    type enumeration {
                      enum exp-null {
                        tailf:info "Set the output label to explicit null";
                      }
                      enum pop {
                        tailf:info "Pop off the top of the label stack";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // mpls static / vrf *
      list vrf {
        tailf:info "Configure VRF parameters";
        tailf:cli-mode-name "config-mpls-static-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Specify the VRF Name";
          }
        }

        // mpls static / vrf * / address-family ipv4 unicast
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          list ipv4 {
            tailf:info "Configure IPv4 Address Family parameters";
            tailf:cli-mode-name "config-mpls-static-vrf-af";
            tailf:cli-full-command;
            key af-modifier;
            leaf af-modifier {
              type enumeration {
                enum unicast {
                  tailf:code-name "mpls_static_vrf_ipv4_unicast";
                  tailf:info "Unicast";
                }
              }
            }
            // mpls static / vrf * / address-family ipv4 unicast / local-label *
            list local-label {
              tailf:info "Configure local label assignment and forwarding";
              tailf:cli-mode-name "config-mpls-static-vrf-af-lbl";
              tailf:cli-incomplete-command;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint32 {
                  tailf:info "<16-1048575>;;Label value";
                  range "16..1048575";
                }
              }
              leaf allocate {
                tailf:info "Label Allocation Option";
                tailf:cli-incomplete-command;
                tailf:cli-hide-in-submode;
                type empty;
              }
              choice allocate-choice {
                leaf per-prefix {
                  tailf:info "For a given prefix";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type ipv4-prefix {
                    tailf:info "A.B.C.D/length;;IPv4 Prefix";
                  }
                }
                leaf per-vrf {
                  tailf:info "For a VRF";
                  tailf:cli-hide-in-submode;
                  type empty;
                }
              }
              // mpls static / vrf * / address-family ipv4 unicast /
              //    local-label * / forward
              container forward {
                when "../per-vrf";
                tailf:cli-break-sequence-commands;
                tailf:info "Configure forwarding rewrites";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-mpls-static-vrf-af-lbl-fwd";
                list "path" {
                  tailf:info "Configure cross-connect path parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-incomplete-command;
                  key id;
                  leaf id {
                    tailf:cli-suppress-range;
                    type uint8 {
                      tailf:info "<1-1>;;Path count";
                    }
                  }
                  leaf pop-and-lookup {
                    tailf:info "Pop and lookup";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Go into the MPLS-TE submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls-te";

      // mpls traffic-eng / auto-tunnel
      container auto-tunnel {
        tailf:info "Automatically created tunnel configuration";
        // mpls traffic-eng / auto-tunnel backup
        container backup {
          tailf:info "Enter the auto-tunnel backup configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mpls-te-auto-bk";
          container timers {
            tailf:info "Auto-tunnel backups related timers";
            container removal {
              tailf:info "Auto-tunnel backups removal timers";
              leaf unused {
                tailf:info "Auto-tunnel backups unused removal timer";
                type uint16 {
                  tailf:info "<0-10080>;;Auto-tunnel backup unused timeout "+
                    "in minutes (0=never timeout)";
                  range "0..10080";
                }
              }
            }
          }
          container tunnel-id {
            tailf:info "Specify Tunnel ID range (modify may result "+
              "auto-tunnel delete)";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel backups";
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for "+
                  "auto-tunnel backups";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel backups";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for "+
                  "auto-tunnel backups";
              }
            }
          }
        }
      }
      // mpls traffic-eng / interface *
      list interface {
        tailf:info "Enable MPLS-TE on an interface";
        tailf:cli-mode-name "config-mpls-te-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        // mpls traffic-eng / interface * / bfd fast-detect
        container bfd {
          tailf:info "Configure BFD parameters";
          leaf fast-detect {
            tailf:info "Enable Fast detection";
            type empty;
          }
        }
        // mpls traffic-eng / interface * / auto-tunnel backup
        container auto-tunnel {
          tailf:info "Auto-tunnel configuration";
          container backup {
            tailf:info "Enable the auto-tunnel backup feature on an interface";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-mpls-te-if-auto-backup";
            presence true;
            // mpls traffic-eng / interface * / auto-tunnel backup / exclude
            container exclude {
              tailf:info "Restrict auto-tunnel backup path based on "+
                "specific criteria.";
              container srlg {
                tailf:info "Backup requires SRLG exclusion from protected "+
                  "interface";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf preferred {
                  tailf:info "SRLG exclusion is preferred but not mandatory";
                  type empty;
                }
              }
            }
          }
        }
      }
      // mpls traffic-eng / logging events
      container logging {
        tailf:info "MPLS Traffic-Eng. logging configuration";
        container events {
          tailf:info "Global logging events";
          leaf frr-protection {
            tailf:info "Enable protection change Syslog";
            tailf:cli-full-command;
            type empty;
          }
          leaf preemption {
            tailf:info "Enable Tunnel Preemption alarms";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      // mpls traffic-eng / soft-preemption
      container soft-preemption {
        tailf:info "Enable soft-preemption";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-soft-preemption";
        leaf timeout {
          tailf:info "Specify a timeout for soft-preempted LSP";
          type uint32 {
            tailf:info "<1-300>;;Timeout for soft-preempted LSP in seconds:"+
              "default 60";
            range "1..300";
          }
        }
      }
      // mpls traffic-eng / auto-bw
      container auto-bw {
        tailf:info "Auto-bandwidth configuration";
        container collect {
          tailf:info "Auto-bandwidth collection parameters";
          leaf frequency {
            tailf:info "Auto-bandwidth collection frequency parameter";
            type uint16 {
              tailf:info "<1-10080>;;Auto-bandwidth collection frequency "+
                "in minutes";
              range "1..10080";
            }
          }
        }
      }
      // mpls traffic-eng / reoptimize
      container reoptimize {
        tailf:info "MPLS TE Reoptimize config";
        leaf "value" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-604800>;;Reoptimize timers frequency (secs)";
            range "0..604800";
          }
        }
        container timers {
          tailf:info "Reoptimization timers";
          container delay {
            tailf:info "Delay reoptimization action";
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              type uint16 {
                tailf:info "<0-300>;;Seconds to delay cleanup of "+
                  "reoptimized LSP";
                range "0..300";
              }
            }
            leaf installation {
              tailf:info "Delay replacement of current LSP by reoptimized LSP";
              type uint16 {
                tailf:info "<0-3600>;;Seconds to delay replacement of "+
                  "tunnel LSP";
                range "0..3600";
              }
            }
            leaf path-protection {
              tailf:info "Time between path protection switchover event and "+
                "tunnel re-optimization";
              type uint32 {
                tailf:info "<0-604800>;;Seconds between path protection "+
                  "switchover event and tunnel re-optimization. "+
                  "Set to 0 to disable";
                range "0..604800";
              }
            }
          }
        }
      }
      // mpls traffic-eng / bfd
      container bfd {
        tailf:info "Configure BFD parameters";
        leaf multiplier {
          tailf:info "Detect multiplier";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<2-10>;;Detect multiplier";
            range "2..10";
          }
        }
        leaf minimum-interval {
          tailf:info "Hello interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<15-200>;;hello interval in milli-seconds";
            range "15..200";
          }
        }
      }
      // mpls traffic-eng / fast-reroute
      container fast-reroute {
        tailf:info "Fast-reroute config parameters";
        container timers {
          tailf:info "Configure fast-reroute timer";
          leaf promotion {
            tailf:info "Configure how often we scan for LSP backup promotion";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;Seconds between promotions "+
                "(0 disables promotion)";
              range "0..604800";
            }
          }
        }
      }
      // mpls traffic-eng / link-management
      container link-management {
        tailf:info "MPLS Link Manager subcommands";
        container timers {
          tailf:info "MPLS Link Manager Timer subcommands";
          container preemption-delay {
            tailf:info "Delay LSP preemption";
            leaf bundle-capacity {
              tailf:info "Bundle capacity change preemption delay timer";
              type uint16 {
                tailf:info "<0-300>;;Bundle capacity change preemption "+
                  "timer value (seconds)";
                range "0..300";
              }
            }
          }
        }
      }
    }

    // mpls ip-ttl-propagate
    container ip-ttl-propagate {
      tailf:info "Propagate IP TTL into the label stack";
      container disable {
        tailf:info "Disable IP TTL propagation";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf disable-type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum forwarded {
              tailf:info "Disable IP TTL propagation for only forwarded "+
                "MPLS packets";
            }
            enum local {
              tailf:info "Disable IP TTL propagation for only locally "+
                "generated MPLS packets";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// multicast-routing
  /// ========================================================================

  container multicast-routing {
    tailf:info "Enable IP multicast forwarding";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-mcast";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "/cisco-ios-xr:interface";

    container address-family {
      tailf:info "Enter Address Family command mode";

      // multicast-routing / address-family ipv4
      container ipv4 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mcast-default-ipv4";

        // multicast-routing / address-family ipv4 / interface *
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name "config-mcast-default-ipv4-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf enable {
            tailf:info "Enable IP multicast";
            tailf:cli-full-command;
            type empty;
          }
          leaf boundary {
            tailf:info "Boundary for administratively scoped multicast "+
              "addresses";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Access list specifying scoped multicast "+
                "groups";
            }
          }
        }

        // multicast-routing / address-family ipv4 / nsf
        leaf nsf {
          tailf:cli-full-command;
          type empty;
        }

        // multicast-routing / address-family ipv4 / log-traps
        leaf log-traps {
          tailf:info "Enable logging trap events";
          type empty;
        }

        // multicast-routing / address-family ipv4 / mdt source
        container mdt {
          tailf:info "MVPN configuration";
          container source {
            tailf:info "Interface used to set MDT source address";
            tailf:cli-diff-dependency "/cisco-ios-xr:interface";
            uses interface-name-grouping;
          }
        }

        // multicast-routing / address-family ipv4 / multipath
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          presence true;
        }

        // multicast-routing / address-family ipv4 / ssm
        container ssm {
          tailf:info "Configure a group range for Source-Specific use";
          leaf "range" {
            tailf:info "Provide ACL that specifies non-standard SSM range";
            type string {
              tailf:info "WORD;;Access list specifying SSM group range";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
            }
          }
          leaf allow-override {
            tailf:info "Allow SSM ranges to be overridden by more "+
              "specific ranges";
            type empty;
          }
        }

        // multicast-routing / address-family ipv4 / oom-handling
        container oom-handling {
          tailf:info "Enable out-of-memory handling";
          presence true;
        }

        // multicast-routing / address-family ipv4 / rate-per-route
        leaf rate-per-route {
          tailf:info "Enable/disable per (S,G) rate calculation";
          tailf:cli-full-command;
          type empty;
        }

        // multicast-routing / address-family ipv4 / accounting
        container accounting {
          tailf:info "Enable/disable Accounting";
          container per-prefix {
            tailf:info "Enable per (S,G) accounting.";
            presence true;
          }
        }
      }

      // multicast-routing / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv6";
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name "config-mcast-default-ipv6-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf enable {
            tailf:info "Enable IP multicast";
            tailf:cli-full-command;
            type empty;
          }
        }
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          presence true;
        }
      }
    }
  }


  /// ========================================================================
  /// xxyyzztop
  /// ========================================================================

  leaf xxyyzztop {
    tailf:info "Internal state variable, do not modify.";
    tailf:cli-run-template "";
    tailf:cli-show-with-default;
    type uint16;
    default "0";
  }

}


/// ========================================================================
//                          EOF
/// ========================================================================
